<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第二份工作</title>
      <link href="/2019/05/09/%E7%AC%AC%E4%BA%8C%E4%BB%BD%E5%B7%A5%E4%BD%9C/"/>
      <url>/2019/05/09/%E7%AC%AC%E4%BA%8C%E4%BB%BD%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>今天2019/5/9，周四，待业两个多月，投的简历没有一个面试机会，这两个月期间一共有两场面试，<br>第一个是360企业安全的服务器开发-Java岗，怎么说呢，从4月19日做完笔试题，以为没希望了，然后10天后通知面试，也就是在4月26日，我去现场面试了<br><a id="more"></a><br>约的11：20,但是因为签到排队面试，等了一会，然后到我的时候面试官又有事走了，于是等到了13：50才开始面试，期间我去旁边的麦当劳吃了顿饭<br>面试之前，真的是无比的紧张，第一次到大公司面试，然而面试的时候，一点紧张感都没有了，但是也就意味着我凉了<br>首先一道算法题，很简单的一个链表题，先说思想，再写主要的代码，思想对了，代码错了，，，，<br>开始正式面试，上来问我为什么选Java，讲一下Java？？？？套路不一样啊，讲一下就为难我这个嘴笨的人了<br>记录一下提问的问题吧：<br><code>1. 什么是封装（回答的他不满意）</code><br><code>2. 包装类的缓存，好的我答对了</code><br><code>3. url过程需要的协议？emmmm，链路层和物理层的没想起来，也就是ARP和MAC</code><br><code>4. JDK10新特性？回答了</code><br><code>5. Spring生命周期？艾玛，忘掉了</code><br>问了很多，现在想想其实挺基础的，奈何自己不用功   </p><p>第二个是“东营汉威油田技术公司”，招聘信息是导员发的，面试的时候，负责人说在北京的这个，已经是一个子公司了“北京汉威胜业石油技术开发有限公司”，<br>面试的时候，很简单，也可能是因为内推的关系吧，问了一下项目就没有别的了，然后就是介绍公司<br>作为一个油田领域上的技术公司，其实发展挺好的，毕竟油田国家垄断嘛，也有自己的研究院（副院长是本校老师，但是没记住是谁），北京的公司主要是负责客户方面（忘了怎么说了），其实就是将东西呈现给客户<br>公司之前在西二旗，现在是在一个居民楼，说是省下钱发奖金？？<br>薪资的话，很低，是真的很低，而且不知道一年涨一次还是两次，还是看着来<br>上班时间很爽，8小时，听说加班有加班费？<br>一年多少薪也没说，主要我也忘了问，啊啊啊啊，保险也忘了问<br>最最主要的是，让我转语言！！！！！<br>我特么坚持了那么久Java，一心想走Java，现在这么可笑的么？？？虽然C#发展也很好<br>但是坚持了那么久的东西，说换就换，不甘心<br>———- 分割线 ——————–<br>刚写到这里，就来了一个口头面试，boss上投简历，第一个面试机会，还真不容易<br>不说了，复习去了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手四次挥手</title>
      <link href="/2019/04/02/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/04/02/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h1><p>本篇文章讲解的是TCP协议三次握手和四次挥手的一个详情。<br><a id="more"></a></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><span id="transport">传输层</span></h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;传输层,顾名思义就是数据之间的通信的，那么这个通信是什么样子的呐，分布式的呀！！！他会利用网络层(他的下方)提供的服务，去源主机的应用进程上和目的主机进行一个<code>端到端</code>的连接<br>提问：  </p><blockquote><p>传输层之间传输的报文称之为什么？  </p></blockquote><p>答：</p><blockquote><p>TPDU-传输协议数据单元<br>全称为：Transport Protocol Data Unit<br>代表从一个传输实体发送到另一个传输实体的消息  </p></blockquote><p>其实在传输层，主要复习的是两个协议：</p><ol><li>传输控制协议TCP，全双工哦（双方可以并行发送数据）</li><li>用户数据报协议UDP </li></ol><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><span id="TCP">TCP</span></h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于三握四挥<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;TCP协议，是一个<code>面向连接的、可靠、基于字节流</code>的传输协议（所以相对UDP较慢），那么TCP是如何通信的呐（其实就是三次握手），既然可以通信，那么也就是说也可以断开通信咯，emmmm,怎么断！（大家挥挥手就断了）</p><p><strong>三次握手</strong>  </p><p>传输说明：</p><blockquote><p>SYN = 同步位，建立连接的时候必须要带上的，而且，人家虽然没有数据传输，但是还是要消耗一个序号的<br>seq = 序号，无论什么情况，只要是发送数据，都必须带一个序号<br>ACK = 是用来确认报文滴，只有两个值0和1，1代表确认<br>ack = 是对对方数据的确认号 = 对方的序号+1</p></blockquote><p>状态说明：</p><blockquote><p>CLOSED = 代表关闭状态<br>LISTEN = 收听状态<br>SYN_SENTT = 同步发送状态<br>SYN_RCVD = 同步收到状态<br>ESTAB_LISTHED = 已建立连接状态   </p></blockquote><p><img src="/2019/04/02/三次握手四次挥手/README/woshou.png" alt=""></p><p>至此，双方已经连接上了，这里需要注意的是，自己的序号每次都是+1的，那么发送的确认号，是<code>对方</code>的序号+1</p><p><strong>四次挥手</strong>  </p><p>说明：</p><blockquote><p>FIN = 终止控制位，和SYN一样，即使不携带数据，也是需要一个序号位的。  </p></blockquote><blockquote><p>ESTABLISHED = 建立连接<br>FIN_WAIT-1 = 终止等待1<br>FIN_WAIT-2 = 终止等待2<br>CLOSE_WAIT = 关闭等待<br>TIME_WAIT = 时间等待，一般设为2MSL(Maximum Segment Lifetime,建议设为2分钟)</p></blockquote><p><img src="/2019/04/02/三次握手四次挥手/README/huishou.png" alt=""></p><p>了解他的机制之后，那么接下来就是一个问答时间了：<br>题1：  </p><blockquote><p>为什么是三握四挥？  </p></blockquote><p>答：  </p><blockquote><p>因为当服务器端接收到客户端的请求报文后，是可以直接发送SYN_ACK报文的。<br>那么关闭的时候，服务器端在接收到FIN报文后，很可能不能立即关闭SOCKET，所以此时，服务器会发送一个确认报文，告诉客户端，我已经收到你的消息了，注意，此时不是终止报文，只有当服务器端的所有报文都发送完了，那么服务器端才会发送一个FIN报文，然后客户端再告诉服务器端，嗯，我也接收到你的消息了</p></blockquote><p>题2：  </p><blockquote><p>为什么客户端再TIME_WAIT状态下必须等待2MSL的时间呐？ </p></blockquote><p>答：</p><blockquote><p>(1)保证客户端发送的最后一个ACK报文能够到达服务器端。毕竟我们的报文还是存在丢失的可能性的，如果处在LAST_WAIT状态的服务器收不到对方的确认报文，那么服务器会重新发送，那么客户端就有时间再次发送报文，然后将计时器设置为2MSL<br>(2)为了防止“已经失效的连接请求报文段”出现在本连接中。相对在下一次连接的时候，竟然还能收到上次连接时的报文，不会很头疼么？？？这就是替别人擦屁股啊！！所以就要尽可能的让他在网络中消失！</p></blockquote><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP，，用户数据报协议，是和TCP在一层的，他们都在传输层<br>Emmmm，这个东西，不大靠谱，竟然不进行连接，都不知道发送的数据是否安全的、完整的到达目的地，啧，渣男！<br>太渣了，后续再写</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树之4个迭代遍历</title>
      <link href="/2019/03/23/%E6%A0%91%E4%B9%8B4%E4%B8%AA%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
      <url>/2019/03/23/%E6%A0%91%E4%B9%8B4%E4%B8%AA%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>以下的遍历都是迭代遍历   </p><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>层次遍历用到的是广度优先算法，BFS,从根节点开始一层层的搜索，所以在遍历的时候用到了队列<br>遍历的时候用到了两层循环，因为我们需要每一层的结点，用一个list存储，如果用一层循环的话，那么就是每一个结点用一个list存储。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">     List&lt;List&lt;Integer&gt;&gt; rlt = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">     if(root == null) &#123;</span><br><span class="line">     return rlt;</span><br><span class="line">     &#125;</span><br><span class="line">     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">     queue.offer(root);</span><br><span class="line">     while(!queue.isEmpty()) &#123;</span><br><span class="line">     int count = queue.size();</span><br><span class="line">     List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">     while(count&gt;0) &#123;</span><br><span class="line">     TreeNode node = queue.poll();</span><br><span class="line">     list.add(node.val);</span><br><span class="line">     if(node.left != null) &#123;</span><br><span class="line">     queue.offer(node.left);</span><br><span class="line">     &#125;</span><br><span class="line">     if(node.right != null) &#123;</span><br><span class="line">     queue.offer(node.right);</span><br><span class="line">     &#125;</span><br><span class="line">     count--;</span><br><span class="line">     &#125;</span><br><span class="line">     rlt.add(list);</span><br><span class="line">     &#125;</span><br><span class="line">     return rlt;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>跟层次遍历不一样的是，后三种遍历都是用栈的形式，先进后出   </p><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>压栈顺序，先右后左<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">if(root == null)&#123;</span><br><span class="line">    return list;</span><br><span class="line">    &#125;</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">while(!stack.isEmpty())&#123;</span><br><span class="line">TreeNode node = stack.pop();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">if(node.right != null)&#123;</span><br><span class="line">stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">  if(node.left != null)&#123;</span><br><span class="line">stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>左孩子入栈，出栈，再开始右孩子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null||!stack.isEmpty())&#123;</span><br><span class="line">            while(root!=null)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>还没写哈哈哈哈哈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法</title>
      <link href="/2019/03/21/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/21/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>嘀嘀嘀！经典排序算法来袭，本文里面，讲解一些什么算法呢，噔噔噔噔噔，看这里：<br>冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快排  （完）<br><a id="more"></a></p><p><img src="/2019/03/21/经典排序算法/total_O.png" alt="">  </p><p>排序之前，理解一下，一下7中排序，可以分为3类<br>（1）交换排序<br>&#160;&#160;&#160;&#160;&#160;冒泡排序<br>&#160;&#160;&#160;&#160;&#160;快速排序<br>（2）插入排序<br>&#160;&#160;&#160;&#160;&#160;直接插入排序<br>&#160;&#160;&#160;&#160;&#160;希尔排序<br>（3）选择排序<br>&#160;&#160;&#160;&#160;&#160;简单选择排序<br>&#160;&#160;&#160;&#160;&#160;堆排序<br>（4）归并排序<br>&#160;&#160;&#160;&#160;&#160;归并排序  </p><p>归并排序是排序算法进行优化后，唯一稳定的（强！）</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序，是<em>相邻</em>的两个数两两对比<br>上图！（emmmmm,盗图嘎嘎嘎嘎嘎嘎）<br><img src="https://media.giphy.com/media/555q4ngZRoxHCtGSrT/giphy.gif" alt="Alt Text">  </p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">bubble(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void bubble(int[] str,int length) &#123;</span><br><span class="line">boolean flag = false;</span><br><span class="line">for(int i=0;i&lt;length-1;i++) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">for(int j=0;j&lt;length-1-i;j++) &#123;</span><br><span class="line">if(str[j]&gt;str[j+1]) &#123;</span><br><span class="line">int tmp = str[j];</span><br><span class="line">str[j] = str[j+1];</span><br><span class="line">str[j+1] = tmp;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            //没有进入到交换里面，说明已经排好序了，直接退出就好了</span><br><span class="line">if(!flag) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><img src="https://media.giphy.com/media/8gLh5k8Kv6rIJzkK4g/giphy.gif" alt="Alt Text"><br>第i趟找出最i小的值，每趟排序都能确定一个位置，注意这里标记的是下标哟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 直接选择排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SelectSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">select(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void select(int[] str, int length) &#123;</span><br><span class="line">int min = 0;</span><br><span class="line">int tmp;</span><br><span class="line">for(int i=0;i&lt;length-1;i++) &#123;</span><br><span class="line">min = i;</span><br><span class="line">for(int j=i+1;j&lt;length;j++) &#123;</span><br><span class="line">if(str[j]&lt;str[min]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(min != i) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">str[i] = str[min];</span><br><span class="line">str[min] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>怎么说，，这是一个我总会遗忘的排序，可能是理解的不够透彻    </p><p>认为第一个元素是已经被排序的，取出下一个元素，和前面的元素进行对比，而且是从后往前对比的，每趟排序，前i个元素都是有序的  </p><p>在简单的排序中，效率算是很高了    </p><p><img src="https://media.giphy.com/media/7zQ0f5CdcDj6D5wV4B/giphy.gif" alt="Alt Text">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 直接插入排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class InsertSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">insert(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void insert(int[] str, int length) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">int j;</span><br><span class="line">for(int i=1;i&lt;length;i++) &#123;</span><br><span class="line">if(str[i]&lt;str[i-1]) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">//从后往前哟,而且要注意j取值j&gt;0</span><br><span class="line">for(j= i;j&gt;0 &amp;&amp; str[j-1]&gt;tmp ;j--) &#123;</span><br><span class="line">//发现大的，依次往后移动一位</span><br><span class="line">str[j] = str[j-1];</span><br><span class="line">&#125;</span><br><span class="line">//那么找不到比他大的后，tmp就在该位置上</span><br><span class="line">str[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p> 希尔排序是需要一个递增序列的，先进行分组，然后再排序，它是基于插入排序的  ，那么这个递增序列，shell是有个建议的（😀）:<br>    d = n/2(向下取整)和 d(i) = d(i+1)/2(向下取整)</p><p><img src="https://media.giphy.com/media/1fWmXxhJ6Qdt1E9MHL/giphy.gif" alt="Alt Text"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ShellSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">shell(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void shell(int[] str, int length) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">int j;</span><br><span class="line">//分组：7,3,1</span><br><span class="line">for(int d= length/2;d&gt;0;d /= 2) &#123;</span><br><span class="line">for(int i=d;i&lt;length;i++) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">for(j = i;j&gt;=d &amp;&amp; str[j-d]&gt;tmp;j -= d) &#123;</span><br><span class="line">str[j] = str[j-d];</span><br><span class="line">&#125;</span><br><span class="line">str[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>大顶堆：每个结点的值都大于或等于其左右孩子结点的值<br>    a[i]&gt;=a[2<em>i+1] &amp;&amp; a[i]&gt;=a[i=2</em>i+2]<br>小顶堆：每个结点的值都小于或等于其左右孩子结点的值    </p><p>大顶堆：<br><img src="https://media.giphy.com/media/dtZVQy94EYzuxleArI/giphy.gif" alt="Alt Text">    </p><p>其实就是一个二叉树    </p><p>说明：</p><ul><li>当结点为i</li><li>那么左孩子为2*i+1;</li><li>右孩子为2*i+2;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">buildHeap(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构建大顶堆</span><br><span class="line"> * @param str</span><br><span class="line"> * @param length</span><br><span class="line"> */</span><br><span class="line">private static void buildHeap(int[] str, int length) &#123;</span><br><span class="line">//从第一个非叶子结点开始调整，从左至右，从上至下</span><br><span class="line">//-1是根据下标从0开始的习惯来的</span><br><span class="line">for(int i = length/2-1;i&gt;=0;i--) &#123;</span><br><span class="line">//构建</span><br><span class="line">heapAdjust(str, i , length);</span><br><span class="line">&#125;</span><br><span class="line">//调整</span><br><span class="line">for(int i = length-1;i&gt;0;i--) &#123;</span><br><span class="line">swap(str,0,i);//&quot;最大的&quot;进行互换</span><br><span class="line">heapAdjust(str, 0, i);//换完之后，进行调整</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] str, int i, int length) &#123;</span><br><span class="line">int tmp = str[i];</span><br><span class="line">str[i] = str[length];</span><br><span class="line">str[length] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void heapAdjust(int[] str, int i, int length) &#123;</span><br><span class="line">int j;</span><br><span class="line">int tmp;</span><br><span class="line">tmp = str[i];</span><br><span class="line">for(j = 2*i+1;j&lt;length;j*=2+1) &#123;</span><br><span class="line">//右孩子&gt;左孩子</span><br><span class="line">if(j != length-1 &amp;&amp; str[j]&lt;str[j+1]) &#123;</span><br><span class="line">j++;//指向最大的孩子</span><br><span class="line">&#125;</span><br><span class="line">if(tmp &gt;= str[j]) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str[i] = str[j];</span><br><span class="line">//注意，这里面的交换，是交换标记的位置</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>合并两个已经排好序的表，所以需要用递归将其分成最小的分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 归并排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">mergebulid(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergebulid(int[] str, int length) &#123;</span><br><span class="line">int[] tmp = new int[length];</span><br><span class="line">merge(str, tmp, 0, length-1);</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] str, int[] tmp, int left , int right) &#123;</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int center = (left+right)/2;</span><br><span class="line">merge(str, tmp, left, center);</span><br><span class="line">merge(str, tmp, center+1, right);</span><br><span class="line"></span><br><span class="line">mergeSort(str, tmp, left, center, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergeSort(int[] str, int[] tmp, int left, int center, int right) &#123;</span><br><span class="line">int i = left;</span><br><span class="line">int j = center+1;</span><br><span class="line">int k = 0;</span><br><span class="line">while(i&lt;=center &amp;&amp; j&lt;=right) &#123;</span><br><span class="line">if(str[i]&lt;str[j]) &#123;</span><br><span class="line">tmp[k++] = str[i++];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tmp[k++] = str[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;=center) &#123;</span><br><span class="line">tmp[k++] = str[i++];</span><br><span class="line">&#125;</span><br><span class="line">while(j&lt;=right) &#123;</span><br><span class="line">tmp[k++] = str[j++];</span><br><span class="line">&#125;</span><br><span class="line">//将排序好的数组拷贝到原数组中</span><br><span class="line">k = 0;</span><br><span class="line">while(left&lt;= right) &#123;</span><br><span class="line">str[left++] = tmp[k++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>快速排序就是要找一个枢纽元，常用的找枢纽元方法为：</p><ul><li>第一个元素代替，有的书上说是比较错误的做法</li><li>随机选取，是比较安全的做法</li><li>三数中值分割法<br>头，尾，中间三个数，找到枢纽元（中值），放在倒数第二个位置上</li></ul><p>快排思想：</p><ul><li>i指向第一个元素，j指向倒数第二个元素，所有的循环，必须i&lt;j</li><li>j左移，直到找到比枢纽元小的元素，或者直到i&lt;j不成立  </li><li>i右移，直到找到比枢纽元大的元素，或者直到i&lt;j不成立</li><li>如果满足i&lt;j，交换</li></ul><p>一直循环第2，3步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 快速排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class QuickSork &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">quick(str,0,str.length-1);</span><br><span class="line">for(int i=0;i&lt;str.length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void quick(int[] str, int left, int right) &#123;</span><br><span class="line">//找到枢纽元</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int pivot = median3(str,left,right);</span><br><span class="line">int i=left,j = right-1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">               //从左到右找大于pivot的值</span><br><span class="line">                //不是i++,因为第一个元素我们之前已经对比过了</span><br><span class="line">while(str[++i]&lt;pivot) &#123;&#125;</span><br><span class="line">//从右到左找到小于pivot的值</span><br><span class="line">while(j&gt;left &amp;&amp; str[--j]&gt;pivot) &#123;&#125;</span><br><span class="line">if(i&lt;j) &#123;</span><br><span class="line">swap(str, i, j);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;right) &#123;</span><br><span class="line">swap(str, i, right-1);</span><br><span class="line">&#125;</span><br><span class="line">quick(str,left,i-1);</span><br><span class="line">quick(str, i+1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int median3(int[] str, int left, int right) &#123;</span><br><span class="line">int center = (left+right)/2;</span><br><span class="line">if(str[left]&gt;str[center]) &#123;</span><br><span class="line">swap(str, left, center);</span><br><span class="line">&#125;</span><br><span class="line">if(str[center]&gt;str[right]) &#123;</span><br><span class="line">swap(str, center, right);</span><br><span class="line">&#125;</span><br><span class="line">if(str[left]&gt;str[right]) &#123;</span><br><span class="line">swap(str, left, right);</span><br><span class="line">&#125;</span><br><span class="line">swap(str, center, right-1);</span><br><span class="line">return str[right-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] str, int left, int right) &#123;</span><br><span class="line">int tmp = str[left];</span><br><span class="line">str[left] = str[right];</span><br><span class="line">str[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树之平衡二叉树</title>
      <link href="/2019/03/20/%E6%A0%91%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/03/20/%E6%A0%91%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>是二叉排序树的一种，在二叉树中，可能会出现比较极端的二叉树，例如斜树，这样在查找的过程中，很影响效率，而平衡二叉排序树就很好的解决了这个问题。<br><a id="more"></a><br>AVL（和AVL算法有区别）,要么是一棵空树，要么左右子树都是平衡二叉树，且左右子树的深度之差的绝对值不超过1，算法复杂度O(lon(n))<br>又名平衡二叉搜索树Self-balancing binary search tree  </p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><ol><li>红黑树<br>一种自平衡二叉查找树，可以用于实现关联数组，又称为“对称二叉B树”</li><li><p>AVL<br>最早的自平衡二叉查找树算法，也是高度平衡树</p></li><li><p>替罪羊树</p></li><li>Treap<br>一棵二叉排序树，记录一个额外的数据（优先级），有堆的性质</li><li>伸展树<br>Splay Tree ,一种二叉排序树，优势为不需要记录用于平衡树的冗余信息</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>将一棵二叉树，变成平衡二叉树，依靠的是旋转，通常会出现四种情况<br>（1）左旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_left.png" alt=""><br>（2）右旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_right.png" alt=""><br>（3）左右旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_leftright.png" alt=""><br>（4）右左旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_rightleft.png" alt=""></p><p>总之，什么时候双旋转呢？那就是bf符号不一致的时候，<br>什么时候会失去平衡呢，简单总结就是4句话  </p><ul><li>在左孩子的左子树上插入元素 - 右旋转</li><li>在左孩子的右子树上插入元素 - 左右旋转</li><li>在右孩子的右子树上插入元素 - 左旋转</li><li>在右孩子的左子树上插入元素 - 右左旋转<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>设一个平衡因子bf<br>IF 平衡因子 &gt;=2<br>&#160;&#160;&#160;&#160;IF 左结点的平衡因子 &lt;0<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;左旋转然后右旋转<br>&#160;&#160;&#160;&#160;&#160;ELSE<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;右旋转<br>ELSE IF 平衡因子 &lt;=-2<br>&#160;&#160;&#160;&#160;&#160;&#160;IF 右结点的平衡因子 &gt;0<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;右旋转<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ELSE<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;左旋转</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.tree;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 平衡二叉树</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AVL &#123;</span><br><span class="line">private static final int ALLOWED_IMBALANCE = 1;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str = &#123;10,5,8,20,16,1,3,7,25&#125;;</span><br><span class="line">Tree tree = new Tree(str[0]);</span><br><span class="line">for(int i=1;i&lt;str.length;i++) &#123;</span><br><span class="line">insertAvl(tree,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">print(tree);</span><br><span class="line">System.out.println();</span><br><span class="line">remove(tree,10);</span><br><span class="line">print(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除某个结点</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param i</span><br><span class="line"> */</span><br><span class="line">private static Tree remove(Tree tree, int key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">if(key&lt;tree.getData()) &#123;</span><br><span class="line">tree.setLchild(remove(tree.getLchild(), key));</span><br><span class="line">&#125; else if(key&gt;tree.getData()) &#123;</span><br><span class="line">tree.setRchild(remove(tree.getRchild(), key));</span><br><span class="line">&#125;else if(tree.getLchild() != null &amp;&amp; tree.getRchild() != null) &#123;</span><br><span class="line">tree.setData(findMin(tree.getRchild()).getData());</span><br><span class="line">tree.setRchild(remove(tree.getRchild(), tree.getData()));</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = (tree.getLchild() != null)?tree.getLchild():tree.getRchild();</span><br><span class="line">&#125;</span><br><span class="line">return balanceAVL(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 找到右子树中最小的左子树（后继结点）</span><br><span class="line"> * @param data</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree findMin(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree;</span><br><span class="line">while(tree.getLchild() != null) &#123;</span><br><span class="line">tree = tree.getLchild();</span><br><span class="line">tmp = tree;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(tmp.getData());</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算平衡因子</span><br><span class="line"> */</span><br><span class="line">private static int hight(Tree tree) &#123;</span><br><span class="line">return tree == null ?-1 :tree.getBf();</span><br><span class="line">&#125;</span><br><span class="line">private static void print(Tree tree) &#123;</span><br><span class="line">if(tree != null) &#123;</span><br><span class="line">print(tree.getLchild());</span><br><span class="line">System.out.print(tree.getData()+&quot; &quot;);</span><br><span class="line">print(tree.getRchild());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**  </span><br><span class="line"> * 插入</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param key  带插入的元素</span><br><span class="line"> */</span><br><span class="line">private static Tree insertAvl(Tree tree, int  key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return new Tree(key, null, null);</span><br><span class="line">&#125; else if(key &lt; tree.getData())&#123;//插入在左子树</span><br><span class="line">tree.setLchild(insertAvl(tree.getLchild(), key));</span><br><span class="line">&#125; else if(key &gt; tree.getData())&#123;</span><br><span class="line">tree.setRchild(insertAvl(tree.getRchild(), key));</span><br><span class="line">&#125;</span><br><span class="line">return balanceAVL(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否平衡</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree balanceAVL(Tree tree) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">if(hight(tree.getLchild())-hight(tree.getRchild())&gt;ALLOWED_IMBALANCE) &#123;//左子树失去了平衡</span><br><span class="line">if(hight(tree.getLchild().getLchild())&gt;=hight(tree.getLchild().getRchild())) &#123;//将值插入到右子树</span><br><span class="line">tree = rotateWithLeftChild(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = doubleWithLeftChild(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(hight(tree.getRchild())-hight(tree.getLchild())&gt;ALLOWED_IMBALANCE) &#123;</span><br><span class="line">if(hight(tree.getRchild().getRchild())&gt;=hight(tree.getRchild().getLchild())) &#123;</span><br><span class="line">tree = rotateWithRightChild(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = doubleWithRightChild(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 先左转再右转</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree doubleWithLeftChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getLchild();</span><br><span class="line">tmp.setLchild(rotateWithRightChild(tmp));</span><br><span class="line">return rotateWithLeftChild(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Tree doubleWithRightChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getRchild();</span><br><span class="line">tmp.setRchild(rotateWithLeftChild(tmp));</span><br><span class="line">return rotateWithRightChild(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 单旋转，将左子树旋转到右子树</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree rotateWithLeftChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getLchild();</span><br><span class="line">tree.setLchild(tree.getRchild());</span><br><span class="line">tmp.setRchild(tree);</span><br><span class="line">tree.setBf(Math.max(hight(tree.getLchild()), hight(tree.getRchild()))+1);</span><br><span class="line">tmp.setBf(Math.max(hight(tmp.getLchild()), tree.getBf())+1);</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Tree rotateWithRightChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getRchild();</span><br><span class="line">tree.setRchild(tree.getLchild());</span><br><span class="line">tmp.setRchild(tree);</span><br><span class="line">tree.setBf(Math.max(hight(tree.getLchild()), hight(tree.getRchild()))+1);</span><br><span class="line">tmp.setBf(Math.max(hight(tmp.getRchild()), tree.getBf())+1);</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树之二叉排序树</title>
      <link href="/2019/03/19/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
      <url>/2019/03/19/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>树里面的精华哟，因为利用了二进制<br>Binary Sort Tree 又称为二叉查找树ADT，它可以是一棵空树，或者具有一下性质的树：<br><a id="more"></a></p><ul><li>若左子树不为空，那么左子树上所有结点的值均小于根结构的值</li><li>若右子树不为空，那么右子树上所有结点的值均大于跟结构的值</li><li>它的左右子树分别为二叉排序树</li></ul><p>说明了啥呢，，，，，，哈哈哈哈，人家是递归呀  </p><p>对了，就是树的中序遍历</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean SearchBST(Tree t, int key)&#123;</span><br><span class="line">if(t == null)&#123;</span><br><span class="line">return false;</span><br><span class="line">    &#125; else if (t.data == key)&#123;</span><br><span class="line">return true;</span><br><span class="line">    &#125; else if(key&lt;t.data)&#123;</span><br><span class="line">return Search(t.lchild, key);</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">return Search(t.rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除的时候，要注意，该位置用哪个结点进行填充，有一个规则是：<br>要么是当前结点的前驱，要么是当前结点的后继（根据中序遍历的特点来的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static boolean deleteBST(Tree tree, int key) &#123;</span><br><span class="line">if(tree != null) &#123;</span><br><span class="line">if(key == tree.getData()) &#123;</span><br><span class="line">delete(tree);</span><br><span class="line">return true;</span><br><span class="line">&#125;else if(key&lt;tree.getData()) &#123;</span><br><span class="line">return deleteBST(tree.getLchild(), key);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return deleteBST(tree.getRchild(), key);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void delete(Tree tree) &#123;</span><br><span class="line">Tree q,s;//上一个结点</span><br><span class="line">if(tree.getRchild() == null) &#123;//叶子结点</span><br><span class="line">q = tree;</span><br><span class="line">//tree = tree.getLchild();</span><br><span class="line">tree.setData(tree.getLchild().getData());</span><br><span class="line">tree.setLchild(null);</span><br><span class="line">&#125; else if(tree.getLchild() == null) &#123;</span><br><span class="line">q = tree;</span><br><span class="line">//tree = tree.getRchild();</span><br><span class="line">tree.setData(tree.getRchild().getData());</span><br><span class="line">tree.setRchild(null);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">//替换直接前驱或者直接后继</span><br><span class="line">q = tree;</span><br><span class="line">s = tree.getLchild();</span><br><span class="line">while(s.getRchild() != null) &#123;</span><br><span class="line">q = s;</span><br><span class="line">s = s.getRchild();</span><br><span class="line">&#125;</span><br><span class="line">tree.setData(s.getData());</span><br><span class="line">if(q != tree) &#123;//判断有没有右子树</span><br><span class="line">q.setRchild(s.getLchild());</span><br><span class="line">&#125;else &#123;</span><br><span class="line">q.setLchild(s.getLchild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入元素</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param i</span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">private static Tree insertSort(Tree tree, int key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">tree = new Tree(key);</span><br><span class="line">return tree;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if(key&lt;=tree.getData()) &#123;</span><br><span class="line">tree.setLchild(insertSort(tree.getLchild(), key));</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree.setRchild(insertSort(tree.getRchild(), key));</span><br><span class="line">&#125;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str = &#123;111,104,105,46,115,99,70,109,67&#125;;</span><br><span class="line">Tree tree = new Tree(str[0]);</span><br><span class="line">for(int i=1;i&lt;str.length;i++) &#123;</span><br><span class="line">insertSort(tree,str[i]);</span><br><span class="line">//tmp = tree;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;中序遍历：&quot;);</span><br><span class="line">print(tree);</span><br><span class="line">//假设删除的是数据105</span><br><span class="line">if(deleteBST(tree,105)) &#123;</span><br><span class="line">System.out.print(&quot;\n删除后:&quot;);</span><br><span class="line">print(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\n删除结点不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 打印二叉树</span><br><span class="line"> * @param tree</span><br><span class="line"> */</span><br><span class="line">private static void print(Tree tree) &#123;</span><br><span class="line"></span><br><span class="line">if(tree != null)&#123;</span><br><span class="line">print(tree.getLchild());</span><br><span class="line">System.out.print(tree.getData()+&quot; &quot;);</span><br><span class="line">print(tree.getRchild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：46 67 70 99 104 105 109 111 115<br>删除后:46 67 70 99 104 109 111 115 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之关键路径</title>
      <link href="/2019/03/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/03/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li>源点<br>没有入度的顶点</li><li>汇点<br>没有出度的顶点</li><li>事件<br>顶点</li><li>活动<br>弧<a id="more"></a><h1 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h1>再带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图称为AOE网：Activity Edge Network<h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1>最长路径之和<br>关键路径是建立在拓扑序列上的</li></ol><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><h2 id="ETV"><a href="#ETV" class="headerlink" title="ETV"></a>ETV</h2><p>Earliest Time Of Vertex 时间最早发生时间，就是顶点的最早发生时间</p><h2 id="LTV"><a href="#LTV" class="headerlink" title="LTV"></a>LTV</h2><p>Latest Time Of Vertex:事件最晚发生时间，就是每个顶点对应的事件最晚需要开始的时间，如果超出此事件就会延误整个工期。</p><h2 id="ETE"><a href="#ETE" class="headerlink" title="ETE"></a>ETE</h2><p>Earliesr Time Of Edge:活动的最早开始事件，就是弧的最早发生时间</p><h2 id="LTE"><a href="#LTE" class="headerlink" title="LTE"></a>LTE</h2><p>Latest Time Of Edge:活动的最晚发生时间，就是不推迟工期的最晚开工时间。</p><p><img src="/2019/03/19/图论之关键路径/aoe_1.PNG" alt=""></p><p><img src="/2019/03/19/图论之关键路径/aoe_2.PNG" alt=""> </p><p>由此可发现：<br>ETV，ETE是顺序来的<br>LTV，LTE是逆序来的<br>ETV可以推断出ETE<br>LTV可以推断出LTE<br>关键路径：最早发生时间ETV和最晚发生时间LTV相等的时候 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之拓扑结构</title>
      <link href="/2019/03/18/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/"/>
      <url>/2019/03/18/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="无环图"><a href="#无环图" class="headerlink" title="无环图"></a>无环图</h1><p>DAG：Directed Acyclic Graph<br>五环的有向图</p><h1 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h1><p>Active On Vertex Network,有向图为顶点表示活动的网<br><a id="more"></a></p><h1 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><p>&#160;&#160;&#160;&#160;&#160;&#160;设G = (V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,…,Vn满足：若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则这样的一个顶点序列称为 拓扑序列</p><h1 id="拓扑序列-1"><a href="#拓扑序列-1" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><p>将一个有向图构造成一个拓扑序列的过程   </p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从AOV网中选择一个没有前驱的顶点（入度为0），并且输出它  </li><li>从网中删除该顶点并且删除从该顶点出发的全部有向边  </li><li>重复以上两个步骤，直到剩余网中不再存在没有前驱的顶点为止   </li></ol><p>可以用邻接表实现哟，因为要删除顶点，所以会比邻接矩阵方便一些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean topologicalSort() &#123;</span><br><span class="line">    //统计输出顶点数</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    //建栈存储入度为0的顶点</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    //统计入度数（录入也可以，但是示例图的v9的度应为2，示例图中误写为1，导致查了半天bug，自动统计入度数看来也是有必要的）</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        vexList.get(i).setIn(0);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        </span><br><span class="line">        EdgeNode edge = vexList.get(i).getFirstEdge();</span><br><span class="line">        while (edge != null) &#123;</span><br><span class="line">            VertexNode vex = vexList.get(edge.getAdjvex());</span><br><span class="line">            vex.setIn(vex.getIn() + 1);</span><br><span class="line">            </span><br><span class="line">            edge = edge.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将入度为0 的顶点入栈</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        if (vexList.get(i).getIn() == 0) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        //栈顶 顶点出栈</span><br><span class="line">        int vexIndex = stack.pop();</span><br><span class="line">        System.out.print(vexIndex + &quot;  &quot;);</span><br><span class="line">        </span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        //从顶点表结点中取出第一个边表结点</span><br><span class="line">        EdgeNode edge = vexList.get(vexIndex).getFirstEdge();</span><br><span class="line">        </span><br><span class="line">        while (edge != null) &#123;</span><br><span class="line">            int adjvex = edge.getAdjvex();</span><br><span class="line">            </span><br><span class="line">            VertexNode vex = vexList.get(adjvex);</span><br><span class="line">            </span><br><span class="line">            //将此 顶点的入度减一</span><br><span class="line">            vex.setIn(vex.getIn() - 1);</span><br><span class="line">            //此顶点的入度为零则入栈，以便于下次循环输出</span><br><span class="line">            if (vex.getIn() == 0) &#123;</span><br><span class="line">                stack.push(adjvex);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            edge = edge.getNext();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (count != vexList.size())</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 边表结点</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class EdgeNode &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 邻接点域，存储该顶点对应的下标</span><br><span class="line">     */</span><br><span class="line">    private int adjvex;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 用于存储权值，对于非网图可以不需要</span><br><span class="line">     */</span><br><span class="line">    private int weight;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 链域，指向下一个邻接点</span><br><span class="line">     */</span><br><span class="line">    private EdgeNode next;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    public EdgeNode(int adjvex, int weight, EdgeNode next) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.adjvex = adjvex;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getAdjvex() &#123;</span><br><span class="line">        return adjvex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setAdjvex(int adjvex) &#123;</span><br><span class="line">        this.adjvex = adjvex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getWeight() &#123;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setWeight(int weight) &#123;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public EdgeNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setNext(EdgeNode next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顶点表结点</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class VertexNode &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 顶点入度</span><br><span class="line">     */</span><br><span class="line">    private int in;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 顶点域，存储顶点信息（下标）</span><br><span class="line">     */</span><br><span class="line">    private int data;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 边表头指针</span><br><span class="line">     */</span><br><span class="line">    private EdgeNode firstEdge;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    public VertexNode(int in, int data, EdgeNode firstEdge) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.in = in;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.firstEdge = firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getIn() &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setIn(int in) &#123;</span><br><span class="line">        this.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setData(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public EdgeNode getFirstEdge() &#123;</span><br><span class="line">        return firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setFirstEdge(EdgeNode firstEdge) &#123;</span><br><span class="line">        this.firstEdge = firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用于判断一个图是否存在环，存在的话，返回false，否则返回true</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关联分析之Apriori</title>
      <link href="/2019/03/15/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B9%8BApriori/"/>
      <url>/2019/03/15/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B9%8BApriori/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/15/关联分析之Apriori/apriori.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来京第一次搬家</title>
      <link href="/2019/03/09/%E6%9D%A5%E4%BA%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AC%E5%AE%B6/"/>
      <url>/2019/03/09/%E6%9D%A5%E4%BA%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AC%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;2019年3月9日，从去年九月23号来京，将近半年了，这半年怎么说，感觉很浪费了，一是在于自己当初真的是太着急了，二是这半年来的得过且过。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;收拾东西的时候，很烦，真的很烦，东西太多了，两个行李箱，一个行李袋，外加好几个箱子，还有一些杂七杂八的东西，然后,emmmmm，懒癌犯了，想着，自己当初为什么要来北京，天津也不错啊，然后给自己的理由是，嗯，有小哥哥啊（甩锅给小哥哥，其实没他我也会在北京呆着，哎，（我的）才华配不上我的理想啊），难受的哭唧唧<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;不过搬家前有朋友一直再说帮我搬，很开心，然后今天搬家的时候，朋友特地开车过来帮忙，美滋滋呀，有朋友帮忙的感觉是真的好呀。  </p><p>今天就当作是新的开始好了</p><p>一切都要加油哟！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理和反向代理</title>
      <link href="/2019/03/05/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2019/03/05/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>对于代理一直比较懵，现在把理解出来的代理记下来~~~因为我觉得我会忘掉了，如果长时间不看  </p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>对于一个无法访问的网站，例如Google，我们就需要一个代理<br>我们向代理发送一个请求，代理转发请求去网站拿数据，再把请求发送回来<br><a id="more"></a></p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ul><li>可以做缓存</li><li>加快访问速度</li><li>代理可以记录用户访问记录，对外隐藏用户信息</li><li>对客户端（用户）访问授权，上网进行认证</li></ul><p>所以我们需要去租一个服务器，然后在主机上进行配置，就可以<em>科学上网</em>啦  </p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>Reverse Proxy   </p><p>这里比较神奇，客户端竟然都不知道代理的存在！！！<br>反向代理对外都是透明的<br>因此啊，访问者根本不知道自己访问的是一个网站，还是一个代理！！！   哼，流氓   </p><p>Nginx就是一个反向代理<br>客户端访问一个网站（代理）时：</p><p>客户端发送请求给代理，此时的代理有内网和外网，外网是公共访问地址，这时候反响代理服务器拿着请求，找到内网地址，去到了对应的服务器  </p><h2 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h2><ul><li>一般大型的网站，使用的都是反向代理，将反向代理作为公网的访问地址，WEB服务器是内网。   </li><li>负载均衡，通过反向代理服务器来优化网站的负载  </li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>盗个图<br><img src="/2019/03/05/正向代理和反向代理/proxy.PNG" alt="">  </p><p>正向代理中，proxy和client属于同一个LAN，对server透明<br>反向代理中，proxy和server属于同一个LAN，对client透明   </p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>一款轻量级的Web服务器/反向代理服务器，工作在七层的http协议的负载均衡系统  </p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>模块化设计<br>扩展性好</li><li>高可靠性<br>主控进程heworker是同步实现的，一个worker出现问题，会立刻启动另一个worker  </li><li>低内存<br>一万个长连接(keep-alive)，仅消耗2.5MB内存  </li><li>支持热部署<br>不用停止服务器，实现更新配置文件，更新日志文件，跟新服务器程序版本。</li><li>高并发<br>官方数据，每秒支持5万并发。</li><li>功能丰富<br>优秀的反向代理功能和灵活的负载均衡策略   </li></ul><p>还有很多，这里只是一个大概的了解  </p><p>吼吼吼</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树之最小生成树</title>
      <link href="/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树 MST"></a>最小生成树 MST</h1><p>最小，指的是权值的和最小</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Minimum Spanning Tree.一个有n个结点的<em>连通图</em>的生成树 是  原图的极小连通子图，且包含原图中的所有n个结点，并且保持图连通的最少的边<br>本身是一棵树<br><a id="more"></a><br>所以一定是无环的哟<br>两个典型的算法，为啥是两个呢，因为啊，哎，两个人提出来的，然后就根据名字来命名了！</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法(Prim)"></a>普里姆算法(Prim)</h2><p>体现了回溯法和贪心算法</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>（1）输入：一个加权的连通图，其中呢，顶点集合为V，边集合为E(呀哈，邻接矩阵，邻接链表也可以哟)<br>（2）初始化：全都初始化为0<br>（3）首先随意的选取一个顶点，再选取权值最小的边，标记这两个顶点<br>（4）若有一个顶点，连接一个以上被标记的顶点，舍去权值最大的那条边<br>（5）一直执行第三步，知道遍历完所有的边</p><p><strong><em>要注意</em></strong><br>千万不能形成一个环呀</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>（1）选取一个顶点（0）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_1.PNG" alt=""><br>（2）找到与之相连的，权值最小的边和顶点<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_2.PNG" alt=""><br>（3）即第四步，舍弃权值最大的那条边（舍弃权值为：6和7）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_3.PNG" alt=""><br>（4）重复第三步，找到当前顶点，权值最小的边和顶点（顶点5）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_4.PNG" alt=""><br>（5）重复第四步，舍去边（5和6）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_5.PNG" alt=""><br>（6）重复第三步，选出最小边，相等时，随便选<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_6.PNG" alt=""><br>（7）重复第四步，社区最大边<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_7.PNG" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * prim算法实现最小生成树</span><br><span class="line"> * @param g 图</span><br><span class="line"> */</span><br><span class="line">public static void MiniSpanTree_Prim(Graph g) &#123;</span><br><span class="line">int min, j, k;</span><br><span class="line">int maxvex  = 0;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共几个顶点&quot;);</span><br><span class="line">maxvex= scan.nextInt();</span><br><span class="line">int[] adjvex = new int[maxvex];//保存相关顶点下标</span><br><span class="line">int[] lowcoat = new int[maxvex];//保存相关顶点间边的权值</span><br><span class="line">lowcoat[0] = 0;</span><br><span class="line">adjvex[0] = 0;</span><br><span class="line">//初始化</span><br><span class="line">for(int i=1;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">lowcoat[i] =g.edges[0][i];</span><br><span class="line">adjvex[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">//构建</span><br><span class="line">for(int i=1;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">min = Integer.MAX_VALUE;//初始化已给不可能数值</span><br><span class="line">j = 1;</span><br><span class="line">k = 0;</span><br><span class="line">//遍历所有的顶点</span><br><span class="line">while(j&lt;g.numVertex) &#123;</span><br><span class="line">//找到lowcoat数组中存储的最小权值</span><br><span class="line">// == 0 是自己连线</span><br><span class="line">if(lowcoat[j] != 0 &amp;&amp; lowcoat[j]&lt;min) &#123;</span><br><span class="line">min = lowcoat[j];</span><br><span class="line">k = j;//将发现的最小权值的下标存入k,以待使用</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">//打印当前顶点边中权值最小的边</span><br><span class="line">System.out.println(adjvex[k]+&quot;-&quot;+k);</span><br><span class="line">lowcoat[k] = 0;//设置当前顶点的权值为0，表示此顶点已经完成任务</span><br><span class="line">//这里重要一点，逐个遍历邻接矩阵k行所有顶点</span><br><span class="line">for(j=1;j&lt;g.numVertex;j++) &#123;</span><br><span class="line">if(lowcoat[j] != 0 &amp;&amp; g.edges[k][j] &lt;lowcoat[j]) &#123;</span><br><span class="line">lowcoat[j] = g.edges[k][j];</span><br><span class="line">adjvex[j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="克鲁斯卡尔-Kruskal"><a href="#克鲁斯卡尔-Kruskal" class="headerlink" title="克鲁斯卡尔(Kruskal)"></a>克鲁斯卡尔(Kruskal)</h2><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>先构造一个只含n个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根节点，然后，从E中取出一条权值最小的边，如果这条边的两个顶点属于不同的树，那么将其加入子图(两棵树合成一棵树)；否则的话，不可以取哟，应该取下一条权值最小的边再试试。结束条件：森林中只有一棵树，也就是说，图里面有n-1条边为止。<br>原理是   只含顶点不含边的森林<br>本身是一个森林  </p><h2 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h2><p>用的是边界数组<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal.PNG" alt=""><br>边集数组是按照权值从小到达排序的<br>（1）找到边集数组中的边，直到所有的顶点都遍历完<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal_1.PNG" alt=""><br>（2）若边的两个顶点在同一棵树上，舍去，下一条边，若权值相等，随便选取一条<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal_2.PNG" alt=""></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAGEDGE = 5;</span><br><span class="line">class Edge&#123;</span><br><span class="line">int begin;</span><br><span class="line">int end;</span><br><span class="line">int weight;//权值</span><br><span class="line">&#125;</span><br><span class="line">public int find(int[] parent, int f) &#123;</span><br><span class="line">while(parent[f]&gt;0) &#123;</span><br><span class="line">f = parent[f];</span><br><span class="line">&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * kruskal算法实现最小生成树</span><br><span class="line"> */</span><br><span class="line">public void MiniSpanTree_Kruskal(Graph g) &#123;</span><br><span class="line">int i, n, m;</span><br><span class="line">Edge[] edges  = new Edge[MAGEDGE];//边集数组</span><br><span class="line">    int[] parent = new int[MAGEDGE];//用于判断是否形成回路</span><br><span class="line">    //初始化</span><br><span class="line">    for(i = 0;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">    parent[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">    n = find(parent,edges[i].begin);</span><br><span class="line">    m = find(parent,edges[i].end);</span><br><span class="line">    if(n != m) &#123;//否则的话，就形成了一个环路</span><br><span class="line">    parent[n] = m;//将此边的结尾顶点放入下标为起点的parent数组中，表示此顶点已经再生成树集合中</span><br><span class="line">    System.out.println(&quot;连接情况：&quot;+edges[i].begin+&quot;-&gt;&quot;+edges[i].end+&quot;权重为：&quot;+edges[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难理解的是parent数组，注意，parent数组的值是可以重复的！！！</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>克鲁斯卡尔适合边数少的图，普里姆适合边数多的图</p><p>以上算法都是<strong><em>贪心算法</em></strong>的应用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之最短路径</title>
      <link href="/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>一个顶点到另一个顶点的最短路径，与最小生成树不同的是，这里最短路径不一定包含所有的顶点，但是最小生成树一定要包含所有的顶点。<br><a id="more"></a></p><h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>Dijkstra.算法复杂度O(n^2) 使用了贪心算法，求出所有的顶点路径。算法和prim相似，先赋值，再修正<br><img src="/2019/03/01/图论之最短路径/dijkstra.jpg" alt=""></p><p>啦啦啦啦啦，这个算法，其实，效率很低哈哈哈哈   </p><p>下图中的算法中，使用的是邻接矩阵</p><h2 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h2><p>Floyd.算法复杂度O(n^3),是动态规划的应用<br><img src="/2019/03/01/图论之最短路径/凸轮之最短路径/floyd.jpg" alt=""></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li>路径<br>迪杰斯特拉算法求的是一个顶点到所有顶点的最短路径<br>弗洛伊德算法求得是所有顶点到所有顶点得最短路径</li><li>弗洛伊德算法得代码更加简洁  </li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历</title>
      <link href="/2019/02/26/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2019/02/26/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>Depth First Search.  与树的先序遍历类似。从某个顶点出发，依次向下访问<br>分析：</p><ol><li>访问初始顶点v，并标记顶点v已经被访问<a id="more"></a></li><li>找到顶点v的第一个邻接顶点w</li><li>若顶点w存在，则执行第4步，否则结束算法</li><li>若顶点w未被访问，进行深度优先遍历（重复123步骤）</li><li>找到W的下一个邻接顶点，执行第3步</li></ol><h2 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><p>用的递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.synth.SynthSpinnerUI;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;String&gt; vertexList;//用来存储顶点信息</span><br><span class="line">private int[][] edges;//邻接矩阵，存储顶点之间的边信息</span><br><span class="line">private int numEdges;//边的数目</span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> * @param n</span><br><span class="line"> */</span><br><span class="line">public GraphVertex(int n) &#123;</span><br><span class="line">vertexList = new ArrayList&lt;&gt;(n);</span><br><span class="line">edges = new int[n][n];</span><br><span class="line">numEdges = 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到结点个数</span><br><span class="line"> */</span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return vertexList.size();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到边数</span><br><span class="line"> */</span><br><span class="line">public int getNumEdges() &#123;</span><br><span class="line">return numEdges;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param i</span><br><span class="line"> * @return 返回第i个结点的信息</span><br><span class="line"> */</span><br><span class="line">public String getValueByIndex(int i) &#123;</span><br><span class="line">return vertexList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param v1  第一个顶点</span><br><span class="line"> * @param v2  第二个顶点</span><br><span class="line"> * @return 返回两个顶点之间的权值</span><br><span class="line"> */</span><br><span class="line">public int getWeight(int v1, int v2) &#123;</span><br><span class="line">return edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 插入结点到集合中</span><br><span class="line"> * @param vertex</span><br><span class="line"> */</span><br><span class="line">public void insertVertex(String vertex) &#123;</span><br><span class="line">if(vertexList.contains(vertex)) &#123;</span><br><span class="line">System.out.println(&quot;该顶点已存在！！！&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">vertexList.add(vertexList.size(), vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 邻接矩阵存储</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @param weight 权值</span><br><span class="line"> */</span><br><span class="line">public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">if(edges[v1][v2] != 0) &#123;//修改权值而不是新增的</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">numEdges++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 删除边</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> */</span><br><span class="line">public void deleteEdge(int v1, int v2) &#123;</span><br><span class="line">if(edges[v1][v2] == 0) &#123;</span><br><span class="line">System.out.println(&quot;该边不存在！！！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = 0;</span><br><span class="line">numEdges--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param index</span><br><span class="line"> * @return 当前结点第一个邻接顶点下标</span><br><span class="line"> */</span><br><span class="line">public int getFirshNeighbor(int index) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[index][i]&gt;0) &#123;//行是相同的哟</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param v1 开始顶点的下标</span><br><span class="line"> * @param v2 结束顶点的下标</span><br><span class="line"> * @return 下一个邻接顶点</span><br><span class="line"> */</span><br><span class="line">public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">for(int i= v2+1; i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[v1][i]&gt;0) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印邻接矩阵</span><br><span class="line"> */</span><br><span class="line">private void print() &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">System.out.print(&quot;\t&quot;+vertexList.get(i)+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;edges[0].length;i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot;\t&quot;);</span><br><span class="line">for(int j=0;j&lt;edges[0].length;j++) &#123;</span><br><span class="line">System.out.print(edges[i][j]+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void depthFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">//初始化</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">DFS(i,visited);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 深度优先遍历</span><br><span class="line"> * @param v</span><br><span class="line"> * @param visited</span><br><span class="line"> */</span><br><span class="line">private void DFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">//打印出遍历的结点</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">        //整个循环不仅可以用getNumVertex()进行判断，也可以用权值判断，权值为-1表示是没有边的</span><br><span class="line">for(int j=0;j&lt;getNumVertex();j++) &#123;</span><br><span class="line">            //if(有边，未被访问，权值不超过最大值)</span><br><span class="line">            </span><br><span class="line">if(edges[i][j] != 0 &amp;&amp; !visited[j] &amp;&amp; edges[i][j] != 65535) &#123;</span><br><span class="line">DFS(j,visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int n=8,e=9;//分别代表结点个数和边的数目</span><br><span class="line">        String labels[]=&#123;&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;,&quot;v5&quot;,&quot;v6&quot;,&quot;v7&quot;,&quot;v8&quot;&#125;;//结点的标识</span><br><span class="line">        GraphVertex graph=new GraphVertex(n);</span><br><span class="line">        for(String label:labels) &#123;</span><br><span class="line">            graph.insertVertex(label);//插入结点</span><br><span class="line">        &#125;</span><br><span class="line">        //插入九条边</span><br><span class="line">        graph.insertEdge(0, 1, 1);</span><br><span class="line">        graph.insertEdge(0, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 3, 1);</span><br><span class="line">        graph.insertEdge(1, 4, 1);</span><br><span class="line">        graph.insertEdge(3, 7, 1);</span><br><span class="line">        graph.insertEdge(4, 7, 1);</span><br><span class="line">        graph.insertEdge(2, 5, 1);</span><br><span class="line">        graph.insertEdge(2, 6, 1);</span><br><span class="line">        graph.insertEdge(5, 6, 1);</span><br><span class="line">        graph.insertEdge(1, 0, 1);</span><br><span class="line">        graph.insertEdge(2, 0, 1);</span><br><span class="line">        graph.insertEdge(3, 1, 1);</span><br><span class="line">        graph.insertEdge(4, 1, 1);</span><br><span class="line">        graph.insertEdge(7, 3, 1);</span><br><span class="line">        graph.insertEdge(7, 4, 1);</span><br><span class="line">        graph.insertEdge(6, 2, 1);</span><br><span class="line">        graph.insertEdge(5, 2, 1);</span><br><span class="line">        graph.insertEdge(6, 5, 1);</span><br><span class="line">        graph.print();</span><br><span class="line">System.out.println(&quot;深度优先,从结点v1开始&quot;);</span><br><span class="line">graph.depthFirstSearch(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>结果<br><img src="/2019/02/26/图的遍历/vertexDFS.PNG" alt=""></p></blockquote><h2 id="马踏棋盘问题"><a href="#马踏棋盘问题" class="headerlink" title="马踏棋盘问题"></a>马踏棋盘问题</h2><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>Breadth First Search. 又称为“宽度优先搜索”或“横向优先搜索”<br>从某一顶点出发，依次访问邻接的所有顶点<br>因为BFS并不使用经验法则算法，所以展开结点而得到的子节点都会被加进一个先进先出的队列中。</p><p>分析：</p><ol><li>访问初始顶点v，并标记顶点v已经被访问</li><li>结点v入队列</li><li>当队列非空时，继续向下执行，否则结束算法</li><li>出队列，获得队头结点u</li><li>找到结点u的第一个邻接顶点w</li><li>若w不存在，执行第3步，否则向下执行</li><li>若w未被访问，标记顶点w已经被访问</li><li>顶点w入队列</li><li>找到顶点的第二个邻接顶点，执行第6步</li></ol><p>其实就是按照邻接矩阵的行进行寻找的<br>第一行的0-n列<br>第二行的0-n列<br>……</p><h2 id="邻接矩阵实现-1"><a href="#邻接矩阵实现-1" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><p>用的是迭代</p><p>根据出队下标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void broadFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">BFS(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">private void BFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">//第一次访问的顶点</span><br><span class="line">System.out.print(getValueByIndex(i)+&quot; &quot;);</span><br><span class="line">//标记该顶点已被遍历过</span><br><span class="line">visited[i] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(i);</span><br><span class="line">while(!queue.isEmpty()) &#123;</span><br><span class="line">//出队列</span><br><span class="line">int vertex = queue.poll();</span><br><span class="line">for(int j=vertex;j&lt;getNumVertex();j++) &#123;</span><br><span class="line">if(!visited[j] &amp;&amp; getWeight(vertex, j) != 0) &#123;</span><br><span class="line">visited[j] = true;</span><br><span class="line">System.out.print(getValueByIndex(j)+&quot; &quot;);</span><br><span class="line">queue.offer(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据权值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void broadFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">BFS(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">private void BFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">//第一次访问的顶点</span><br><span class="line">System.out.print(getValueByIndex(i)+&quot; &quot;);</span><br><span class="line">//标记该顶点已被遍历过</span><br><span class="line">visited[i] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(i);</span><br><span class="line">while(!queue.isEmpty()) &#123;</span><br><span class="line">//出队列</span><br><span class="line">int vertex = queue.poll();</span><br><span class="line">//第一个邻接顶点</span><br><span class="line">int next = getFirshNeighbor(vertex);</span><br><span class="line">while(next != -1) &#123;//还有邻接顶点的时候</span><br><span class="line">if(!visited[next]) &#123;</span><br><span class="line">System.out.print(getValueByIndex(next)+&quot; &quot;);</span><br><span class="line">visited[next] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">//下一个邻接顶点</span><br><span class="line">next = getNextNeighbor(vertex, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>感觉根据权值来进行比较的话，比较次数会相对少一些，尤其稀疏的时候<br><img src="/2019/02/26/图的遍历/BFSVertexs.PNG" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码习题</title>
      <link href="/2019/02/21/%E4%BB%A3%E7%A0%81%E4%B9%A0%E9%A2%98/"/>
      <url>/2019/02/21/%E4%BB%A3%E7%A0%81%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-对链表进行重新排序"><a href="#1-对链表进行重新排序" class="headerlink" title="1.对链表进行重新排序"></a>1.对链表进行重新排序</h1><p>题目：给定链表 L0-L1-L2-…-Ln-1-Ln,把链表重新排序为L0-Ln-L1-Ln-1-L2-Ln-2-…<br>要求：  </p><ul><li>再原来链表的基础上进行排序，即不能申请新的结点</li><li>只能修改结点的next域，不能修改数据域。<a id="more"></a>思路：</li><li>找到链表的中间结点(暴力法或者快慢指针法)</li><li>将链表分成两个来链表</li><li>逆序后面的链表</li><li>依次循环，每次各去除两个链表的一个结点，直至next为空</li></ul><h1 id="2-求两个字符串的最长公共子串"><a href="#2-求两个字符串的最长公共子串" class="headerlink" title="2.求两个字符串的最长公共子串"></a>2.求两个字符串的最长公共子串</h1><ol><li>暴力求解<br>利用动态规划法，双重for循环。</li></ol><ul><li>初始化二维数组max[][]，赋值为0</li><li>双重循环两个字符串，如果字符串在某一位置相等,赋值max+1，</li><li>两个变量，max记录最长公共子串的长度，maxI记录最长公共子串最后一个字符的位置</li><li>最长公共子串的位置是从下标maxI-max开始，下标增加max位的字符</li><li>需要注意的是，比较的时候对max数组的赋值，因为循环是从1开始的</li></ul><p><img src="/2019/02/21/代码习题/maxSubStr.PNG" alt="">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str1 = &quot;GCCCTAGCG&quot;;</span><br><span class="line">String str2 = &quot;GCGCAATG&quot;;</span><br><span class="line">getMaxSubStr(str1, str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getMaxSubStr(String str1, String str2) &#123;</span><br><span class="line">if(str1 == null || str2 == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int[][] m = new int[str1.length()+1][str2.length()+1];</span><br><span class="line">int max = 0;//最长公共子序列的长度</span><br><span class="line">int maxI = 0;//最长公共子序列的最后一个字符的位置</span><br><span class="line">for(int i=0;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">m[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=1;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">if(str1.charAt(i-1) == str2.charAt(j-1)) &#123;</span><br><span class="line">m[i][j] = m[i-1][j-1]+1;</span><br><span class="line">if(max&lt;m[i][j]) &#123;</span><br><span class="line">max = m[i][j];</span><br><span class="line">maxI = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str1.substring(maxI-max, maxI));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>滑动比较法</li></ol><ul><li>保持str1的位置不变，移动str2,比较重叠字符的公共子串</li><li>移动时，如果当前重叠子串的长度大于maxI,更新maxI<h1 id="3-求字符串的所有排序（未去重）"><a href="#3-求字符串的所有排序（未去重）" class="headerlink" title="3.求字符串的所有排序（未去重）"></a>3.求字符串的所有排序（未去重）</h1></li><li>第一步，第一个字符和后面所有字符，依次交换</li><li>第二步，固定第一个字符，对剩余的字符进行全排列（交换）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void swap(char[] str, int start, int i) &#123;</span><br><span class="line">char tmp = str[start];</span><br><span class="line">str[start] = str[i];</span><br><span class="line">str[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">public static void Permutation(char[] str, int start) &#123;</span><br><span class="line">if(str.length == 0 || start&lt;0) &#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(start == str.length-1) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for(int i = start;i&lt;str.length;i++) &#123;</span><br><span class="line">swap(str,start,i);</span><br><span class="line">Permutation(str, start+1);</span><br><span class="line">swap(str,i,start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String string = &quot;abc&quot;;</span><br><span class="line">char[] str = string.toCharArray();</span><br><span class="line">Permutation(str, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-将多个有序的list集合组合成一个有序的集合"><a href="#4-将多个有序的list集合组合成一个有序的集合" class="headerlink" title="4. 将多个有序的list集合组合成一个有序的集合"></a>4. 将多个有序的list集合组合成一个有序的集合</h1><p>数美时代技术有限公司的一道面试题，25分，本人直接用了：<br>Collections.sort() emmmmmm直接扣掉了15分，当时太紧张了，脑子都是懵的，不过也是基础不扎实的缘故。 </p><p>思路：</p><ul><li>俩俩比较，但是总觉得会有更优的算法，要不然为何强调是有序的集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉是不是需要递归啊</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2019/02/19/%E5%9B%BE/"/>
      <url>/2019/02/19/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>图(Graph)是由顶点的<em>有穷非空</em>集合和顶点之间边的集合组成。通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br><a id="more"></a><br>注意：</p><ul><li>数据元素，在线性表中叫元素，树中叫结点，图中称为顶点(Vertex)</li></ul><ol><li>无向边（Edge）<br>顶点Vi到Vj之间的边没有方向,用无序偶(Vi,Vj)来表示。</li><li>有向边<br>也称为弧(Arc),用有序偶&lt;Vi,Vj&gt;表示，Vi是弧尾，Vj是弧头</li><li>简单图<br>不存在顶点到其自身的边，且同一条边不重复出现。</li><li>无向完全图<br>在无向图中，任意两个顶点之间都存在边。含有n个项点的无向完全图有n*(n-1)/2条边。</li><li>有向完全图<br>在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。含有n个顶点的有向完全图有n*(n-1)条边。</li><li>稀疏图和稠密图<br>通常认为边或弧数小于n*logn的图为稀疏图。</li><li>权(Weight)<br>与图的边或弧相关的数</li><li>网(Network)<br>带权的图</li><li>度(Degree)<br>顶点和相关联的边的数目.TD(V) = ID(V)+OD(V)</li><li>入度(InDegree)<br>以顶点V为头的弧的数目称为V的入度，记为ID(V)</li><li>初读(OutDegree)<br>以V为尾的弧的数目称为V的出度，记为OD(V)  </li><li>回路或环(Cycle)<br>第一个顶点到最后一个顶点相同的路径<br>顶点不重复出现的是简单环</li><li>连通图<br>无向图中，每个顶点都相连，如果是有向图，称为强连通图</li><li>无向图中的极大连通子图称为连通分量</li></ol><ul><li>首先是子图，且子图是连通的</li><li>连通子图含有极大顶点数</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>是多对多的关系，树是一对多，链表是一对一  </p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>分为有向图邻接矩阵和无向图邻接矩阵</p><ol><li>无向图<br>用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息：0表示不存在，1表示存在。</li><li>有向图<br>与无向图一样，但无向图更浪费空间，因为无向图是对称矩阵</li><li>网<br>没有连线的两个顶点，用无穷∞表示</li></ol><ul><li>入度<br>该顶点所在列的和</li><li>出度<br>该顶点所在行的和</li></ul><ol start="4"><li>实现邻接矩阵<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Graph &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;Object&gt; point;//顶点信息</span><br><span class="line">private int[][] edge;//边信息，</span><br><span class="line">private int numEdge;//边的数目</span><br><span class="line">private int numVertex ;//顶点的数目</span><br><span class="line"></span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumVertex(int numVertex) &#123;</span><br><span class="line">this.numVertex = numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public ArrayList&lt;Object&gt; getPoint() &#123;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">public void setPoint(ArrayList&lt;Object&gt; point) &#123;</span><br><span class="line">this.point = point;</span><br><span class="line">&#125;</span><br><span class="line">public int[][] getEdge() &#123;</span><br><span class="line">return edge;</span><br><span class="line">&#125;</span><br><span class="line">public void setEdge(int[][] edge) &#123;</span><br><span class="line">this.edge = edge;</span><br><span class="line">&#125;</span><br><span class="line">public int getNumEdge() &#123;</span><br><span class="line">return numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumEdge(int numEdge) &#123;</span><br><span class="line">this.numEdge = numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public Graph(int n) &#123;</span><br><span class="line">this.point = new ArrayList&lt;&gt;(n);</span><br><span class="line">this.edge = new int[n][n];</span><br><span class="line">this.numEdge = 0;</span><br><span class="line">&#125;</span><br><span class="line">public Graph() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 建立无向图</span><br><span class="line"> */</span><br><span class="line">public static Graph buildGraph() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共多少个顶点&quot;);</span><br><span class="line">int numVertex  = scan.nextInt();</span><br><span class="line">System.out.println(&quot;一共多少条边&quot;);</span><br><span class="line">int numEdge = scan.nextInt();</span><br><span class="line">Graph g = new Graph();</span><br><span class="line">g.setNumEdge(numEdge);</span><br><span class="line">g.setNumVertex(numVertex);</span><br><span class="line">//读入顶点信息</span><br><span class="line">int vertex = numVertex;</span><br><span class="line">ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">scan.nextLine();</span><br><span class="line">while(vertex&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;请输入顶点&quot;);</span><br><span class="line">String s = scan.nextLine();</span><br><span class="line">list.add(s);</span><br><span class="line">vertex--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">g.setPoint(list);</span><br><span class="line">//初始化</span><br><span class="line">int[][] edge = new int[numVertex][numVertex];</span><br><span class="line">for(int i=0;i&lt;g.getNumVertex();i++) &#123;</span><br><span class="line">for(int j=0;j&lt;g.getNumVertex();j++) &#123;</span><br><span class="line">edge[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//加入到邻接矩阵中，1表示有边</span><br><span class="line">while(numEdge&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;输入连接的两个顶点，用“#”隔开&quot;);</span><br><span class="line">String num = scan.nextLine();</span><br><span class="line">String[] nums = num.split(&quot;#&quot;);</span><br><span class="line">int indexOf0 = list.indexOf(nums[0]);</span><br><span class="line">int indexOf1 = list.indexOf(nums[1]);</span><br><span class="line">if(indexOf0&lt;0 || indexOf1&lt;0) &#123;</span><br><span class="line">System.out.println(&quot;顶点不存在，请重新输入！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edge[list.indexOf(nums[0])][list.indexOf(nums[1])] = 1;</span><br><span class="line">//因为是对称的</span><br><span class="line">edge[list.indexOf(nums[1])][list.indexOf(nums[0])] = 1;</span><br><span class="line">numEdge--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//打印出来</span><br><span class="line">System.out.print(&quot; &quot;);</span><br><span class="line">for(Object li : list) &#123;</span><br><span class="line">System.out.print(li+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;numVertex;i++) &#123;</span><br><span class="line">System.out.print(list.get(i)+&quot; &quot;);</span><br><span class="line">for(int j=0;j&lt;numVertex;j++) &#123;</span><br><span class="line">System.out.print(edge[i][j]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">buildGraph();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果 </p><blockquote><p>一共多少个顶点<br>5<br>一共多少条边<br>5<br>请输入顶点<br>a<br>请输入顶点<br>b<br>请输入顶点<br>c<br>请输入顶点<br>d<br>请输入顶点<br>e<br>[a, b, c, d, e]<br>输入连接的两个顶点，用“#”隔开<br>a#b<br>输入连接的两个顶点，用“#”隔开<br>d#e<br>输入连接的两个顶点，用“#”隔开<br>c#b<br>输入连接的两个顶点，用“#”隔开<br>b#d<br>输入连接的两个顶点，用“#”隔开<br>d#a<br> a b c d e<br>a 0 1 0 1 0<br>b 1 0 1 1 0<br>c 0 1 0 0 0<br>d 1 1 0 0 1<br>e 0 0 0 1 0 </p></blockquote><hr><p>版本二：添加了权值，添加了增加和删除  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.synth.SynthSpinnerUI;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;String&gt; vertexList;//用来存储顶点信息</span><br><span class="line">private int[][] edges;//邻接矩阵，存储顶点之间的边信息</span><br><span class="line">private int numEdges;//边的数目</span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> * @param n</span><br><span class="line"> */</span><br><span class="line">public GraphVertex(int n) &#123;</span><br><span class="line">vertexList = new ArrayList&lt;&gt;(n);</span><br><span class="line">edges = new int[n][n];</span><br><span class="line">numEdges = 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到结点个数</span><br><span class="line"> */</span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return vertexList.size();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到边数</span><br><span class="line"> */</span><br><span class="line">public int getNumEdges() &#123;</span><br><span class="line">return numEdges;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param i</span><br><span class="line"> * @return 返回第i个结点的信息</span><br><span class="line"> */</span><br><span class="line">public String getValueByIndex(int i) &#123;</span><br><span class="line">return vertexList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param v1  第一个顶点</span><br><span class="line"> * @param v2  第二个顶点</span><br><span class="line"> * @return 返回两个顶点之间的权值</span><br><span class="line"> */</span><br><span class="line">public int getWeight(int v1, int v2) &#123;</span><br><span class="line">return edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 插入结点到集合中</span><br><span class="line"> * @param vertex</span><br><span class="line"> */</span><br><span class="line">public void insertVertex(String vertex) &#123;</span><br><span class="line">if(vertexList.contains(vertex)) &#123;</span><br><span class="line">System.out.println(&quot;该顶点已存在！！！&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">vertexList.add(vertexList.size(), vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 邻接矩阵存储</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @param weight 权值</span><br><span class="line"> */</span><br><span class="line">public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">if(edges[v1][v2] != 0) &#123;//修改权值而不是新增的</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">numEdges++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 删除边</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> */</span><br><span class="line">public void deleteEdge(int v1, int v2) &#123;</span><br><span class="line">if(edges[v1][v2] == 0) &#123;</span><br><span class="line">System.out.println(&quot;该边不存在！！！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = 0;</span><br><span class="line">numEdges--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param index</span><br><span class="line"> * @return 当前结点第一个邻接顶点下标</span><br><span class="line"> */</span><br><span class="line">public int getFirshNeighbor(int index) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[index][i]&gt;0) &#123;//行是相同的哟</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @return 下一个邻接顶点</span><br><span class="line"> */</span><br><span class="line">public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">for(int i= v2+1; i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[v1][i]&gt;0) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印邻接矩阵</span><br><span class="line"> */</span><br><span class="line">private void print() &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;edges[0].length;i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">for(int j=0;j&lt;edges[0].length;j++) &#123;</span><br><span class="line">System.out.print(edges[i][j]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int vertex = 4;</span><br><span class="line">int edge = 4;</span><br><span class="line">String[] v = &#123;&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;&#125;;</span><br><span class="line">GraphVertex G = new GraphVertex(vertex);</span><br><span class="line">//插入顶点</span><br><span class="line">for (String string : v) &#123;</span><br><span class="line">G.insertVertex(string);</span><br><span class="line">&#125;</span><br><span class="line">//插入边</span><br><span class="line">G.insertEdge(0, 1, 2);</span><br><span class="line">G.insertEdge(0, 2, 5);</span><br><span class="line">G.insertEdge(2, 3, 8);</span><br><span class="line">G.insertEdge(3, 0, 7);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;结点个数&quot;+G.getNumVertex());</span><br><span class="line">System.out.println(&quot;边个数&quot;+G.getNumEdges());</span><br><span class="line">System.out.println(&quot;邻接矩阵&quot;);</span><br><span class="line">G.print();</span><br><span class="line">G.deleteEdge(0, 1);</span><br><span class="line">System.out.println(&quot;删除v1,v2之间的边&quot;);</span><br><span class="line">System.out.println(&quot;删除后顶点个数：&quot;+G.getNumEdges());</span><br><span class="line">System.out.println(&quot;删除后边个数：&quot;+G.getNumEdges());</span><br><span class="line">G.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>AdjacencyList<br>是链表和数组的结合(树也是链表和数组的结合哟)  </p><ol><li>处理方法  </li></ol><ul><li>图中顶点用一个一维数组存储（或者单链表），用一维数组是为了更快的读取顶点信息，更加方便。  </li><li>图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以用单链表存储。  </li></ul><p><em>邻接表关心出度，不关心入度</em><br>类似于树的孩子表示法</p><p><img src="/2019/02/19/图/list.PNG" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.GenericArrayType;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接表结构</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphNode &#123;</span><br><span class="line">   //表对应链表的顶点</span><br><span class="line">private class ENode&#123;</span><br><span class="line">int index;//顶点位置</span><br><span class="line">ENode nextEdge;//下一条弧</span><br><span class="line">&#125;</span><br><span class="line">//表中顶点</span><br><span class="line">private class VNode&#123;</span><br><span class="line">String data;//顶点信息,就是说他叫什么名字</span><br><span class="line">ENode firstEdge;//指向该顶点的第一条弧</span><br><span class="line">&#125;</span><br><span class="line">private VNode[] vertexs;//顶点数组</span><br><span class="line">public void createGraph() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入顶点个数&quot;);</span><br><span class="line">int numVertexs = scan.nextInt();</span><br><span class="line">System.out.println(&quot;请输入边数&quot;);</span><br><span class="line">int numEdges = scan.nextInt();</span><br><span class="line">scan.nextLine();</span><br><span class="line">//初始化顶点</span><br><span class="line">vertexs = new VNode[numVertexs];</span><br><span class="line">for(int i=0; i &lt; numVertexs; i++) &#123;</span><br><span class="line">System.out.println(&quot;请输入顶点&quot;);</span><br><span class="line">vertexs[i] = new VNode();</span><br><span class="line">vertexs[i].data = scan.nextLine();</span><br><span class="line">vertexs[i].firstEdge = null;//很重要的一步</span><br><span class="line">&#125;</span><br><span class="line">//初始化边</span><br><span class="line">for(int i=0; i &lt; numEdges; i++) &#123;</span><br><span class="line">System.out.println(&quot;请输入边的起始顶点和结束顶点&quot;);</span><br><span class="line">ENode e1 = new ENode();</span><br><span class="line">String start = scan.nextLine();</span><br><span class="line">String end = scan.nextLine();</span><br><span class="line">int startIndex = getPosition(start);</span><br><span class="line">int endIndex = getPosition(end);</span><br><span class="line">e1.index = endIndex;</span><br><span class="line">//将e1连接到endIndedx所在链表的末尾</span><br><span class="line">if(vertexs[startIndex].firstEdge == null) &#123;</span><br><span class="line">vertexs[startIndex].firstEdge = e1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//将e1结点连接到vertexs[startIndex].firstEdge的末尾</span><br><span class="line">VertexsLast(vertexs[startIndex].firstEdge, e1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line">private void VertexsLast(ENode firstEdge, ENode e1) &#123;</span><br><span class="line">ENode p = firstEdge;</span><br><span class="line">while(p.nextEdge != null) &#123;</span><br><span class="line">p = p.nextEdge;</span><br><span class="line">&#125;</span><br><span class="line">p.nextEdge = e1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 连接顶点的位置信息</span><br><span class="line"> * @param start</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int getPosition(String data) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexs.length;i++) &#123;</span><br><span class="line">if(vertexs[i].data.equals(data)) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印矩阵的队列图,出队元素</span><br><span class="line"> */</span><br><span class="line">public void print() &#123;</span><br><span class="line">for(int i=0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">ENode node = vertexs[i].firstEdge;</span><br><span class="line">while(node != null) &#123;</span><br><span class="line">System.out.println(node.index+&quot;\t&quot;+vertexs[node.index].data);</span><br><span class="line">node = node.nextEdge;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">GraphNode g = new GraphNode();</span><br><span class="line">g.createGraph();</span><br><span class="line">g.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>邻接矩阵适用于顶点少，边数多的图，邻接表相反</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>把邻接表和逆邻接表结合起来。<br>结构为：tailVex   headVex    headLink   tailLink<br>Vex表示顶点，Link表示结点<br>常用！！！！！！！！</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>是对边的操作</p><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>由两个一维数组组成，一个存储顶点，一个存储边信息，这个边数组每个数据元素由一条边的起点下标，重点下标和全组成。<br><img src="/2019/02/19/图/1.PNG" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/2019/02/17/%E6%A0%91%E4%B9%8B%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2019/02/17/%E6%A0%91%E4%B9%8B%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>也称赫夫曼树、最优二叉树，Huffman,是首个实用的压缩编码方案。<br>&#160;&#160;&#160;&#160;给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉为最优二叉树，也称为哈夫曼树。<br><a id="more"></a><br>&#160;&#160;&#160;&#160;哈夫曼树是带权路径最短的树，权值较大的结点离根较近。</p><ul><li>路径长度<br>从根节点到该节点的路径上的连接数</li><li>树的路径长度<br>树中每个叶子结点的路径长度之和</li><li>结点带权路径长度<br>结点的路径长度与结点权值的乘积</li><li>树的带权路径长度<br>WPL(Weighted Path Length)是树中所有叶子结点的带权路径长度之和，WPL越小，树的结构越优。<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1></li><li>定长编码<br>约定8位表示一个字符</li><li>变长编码<br>单个编码的长度不一致，可以根据整体出现频率来调节<br>-前缀码<br>没有任何码字是其他码字的前缀</li></ul><p>约定，左子树用0表示，右子树用1表示<br><strong><em>很很很重要</em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树(Binary Tree)</title>
      <link href="/2019/02/17/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/02/17/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;也叫 二分树、二元树、对分树等。是n(n&gt;=0)个结点的有限元素的集合,该集合或为空，或为由一个根元素以及两个互不相交的、被分别称为左子树和右子树的二叉树组成。当集合为空时，称该二叉树为空二叉树。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>子树不能大于2哟</li><li>左右子树是有顺序的哟</li><li>如果没有左子树，是允许有右子树的<a id="more"></a><h1 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h1></li></ul><ol><li>斜树<br><img src="/2019/02/17/树之二叉树/二叉树/1.PNG" alt=""></li><li>满二叉树<br>如果在一棵二叉树中，所有的分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上面。<br><img src="/2019/02/17/树之二叉树/二叉树/2.PNG" alt=""><br>结点数为2^n-1    ,n表示深度</li><li>完全二叉树<br>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下，从左至右的顺序进行编号。如果说编号为i(1&lt;=i &lt;=n )的结点与满二叉树中编号为i的结点在二叉树中的位置相同的话，则称为是完全二叉树<br><strong><em>满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树</em></strong><br><strong>特点：</strong><br>&#160;&#160;&#160;&#160;叶子结点只能出现在最后一层或者倒数第二层上<br>&#160;&#160;&#160;&#160;最下层叶子结点集中在树的左部（根据满二叉树的定义来的）<br>&#160;&#160;&#160;&#160;同样结点数的二叉树，完全二叉树的深度是最小的  </li><li>线索二叉树<br>n个结点的二叉链表中含有n+1个空指针域。利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针（附加的指针称为线索）   <h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2>一维数组存储结点，从上至下，从左至右，不存在的结点可以用-1表示<br>但是如果空结点过多（如斜树）h会造成大量的空间浪费，适用性不强，一般使用链式存储<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2>二叉链表</li></ol><ul><li>数据</li><li>左子树结点，右子树结点  </li></ul><p>结构为：左子树   数据  右子树<br><img src="/2019/02/17/树之二叉树/二叉树/3.PNG" alt=""> </p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><em>注意：</em><br>树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点棉面临着不同的选择。  </p><ul><li>前序遍历<br>根-左-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历<br>左-根-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历<br>左-右-根</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层次遍历  </li></ul><p>节点类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tree &#123;</span><br><span class="line">private Object data;</span><br><span class="line">private Tree lchild;</span><br><span class="line">private Tree rchild;</span><br><span class="line">public Object getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">public void setData(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getLchild() &#123;</span><br><span class="line">return lchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setLchild(Tree lchild) &#123;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getRchild() &#123;</span><br><span class="line">return rchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setRchild(Tree rchild) &#123;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data, Tree lchild, Tree rchild) &#123;</span><br><span class="line">super();</span><br><span class="line">this.data = data;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.tree;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 二叉树</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BinaryTree &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Tree root = new Tree(0);</span><br><span class="line">Tree createTree = createTree(root);</span><br><span class="line">System.out.println(&quot;结点\t层次&quot;);</span><br><span class="line">traverse(createTree,1);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 遍历</span><br><span class="line"> * @param root</span><br><span class="line"> */</span><br><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private static void print(Tree root,int level) &#123;</span><br><span class="line">System.out.println(root.getData()+&quot;\t&quot;+level);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 建立二叉树</span><br><span class="line"> * @param root 树结点</span><br><span class="line"> * @param level  层次</span><br><span class="line"> */</span><br><span class="line">private static Tree createTree(Tree root) &#123;</span><br><span class="line"></span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String n = scan.nextLine();</span><br><span class="line">if(&quot;#&quot;.equals(n)) &#123;//叶子结点</span><br><span class="line">return null;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">root.setData(n);</span><br><span class="line">root.setLchild(createTree(new Tree(0)));</span><br><span class="line">root.setRchild(createTree(new Tree(0)));</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入 ：ABD##F##CE###<br>输出：<br>结点    层次<br>A       1<br>B       2<br>D       3<br>F       3<br>C       2<br>E       3</p><p>“#”表示他的双亲是叶子结点</p><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p><img src="/2019/02/17/树之二叉树/二叉树/4.PNG" alt=""><br>嘿嘿，不懂<br>😭</p><h1 id="树-森林、二叉树转换"><a href="#树-森林、二叉树转换" class="headerlink" title="树/森林、二叉树转换"></a>树/森林、二叉树转换</h1><p><img src="/2019/02/17/树之二叉树/二叉树/5.PNG" alt=""></p><h2 id="树到二叉树的转换"><a href="#树到二叉树的转换" class="headerlink" title="树到二叉树的转换"></a>树到二叉树的转换</h2><ul><li>每个兄弟结点连线</li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/6.PNG" alt=""></p><ul><li>去掉与孩子的连线（第一个长子除外）</li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/7.PNG" alt=""></p><ul><li>调整位置  </li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/8.PNG" alt=""></p><h2 id="森林到二叉树的转换"><a href="#森林到二叉树的转换" class="headerlink" title="森林到二叉树的转换"></a>森林到二叉树的转换</h2><ul><li>将森林中的每棵树转为二叉树</li><li>将根一次连在一起</li><li>调整位置</li></ul><h2 id="二叉树到树、森林的转换"><a href="#二叉树到树、森林的转换" class="headerlink" title="二叉树到树、森林的转换"></a>二叉树到树、森林的转换</h2><ul><li>若结点x是其双亲y的左孩子，则把x的右孩子，有孩子的有孩子，，，，，，都与y用连线连起来</li><li>去除双亲所有右孩子的连线</li></ul><p><em>二叉树的根节点有右孩子就是森林，没有就是树</em></p><h1 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h1><h2 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h2><p>先访问树的根节点，然后再一次访问根的每棵子树</p><h2 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h2><p>先遍历树的每棵子树，再遍历根</p><p><img src="/2019/02/17/树之二叉树/二叉树/9.PNG" alt=""></p><p>嗒嗒嗒，森林的遍历，名词叫做前序遍历和后序遍历，其实就是按照树的先根遍历和后根遍历一次来访问森林的每一棵树。</p><p>树、森林的前根遍历和（转变后的）二叉树的前序遍历相同<br>后根遍历和（转变后的）二叉树的中序遍历相同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五个常见算法</title>
      <link href="/2019/02/15/%E4%BA%94%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
      <url>/2019/02/15/%E4%BA%94%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><ol><li>递归<br>&#160;&#160;&#160;&#160;直接或间接地调用自身的算法    </li><li>分治<br>&#160;&#160;&#160;&#160;将一个规模为n的，难以解决的问题分解为k个规模较小的子问题，<em>子问题相互独立</em>  </li></ol><p>将子问题递归解决，得到源问题的解  </p><ol start="3"><li>典型案例<br>Fibonacci数列，阶乘，Hanoi塔，二分法搜索，高速排序，合并排序<a id="more"></a><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Dynamis programming,是运筹学的一个分支，是求解决策过程最优化的数学方法。 </li><li>基本思想<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;类似分治法，将待求解问题分解成若干个子问题，先求解子问题，但是<em>子问题不是相互独立的</em>，避免大量的重复计算，每一次要用到前一问题的解   </li><li><p>分类<br>线性动态规划： 拦截导弹， 合唱队形， 挖地雷， 建学校， 剑客决斗<br>区域动态规划： 石子合并， 加分二叉树， 统计单词个数， 炮兵布阵<br>树形动态规划： 贪吃的九头龙， 二分查找树， 聚会的欢乐， 数字三角形。<br>背包动态规划： 01背包问题， 完全背包问题， 分组背包问题， 二维背包， 装箱问题， 挤牛奶， </p></li><li><p>实例<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最短路径问题， 项目管理， 网络流优化， 最长公共子序列，最大连续子序列和， 矩阵连乘， 凸多边形最优三角剖分， 电路布线。</p></li></ol><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><ol><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;对问题求解时，总是做出再当前看来最好的选择，也就是说，不从整体最优上加以考虑。<br>某个状态以前的过程不会影响以后的状态，只与当前状态有关。  </li><li>与动态规划的区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;贪心算法是自顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为规模更小的子问题，最后得到一个整体最优解。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不能回退，动态规划可以</li><li>思路<br>建立数学模型来描述问题<br>把求解的问题分成若干个子问题<br>对每一子问题求解，得到子问题的局部最优解<br>八字问题的解局部最优解合成原问题的一个解  </li><li>案例<br>01背包问题， 马踏棋盘，最小生成树的Prim算法和Kruskal算法<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;能进则进，不进则退  。类似枚举的搜索尝试过程，主要再搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就返回，尝试别的路径，<em>是一种选优搜索法</em><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;需要深度优先的方式搜索解空间 </li><li>案例<br>八皇后问题<h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1></li><li><p>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生所有儿子结点，在儿子结点中，导致不可行解或者非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。再从活结点中取下一结点成为当前扩展结点。重复……<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;常以广度优先或以最小消耗优先的方式搜索问题的解空间树。</p></li><li><p>方法  </p></li></ol><ul><li>队列式(FIFO)分支限界法<br>按照队列原则选区下一个结点为扩展结点</li><li>优先队列式分支限界法<br>按优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。</li></ul><ol start="3"><li>与回溯法区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是求条件下的所有解，分支限界是一个解<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是深度优先，分支限界是广度优先   </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年第一周</title>
      <link href="/2019/02/15/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2019/02/15/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>作为新年的第一周，真的是，微笑中透露着疲惫</p><ul><li>周二给同学发了简历，然后挂了</li><li>数据结构真的不好复习</li><li>刷题真的伤时间</li><li>第一周13号线停了一周，我单程时间就变成了2小时</li><li>7：40出发，9：40到公司，心态已崩</li><li>新年愿望：<blockquote><p>换工作<br>顺利毕业<br>皮肤变好<br>瘦<br>如果可以，还有小哥哥</p></blockquote></li></ul><ul><li>最后一定要说：尹腾召是个大傻子，大猪蹄子，糟老头子</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2019/02/14/leetcode/"/>
      <url>/2019/02/14/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                if(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    arr[0] = i;</span><br><span class="line">                    arr[1] = j;</span><br><span class="line">                    return arr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间58ms，属于暴力解法了，击败24.62%的用户，太菜了  </p><ul><li>利用hashmap的动态分配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++) &#123;</span><br><span class="line">       if(map.containsKey(target-nums[i])) &#123;</span><br><span class="line">       arr[0] = map.get(target-nums[i]);</span><br><span class="line">       arr[1] = i;</span><br><span class="line">       return arr;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">       map.put( nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间8ms,击败87.66%的用户</p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p></blockquote><blockquote><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p></blockquote><blockquote><p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode newNode = new ListNode(0);</span><br><span class="line">       ListNode cur = newNode;</span><br><span class="line">        int carry = 0;//进位</span><br><span class="line">        while(l1 !=null || l2 != null)&#123;</span><br><span class="line">            int val1 = (l1 != null)? l1.val : 0;</span><br><span class="line">            int val2 = (l2 != null)? l2.val : 0;</span><br><span class="line">            int num = carry+val1+val2;</span><br><span class="line">            carry = num/10;</span><br><span class="line">            //这里如果用cur.val = num%10;</span><br><span class="line">            //就需要cur.next = new ListNode(0);</span><br><span class="line">            //反正每次结点都需要new</span><br><span class="line">        cur.next = new ListNode(num%10);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">            if(l1 != null)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 != null)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry&gt;0)//最后如果还有进位</span><br><span class="line">            cur.next = new ListNode(carry);</span><br><span class="line">        return newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间68ms,击败19.44%的用户<br>算是最直接（笨）的写法了，看来还要优化  </p><h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><p>示例 1:  </p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:  </p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。  </p></blockquote><pre><code>请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">int result = 0;</span><br><span class="line">int length = s.length();</span><br><span class="line">int i=0,j=0;</span><br><span class="line">//也可以用指针</span><br><span class="line">while(i&lt;length &amp;&amp; j&lt;length) &#123;</span><br><span class="line">if(set.contains(s.charAt(j))) &#123;</span><br><span class="line">//删掉最先出现的那个重复的</span><br><span class="line">set.remove(s.charAt(i++));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">set.add(s.charAt(j++));</span><br><span class="line">//关键的一步</span><br><span class="line">result = Math.max(result, j-i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是官方示例，关键在于对result求最大值，我之前的算法总是不能概括所有情况，后续会更新这道题（链表的形式）</p><h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4.寻找两个有序数组的中位数"></a>4.寻找两个有序数组的中位数</h1><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0<br>示例 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">//1.需要合并两个数组,并排序</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;nums1.length;i++) &#123;</span><br><span class="line">list.add(nums1[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0; j&lt;nums2.length; j++) &#123;</span><br><span class="line">list.add(nums2[j]);</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, null);</span><br><span class="line">//2.分奇偶</span><br><span class="line">int length = list.size();</span><br><span class="line">if(length%2 != 0) &#123;</span><br><span class="line">int result = list.get(length/2);</span><br><span class="line">return (double)result;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return (double)(list.get(length/2)+list.get(length/2-1))/2;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行用时94ms，击败12.56%的用户<br>内存消耗50.8MB，击败30.27%的用户</p><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><p>第一：错误示范，字符串特别长是，超时,答案是对的，但是过于暴力，不符合时间要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> * @param s</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String longestPalindrome(String s) &#123;</span><br><span class="line">//最暴力的方法：1找出所有子串</span><br><span class="line">List&lt;String&gt; list = substringAll(s);</span><br><span class="line">//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line">String result = &quot;&quot;;</span><br><span class="line">if(s.length() == 0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">if(s.length()&gt;0) &#123;</span><br><span class="line">result = s.substring(0, 1);</span><br><span class="line">&#125;</span><br><span class="line">while(list.size()&gt;0)&#123;</span><br><span class="line">String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">String tmp = list.get(0);</span><br><span class="line">for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(list.size()&gt;0 &amp;&amp; list.get(0).equals(tmp)) &#123;</span><br><span class="line">if( list.get(0).length()&gt;result.length()) &#123;</span><br><span class="line">result = list.get(0);</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">String str = s.substring(i, j);</span><br><span class="line">if(str.length()&gt;1  ) &#123;</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String str = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">System.out.println(longestPalindrome(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二：稍微改进了一点，但是还是超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //最暴力的方法：1找出所有子串</span><br><span class="line">if(s.length() == 0) &#123;</span><br><span class="line">return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String result = &quot;&quot;;</span><br><span class="line">if(s.length()&gt;0) &#123;</span><br><span class="line">result = s.substring(0, 1);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; list = substringAll(s);</span><br><span class="line">//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line"></span><br><span class="line">while(list.size()&gt;0)&#123;</span><br><span class="line">/*String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">String tmp = list.get(0);</span><br><span class="line">for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;*/</span><br><span class="line">if( list.get(0).length()&gt;result.length()) </span><br><span class="line">result = list.get(0);</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;</span><br><span class="line">//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">String str = s.substring(i, j);</span><br><span class="line">//是回文</span><br><span class="line">if(str.length()&gt;1 &amp;&amp; new StringBuffer(str).reverse().toString().equals(str)) &#123;</span><br><span class="line">if(list.size()== 0 || !list.get(list.size()-1).contains(str))</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行用时10578ms，击败了0.98%的用户<br>内存消耗380MB，击败了0.97%得用户—-真可怕</p><h1 id="6-Z-N-字形变换"><a href="#6-Z-N-字形变换" class="headerlink" title="6. Z(N)字形变换"></a>6. Z(N)字形变换</h1><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p></blockquote><blockquote><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L&#160;&#160;&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I   &#160;&#160;&#160;&#160;&#160;R<br>E &#160;T &#160;O&#160;&#160;E&#160;&#160;S&#160;&#160;&#160;I&#160;&#160;  I&#160;&#160;&#160;&#160;G<br>E&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;H   &#160;&#160;&#160;&#160;&#160;N          </p></blockquote><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><blockquote><p>string convert(string s, int numRows);  </p></blockquote><p>示例 1:</p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”  </p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;R<br>E&#160;&#160;&#160;&#160;&#160;&#160;&#160;O&#160;&#160;&#160;E&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;I<br>E&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;&#160;&#160;H&#160;&#160;&#160;&#160;&#160;&#160;N<br>T&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 7.整数反转 #</span><br><span class="line">给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> 示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure><p>class Solution {<br>    public int reverse(int x) {<br>        int rev = 0;<br>            while (x != 0) {<br>                int pop = x % 10;<br>                x /= 10;<br>                if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return 0;<br>                if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return 0;<br>                rev = rev * 10 + pop;<br>            }<br>            return rev;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">执行用时43ms,击败了64.62%的用户  </span><br><span class="line">内存消耗32.6MB,击败了43.26%的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 8.字符串转换整数 #</span><br><span class="line">这道题怎么说，我完全就是暴力求解，然后，，，，限制条件太多， 我提交了8次才对！  </span><br><span class="line"></span><br><span class="line">请你来实现一个 atoi 函数，使其能将字符串转换成整数。  </span><br><span class="line"></span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。  </span><br><span class="line"></span><br><span class="line">当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。  </span><br><span class="line"></span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。  </span><br><span class="line"></span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。  </span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。  </span><br><span class="line"></span><br><span class="line">说明：  </span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。  </span><br><span class="line"></span><br><span class="line">示例 1:  </span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;42&quot;  </span><br><span class="line">输出: 42 </span><br><span class="line"> </span><br><span class="line">示例 2:  </span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;   -42&quot;  </span><br><span class="line">输出: -42  </span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。  </span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。  </span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;4193 with words&quot;  </span><br><span class="line">输出: 4193  </span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。  </span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;words and 987&quot;  </span><br><span class="line">输出: 0  </span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。  </span><br><span class="line">     因此无法执行有效的转换。  </span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;-91283472332&quot;  </span><br><span class="line">输出: -2147483648  </span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。   </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></p><p> public static  int myAtoi(String str) {<br>         String trim = str.trim();<br>         if(str.length() == 0 || trim.length() == 0) {<br>             return 0;<br>         }<br>         int indexOf = trim.indexOf(“ “);<br>         Integer result = 0;<br>         if(indexOf != -1) {//存在空格<br>             result= getNumber(trim, indexOf);<br>         } else {<br>             result = getNumber(trim, trim.length());<br>         }<br>         return result;<br>     }<br>     private static int getNumber(String trim, int indexOf) {<br>         StringBuffer buffer = new StringBuffer();<br>         int sign = 1;<br>         boolean  flag = false; //判断是否有符号<br>         if(trim.charAt(0) == ‘-‘ ){<br>             sign = -1;<br>             flag = false;<br>         } else if(trim.charAt(0) == ‘+’ ) {<br>             sign = 1;<br>             flag = true;<br>         } else if(trim.charAt(0)&gt;=’0’ &amp;&amp; trim.charAt(0)&lt;=’9’) {<br>             if(trim.charAt(0)&gt;’0’ &amp;&amp; trim.charAt(0)&lt;=’9’) {<br>                 buffer.append(trim.charAt(0));<br>                 flag = true;<br>             }</p><pre><code>     }else {         return 0;     }     char[] charArray = trim.toCharArray();     for(int i=1;i&lt; charArray.length;i++) {         if(charArray[i]&gt;=&apos;0&apos; &amp;&amp; charArray[i]&lt;=&apos;9&apos;) {             if(charArray[i] == &apos;0&apos;) {                 if(buffer.length()&gt;0 &amp;&amp; buffer.charAt(0)&gt;&apos;0&apos;) {                     buffer.append(charArray[i]);                 }             }else {                 buffer.append(charArray[i]);             }         }else {             break;         }     }     if(buffer.length()&gt;10) {         if(flag) {             return Integer.MAX_VALUE;         }else {             return Integer.MIN_VALUE;         }     }     if(buffer.length() == 0) {         return 0;     }     if(buffer.length() == 10) {        String str = new String(buffer);        Integer consult = Integer.valueOf(str.substring(0, 9));        Integer residue = Integer.valueOf(str.substring(9, 10));        System.out.println(consult);        System.out.println(residue);         if(consult&gt;Integer.MAX_VALUE/10) {             if(flag) {                 return Integer.MAX_VALUE;             } else {                 return Integer.MIN_VALUE;             }         }else if(consult == Integer.MAX_VALUE/10) {             if(residue &lt;= Integer.MAX_VALUE%10) {                 System.out.println(Integer.valueOf(new String(buffer))*sign);                 return Integer.valueOf(new String(buffer))*sign;             } else {                 if(flag) {                     return Integer.MAX_VALUE;                 } else {                     return Integer.MIN_VALUE;                 }             }         } else {             return Integer.valueOf(new String(buffer))*sign;         }     }    return Integer.valueOf(new String(buffer))*sign;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">执行用时 50ms,击败了40.37%的用户  </span><br><span class="line">内存消耗47.9MB  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 9. 回文数 #</span><br><span class="line">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p> public boolean isPalindrome(int x) {<br>        if(x&lt;0)<br>            return false;<br>        boolean rlt = false;<br>        int rev = 0;<br>        int n = x;<br>        while (n != 0) {<br>            int pop = n % 10;<br>            n /= 10;<br>            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return false;<br>            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return false;<br>            rev = rev * 10 + pop;<br>        }<br>        if(rev == x)<br>            rlt = true;<br>        return rlt;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时146ms，击败了81.29%的用户  </span><br><span class="line">内存消耗：30.3MB，击败了63.98%的用户  </span><br><span class="line"></span><br><span class="line">emmmmm,最快的一次了</span><br><span class="line"></span><br><span class="line"># 11.盛最多水的容器 #</span><br><span class="line"></span><br><span class="line">&gt;给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">&gt;说明：你不能倾斜容器，且 n 的值至少为 2。</span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [1,8,6,2,5,4,8,3,7]  </span><br><span class="line">输出: 49</span><br><span class="line"></span><br><span class="line">暴力解</span><br></pre></td></tr></table></figure></p><p>public int maxArea(int[] height) {<br>        int max = 0;<br>        for(int i=0;i&lt;height.length;i++) {<br>            for(int j=i+1;j&lt;height.length;j++) {</p><pre><code>            int num = Math.min(height[i], height[j])*(j-i);            max = max&lt;num ? num:max;        }    }     return max;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时402ms,击败了22.18%的用户  </span><br><span class="line">内存消耗47.8MB，击败了0.96%的用户</span><br><span class="line"></span><br><span class="line">方法二：双指针法（官方题解）  </span><br><span class="line">思想：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;两线段之间形成的区域总是会受到其中较短那条长度的限制，此外，线段距离越远，得到的面积越大   </span><br><span class="line">分析：</span><br><span class="line">- 两个指针，一个指向头， 一个指向尾  </span><br><span class="line">- 每一步中，比较max，且较短线段的指针向较长线段指针的一侧移动。</span><br></pre></td></tr></table></figure><p> public int maxArea(int[] height) {<br>       int max = 0;<br>        int i=0;<br>        int j = height.length-1;<br>        while(i&lt;j) {<br>            max = Math.max(max, Math.min(height[i], height[j])*(j-i));<br>            if(height[i]&gt;height[j]) {<br>                j–;<br>            } else {<br>                i++;<br>            }<br>        }<br>         return max;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">执行用时：10ms,击败了64.19%的用户  </span><br><span class="line">内存消耗47.1MB,击败了0.96%的用户 </span><br><span class="line"></span><br><span class="line"># 13.罗马数字转整数 #</span><br><span class="line">问题</span><br><span class="line">&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。  </span><br><span class="line">字符          数值  </span><br><span class="line">I             1  </span><br><span class="line">V             5  </span><br><span class="line">X             10  </span><br><span class="line">L             50  </span><br><span class="line">C             100  </span><br><span class="line">D             500  </span><br><span class="line">M             1000  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">&gt;   通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。   </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。  </span><br><span class="line"></span><br><span class="line">给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。  </span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">输入: &quot;III&quot;  </span><br><span class="line">输出: 3  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:  </span><br><span class="line">输入: &quot;IV&quot;  </span><br><span class="line">输出: 4  </span><br><span class="line"></span><br><span class="line">&gt;示例 3:  </span><br><span class="line">输入: &quot;IX&quot;  </span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><pre><code>public static int romanToInt(String s) {    int num = 0;    for(int i=0;i&lt;s.length();i++) {        char charAt = s.charAt(i);        switch(charAt) {        case &apos;I&apos;:    num += 1;    break;        case &apos;V&apos;:    num += 5;    break;        case &apos;X&apos;:    num += 10;    break;        case &apos;L&apos;:   num += 50;    break;        case &apos;C&apos;:    num += 100;    break;        case &apos;D&apos;:    num += 500;    break;        case &apos;M&apos;:    num += 1000;    break;        default:    break;        }        //六种特殊情况        if(i != 0) {            if(( s.charAt(i) == &apos;V&apos; || s.charAt(i) == &apos;X&apos;) &amp;&amp;s.charAt(i-1) == &apos;I&apos; ) {                num -= 1*2; //*2是因为（i-1）的值之前加了一遍            }            if(( s.charAt(i) == &apos;L&apos; || s.charAt(i) == &apos;C&apos;) &amp;&amp;s.charAt(i-1) == &apos;X&apos; ) {                num -= 10*2;            }            if(( s.charAt(i) == &apos;D&apos; || s.charAt(i) == &apos;M&apos;) &amp;&amp;s.charAt(i-1) == &apos;C&apos; ) {                num -= 100*2;            }        }    }    return num;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">过于暴力啊  </span><br><span class="line">执行用时：108ms,击败了46.6%的用户  </span><br><span class="line">内存消耗：66MB,击败了0.95%的用户  </span><br><span class="line"></span><br><span class="line"># 14.最长公共前缀 #</span><br><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]  </span><br><span class="line">输出: &quot;fl&quot;  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:</span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]  </span><br><span class="line">输出: &quot;&quot;  </span><br><span class="line">解释: 输入不存在公共前缀。  </span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br><span class="line"></span><br><span class="line">方法1-横向扫描，依次对比每一个字符串</span><br></pre></td></tr></table></figure><p>if(strs == null || strs.length == 0) {<br>            return “”;<br>        }<br>        String str = strs[0];<br>        for(int i=1;i&lt;strs.length;i++) {<br>            while(strs[i].indexOf(str) != 0) {<br>                //indexOf对于数组，相同为0，不同为-1<br>                str = str.substring(0, str.length()-1);<br>                if(str.isEmpty()) {<br>                    return “”;<br>                }<br>            }<br>        }<br>        return str;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时10ms,击败了65.5%的用户  </span><br><span class="line">内存消耗38.7MB,击败了1.37%的用户  </span><br><span class="line">方法2- 二分查找法</span><br><span class="line">思想：如果（1-mid）不是所有串的公共前缀，舍弃后半个区间  </span><br><span class="line">否则，再次分割，进行查找</span><br></pre></td></tr></table></figure></p><p>public static String longestCommonPrefix(String[] strs) {<br>        if(strs == null || strs.length == 0) {<br>            return “”;<br>        }<br>        //找出最短的那个串<br>        int minLen = Integer.MAX_VALUE;<br>        for (String string : strs) {<br>            minLen = Math.min(minLen, string.length());<br>        }<br>        int low = 1;<br>        int hight = minLen;<br>        while(low&lt;= hight) {<br>            int middle = (low+hight)/2;<br>            if(isLongStr(strs,middle)){<br>                low = middle +1;<br>            }else {<br>                hight = middle-1;<br>            }<br>        }<br>        return strs[0].substring(0, (low+hight)/2);<br>    }</p><pre><code>private static boolean isLongStr(String[] strs, int middle) {    String str1 = strs[0].substring(0, middle);    for(int i=1;i&lt;strs.length;i++) {        if(!strs[i].startsWith(str1)) {            return false;        }    }    return true;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时10ms,击败了65.5%的用户  </span><br><span class="line">内存消耗40.5MB，击败了1.02%的用户  </span><br><span class="line">时间复杂度为O(s*log(n)),s表示字符中字符数量总数，n表示长度为m的相同的字符串</span><br><span class="line"></span><br><span class="line"># 20.有效的括号 #</span><br><span class="line"></span><br><span class="line">给定一个只包括 &apos;(&apos;，&apos;)&apos;，&apos;&#123;&apos;，&apos;&#125;&apos;，&apos;[&apos;，&apos;]&apos; 的字符串，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：  </span><br><span class="line"></span><br><span class="line">左括号必须用相同类型的右括号闭合。  </span><br><span class="line">左括号必须以正确的顺序闭合。  </span><br><span class="line">注意空字符串可被认为是有效字符串。  </span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;()&quot;  </span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;([)]&quot;  </span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>public static  boolean isValid(String s) {<br>        Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;();<br>        map.put(‘)’, ‘(‘);<br>        map.put(‘]’, ‘[‘);<br>        map.put(‘}’, ‘{‘);<br>        if(s == “”) {<br>            return true;<br>        }<br>       Stack<character> stack = new Stack<character>();<br>       for(int i=0;i&lt;s.length();i++) {<br>           // 如果遇到闭括号<br>           if(map.containsKey(s.charAt(i))) {<br>               char ch = stack.isEmpty()?’#’: stack.pop();<br>                //ch和值不相等，说明开括号和闭括号是不匹配的<br>                 if(ch != map.get(s.charAt(i))) {<br>                   return false;<br>               }<br>           }else {<br>               stack.push(s.charAt(i));<br>           }<br>       }</character></character></p><pre><code>   return stack.isEmpty();}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行用时：14ms,击败了23.95%的用户  </span><br><span class="line">内存消耗：35.7MB，击败了2.27%的用户  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 21.合并两个有序链表 #</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span><br><span class="line"></span><br><span class="line">&gt;示例：  </span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4  </span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Definition for singly-linked list.</li><li>public class ListNode {</li><li>int val;</li><li>ListNode next;</li><li>ListNode(int x) { val = x; }</li><li><p>}<br>*/<br>class Solution {<br> public ListNode mergeTwoLists(ListNode l1, ListNode l2) {</p><pre><code>ListNode newNode = new ListNode(0);ListNode cur = newNode;while(l1 != null &amp;&amp; l2 != null) {    if(l1.val&lt;l2.val) {        cur.next = l1;        cur = cur.next;        l1 = l1.next;    }else {        cur.next = l2;        cur = cur.next;        l2 = l2.next;    }</code></pre></li></ul><pre><code>    }    if(l1 == null ) {        cur.next = l2;    }    if(l2 == null) {        cur.next = l1;    }    return newNode.next;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">执行用时16ms，击败了59.56%的用户</span><br><span class="line">内存消耗42.9MB,击败了0.97%的用户 </span><br><span class="line"></span><br><span class="line"># 26.删除排序数组中的重复项 #</span><br><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。  </span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;给定数组 nums = [1,1,2],  </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [0,0,1,1,1,2,2,3,3,4],  </span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">思路：在看到这道题的时候，首先根据题目意思：有序   </span><br><span class="line">意味着，是递增或者递减的，而且因为是引用，那么删除之后的数组也是有序的</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        if(nums.length&lt;=1){<br>            return nums.length;<br>        }<br>        int count = 0;<br>        for(int i=0;i&lt;nums.length-1;) {<br>             while(nums[i] == nums[i+1] &amp;&amp; i&lt;(nums.length-count-1)) {<br>                 for(int j=i;j&lt;nums.length-1;j++) {<br>                     nums[j] = nums[j+1];<br>                 }<br>                 count++;<br>                 if(nums[i] != nums[i+1]) {<br>                     i = i+1;<br>                 }</p><pre><code>         }         if(nums[i] == nums[nums.length-1]) {             break;         }else if(nums[i] != nums[i+1]) {             i++;         }     }     return (nums.length-count);}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不知道是不是几天没碰代码，这道题写的过于暴力：  </span><br><span class="line">执行用时114ms,击败了6.88%的提交记录，  </span><br><span class="line">内存消耗47MB   </span><br><span class="line">估计是这道题最笨的一种解法了</span><br><span class="line"></span><br><span class="line">然后看了一下官方实例，真的是，巧妙了：</span><br></pre></td></tr></table></figure></p><p>public int removeDuplicates(int[] nums) {<br>    if (nums.length == 0) return 0;<br>    int i = 0;<br>    for (int j = 1; j &lt; nums.length; j++) {<br>        if (nums[j] != nums[i]) {<br>            i++;<br>            nums[i] = nums[j];<br>        }<br>    }<br>    return i + 1;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">利用了快慢指针的思想,i是慢指针，j是快指针，只要nums[i] == nums[j]就利用j++来跳过重复项</span><br><span class="line"># 27.移除元素 #</span><br><span class="line"></span><br><span class="line">给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。  </span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。  </span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">给定 nums = [3,2,2,3], val = 3,  </span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。  </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:  </span><br><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,  </span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。  </span><br><span class="line">注意这五个元素可为任意顺序。  </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">说明:  </span><br><span class="line"></span><br><span class="line">为什么返回数值是整数，但输出的答案是数组呢?  </span><br><span class="line"></span><br><span class="line">请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。  </span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:  </span><br><span class="line"></span><br><span class="line">&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝  </span><br><span class="line">int len = removeElement(nums, val);  </span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。  </span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。  </span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;  </span><br><span class="line">    print(nums[i]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>public static int removeElement(int[] nums, int val) {<br>        int i=0;<br>        int j=nums.length-1;<br>        int len = 0;<br>        while(i&lt;=j) {<br>            if(nums[i] == val) {<br>                int tmp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = tmp;<br>                j–;<br>            }else {<br>                i++;<br>                ++len;<br>            }<br>        }<br>        return len;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时：9ms,击败了69.33%的用户  </span><br><span class="line">内存消耗：69.6MB,击败了0.97%的用户  </span><br><span class="line"># 28.实现strStr() #</span><br><span class="line">实现 strStr() 函数。</span><br><span class="line"></span><br><span class="line">给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;  </span><br><span class="line">输出: 2  </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;  </span><br><span class="line">输出: -1  </span><br><span class="line"></span><br><span class="line">&gt;当needle为空字符串时，返回0</span><br><span class="line"></span><br><span class="line">实际上就是字符串匹配问题，这里用到了KMP算法</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int strStr(String haystack, String needle) {<br>        if(needle.length() == 0 &amp;&amp; haystack.length() != 0) {<br>             return 0;<br>         }<br>         if(haystack.equals(needle)) {<br>             return 0;<br>         }<br>         int[] next = getNext(needle);<br>         int i=0;<br>         int j=0;<br>         while(i&lt;haystack.length() &amp;&amp; j&lt;needle.length()) {<br>             if(-1 == j || haystack.charAt(i) == needle.charAt(j)) {<br>                 i++;<br>                 j++;<br>             }else {<br>                 j = next[j];<br>             }<br>         }<br>         if(j&gt;= needle.length()) {<br>             return i-j;<br>         }else {<br>             return -1;<br>         }<br>    }<br>    public int[] getNext(String needle) {<br>        int[] next = new int[needle.length()];<br>        next[0] = -1;<br>        int i = 0;<br>        int j = -1;<br>        String[] T = needle.split(“”);<br>        while(i&lt;T.length-1) {<br>                if(-1 == j || T[i].equals(T[j])) {<br>                    i++;<br>                    j++;<br>                    if(T[i] != T[j]) {<br>                        next[i] = j;<br>                    }else {<br>                        next[i] = next[j];<br>                    }<br>                }else {<br>                    j = next[j];<br>                }<br>        }<br>        return next;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时73ms,击败了8.92%的用户  </span><br><span class="line">内存消耗37.5MB,击败了0.93%的用户</span><br><span class="line"></span><br><span class="line">但是不知道为啥，用BF算法竟然要快？？</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int strStr(String haystack, String needle) {<br>        if(needle.length() == 0) {<br>             return 0;<br>         }<br>         if(haystack == needle) {<br>             return 0;<br>         }<br>         String[] S = haystack.split(“”);<br>         String[] T = needle.split(“”);<br>         int i = 0;<br>          int j = 0;<br>          while(i&lt;S.length &amp;&amp; j&lt;T.length) {<br>             if(S[i].equals(T[j])) {<br>                 i++;<br>                 j++;<br>             } else {<br>                 i = i-j+1;<br>                 j = 0;<br>             }<br>             if(j == T.length) {<br>                 return i-T.length;</p><pre><code>         }       }     return -1;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时44ms,击败了9.28%的用户 </span><br><span class="line">内存消耗41.8MB</span><br><span class="line"># 42.接雨水 #</span><br><span class="line"></span><br><span class="line">是一道难题，思路难，以下是百度的答案 (思路是百度给的，但是没有看答案哟)</span><br><span class="line">&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line">![](leetcode/接雨水.PNG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]  </span><br><span class="line">输出: 6  </span><br><span class="line">分析：</span><br><span class="line">如果想接到雨水，需要满足的条件是</span><br><span class="line">- height[i-1]&gt;height[i]</span><br><span class="line">- height[i]&lt;height[i+1]  </span><br><span class="line"></span><br><span class="line">假设已知最高点的坐标macIndex及其高度maxValue,考虑从左逐渐靠近最高点，此时，只需考虑第一个条件，因为始终有height[maxIndex]&gt;height[i]   </span><br><span class="line">*局部最高curRoot*</span><br><span class="line">局部最高与其余高度值得差值和即为积水和。  </span><br><span class="line">例如上例；积水和分别为:</span><br><span class="line">&gt;左侧：[0,1,1,2,2,2,2]（左往右）,那么左侧积水和为1+1+2+1 = 5</span><br><span class="line">&gt;右侧:[2,2,2,1]（右往左）,那么左侧积水和为1+1</span><br><span class="line">积水和为：5+1 = 6    </span><br><span class="line">  </span><br><span class="line">方法：</span><br><span class="line">- 遍历整个数组，找最高点  </span><br><span class="line">- 从左向右遍历至最高点坐标，求积水和</span><br><span class="line">- 从右向左遍历至最高点坐标，求积水和</span><br></pre></td></tr></table></figure></p><p> /**</p><pre><code>  * 接雨水  * @param height  * @return  */ public static int trap(int[] height) {     if(height == null || height.length == 0) {         return 0;     }    int max = 0;    int maxIndex = 0;   //遍历数组找到最高点    for(int i=0;i&lt;height.length;i++) {        if(height[i]&gt;max) {            maxIndex = i;            max = height[i];        }    }    int left = 0,right = 0;    //从左向右遍历至最高点，返回积水和    if(maxIndex&gt;0) {        left = countWaterLeft(0, maxIndex, height);    }    //从右向左遍历至最高点，返回积水和    if(maxIndex&lt;height.length-1) {        right = countWaterRight(maxIndex, height.length-1, height);    }    max = left+right;    return max;  }public static int countWaterRight(int maxIndex, int length, int[] height) {    int res = 0;    int[] result = new int[length - maxIndex];    int j=result.length-2;    //height: 0,1,0,2,1,0,1,3,2,1,2,1     //result:               [2,2,2,1]    result[result.length-1] = height[length];    for(int i=length-1;i&gt;maxIndex;i--) {        result[j] = Math.max(result[j+1], height[i]);        res += Math.abs((result[j]-height[i]));        j--;    }    return res;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时24ms,击败了43.90%的用户  </span><br><span class="line">内存消耗453.MB，击败了0.94%的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">来一份网友答案：：</span><br></pre></td></tr></table></figure><p>找到三个值，第一是头值，第二是尾值，第三是除去头和尾之外，中间的最大值，如果中间的最大值小于头和尾的最小值，那么直接就可以计算出结果，如大于等于最大值（其实等于也可以直接处理，避免下一次递归，但是我为了懒省事没写。。。），则从中间把它们一分为二，再分别求值加到一起。运行时间11ms,超越100%。<br>class Solution {<br>    public int trap(int[] height) {<br>        if(height.length&lt;3){<br>            return 0;<br>        }<br>        return find(height,0,height.length-1);<br>    }<br>    public int find(int[] height,int start,int end){<br>        if(end-start&lt;2){//递归的终点<br>            return 0;<br>        }<br>        int max=-1,tmp=-1,min_two=Math.min(height[start],height[end]),sum=0;;<br>        for(int i=start+1;i&lt;end;i++){<br>            //这一句写在哪里都行<br>            sum=sum+(min_two-height[i]);<br>            if(height[i]&gt;max){<br>                max=height[i];<br>                tmp=i;<br>            }<br>        }</p><pre><code>    if(max&lt;min_two){//上面的加法其实应该在这里，转移到上面和在这里其实都一样        //sum=sum+(min_two-height[i]);        return sum;    }else{//其实这里还可以优化一下当中间的max值等于start或者end的时候，当它等于start,那么直接计算即可，不用进行下一次递归，因为下一次递归会再扫描一遍        return find(height,start,tmp)+find(height,tmp,end);    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 80.删除排序数组中的重复项II #</span><br><span class="line"></span><br><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [1,1,1,2,2,3],  </span><br><span class="line">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [0,0,1,1,1,1,2,3,3],  </span><br><span class="line">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        if(nums.length == 0)<br>            return 0;<br>        int i = 0;<br>         int j = 1;<br>         for(j=1;j&lt;nums.length;j++) {<br>             if(nums[i] != nums[j] ) {<br>                 i++;<br>                 if((j-i)&gt;=1) {<br>                     nums[i+1] = nums[j];<br>                 }</p><pre><code>         }     }    return i+2;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在做完第26题之后趁热打铁，哈哈哈哈   </span><br><span class="line">执行用时2ms,击败了91.59%的用户  </span><br><span class="line">执行用时38.4MB,击败了0.89%的用户    </span><br><span class="line"></span><br><span class="line">但是看了大神的，啊啊啊，难受：</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        int i = 0;<br>        for (int n : nums)<br>            if (i &lt; 2 || n &gt; nums[i-2])<br>                nums[i++] = n;<br>        return i;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 88.合并两个有序数组 #</span><br><span class="line">给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</span><br><span class="line"></span><br><span class="line">&gt;说明:  </span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n。  </span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入:  </span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3  </span><br><span class="line">nums2 = [2,5,6],       n = 3  </span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 102.二叉树的层次遍历 #</span><br><span class="line">要求，使用迭代的方法  </span><br><span class="line">利用队列先进先出的特点，每次入队一层，出队，再进行下一层</span><br></pre></td></tr></table></figure><p>class Solution{<br>    public List&lt;List<integer>&gt; levelOrder(TreeNode root){<br>        List&lt;List<integer>&gt; rlt = new ArrayList&lt;List<integer>&gt;();<br>        if(root != null){<br>            return rlt;<br>        }<br>        Queue<treenode> queue = new LinkedList<treenode>();<br>        queue.offer(root);<br>        while(!quque.isEmpty()){<br>            List<integer> list = new ArrayList<integer>();<br>            int count = queue.size();<br>            while(count&gt;0){<br>                TreeNode node = queue.poll();<br>                list.add(node.val);<br>                if(node.left != null){<br>                    queue.offer(node.left);<br>                }<br>                if(node.right != null){<br>                    queue.offer(node.right);<br>                }<br>            }<br>            rlt.add(list);<br>        }<br>        return rlt;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行用时2ms,击败了68.09%的用户  </span><br><span class="line">内存消耗35.8MB,击败了0.84%的用户</span><br><span class="line"></span><br><span class="line"># 144.二叉树的前序遍历 #</span><br><span class="line">注意，这里因为前序遍历的时候是：根-左-右  </span><br><span class="line">所以遍历的时候，是先右后左</span><br></pre></td></tr></table></figure></integer></integer></treenode></treenode></integer></integer></integer></p><p>class Solution{<br>    public List<integer> preorderTraversal(TreeNode root){<br>    List<integer> list = new ArrayList<integer>();<br>    if(root == null)<br>        return list;<br>    }<br>    Stack<treenode> stack = new Stack<treenode>();<br>    stack.push(root);<br>    while(!stack.isEmpty()){<br>        TreeNode node = stack.pop();<br>        list.add(node.val);<br>        if(node.right != null){<br>            stack.push(node.right);<br>        }<br>        if(node.left != null){<br>            stack.push(node.left);<br>        }<br>    }<br>    return list;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行用时1ms,击败了86.31%的用户  </span><br><span class="line">内存消耗33.5MB,击败了0.75%的用户  </span><br><span class="line"># 136.只出现一次的数字#</span><br><span class="line"></span><br><span class="line">利用了异或的原理，1^1 = 0，0^n = n;</span><br></pre></td></tr></table></figure></treenode></treenode></integer></integer></integer></p><p>class Solution{<br>    public int singleNumber(int[] nums){<br>        int result = nums[0];<br>        for(int i=1;i&lt;nums.length;i++){<br>            result = nums[i]^result;<br>        }<br>        return result;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行用时1ms,击败了99.44%的用户  </span><br><span class="line">内存消耗38.7MB,击败了0.89%的用户  </span><br><span class="line"></span><br><span class="line"># 344.反转字符串 #</span><br><span class="line">&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。  </span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。  </span><br><span class="line">你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&gt;示例 1：  </span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]  </span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class="line"></span><br><span class="line">&gt;示例 2：  </span><br><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]  </span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public void reverseString(char[] s) {<br>        for(int i=0,j = s.length-1;i&lt;j;i++,j–) {<br>            char tmp = s[i];<br>            s[i] = s[j];<br>            s[j] = tmp;<br>        }<br>        for(int i=0;i&lt;s.length;i++) {<br>            System.out.print(s[i]);<br>        }<br>    }<br>}<br><code>`</code><br>执行用时</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2019/02/14/%E6%A0%91/"/>
      <url>/2019/02/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是一对多的数据结构<br>树是n个结点的有限集，当n = 0 时称为空树。在任意一棵非空树中：  </p><ul><li>有且仅有一个特定的称为根的结点</li><li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每个集合本身又是一棵树，并称为根的子树(SubTree)   <a id="more"></a>  </li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li><p>度<br>结点拥有的子树，树的度是各结点度的最大值<br>度为 0 的结点称为叶节点(leaf)或者终端结点<br>度不为0 的结点称为分支结点，或非终端节点，除了根节点外，分支结点也称为内部结点。</p></li><li><p>结点的层次(level)<br>结点的层次从根开始定在一起，根为第一层<br>双亲在同一层的结点互为堂兄弟</p></li><li><p>结点的祖先<br>从根节点到该节点所经过分支上的所有结点</p></li><li><p>深度或高度<br>结点的最大层次称为树的深度(depth)或高度</p></li><li><p>森林(fores)<br>由m(m&gt;=0)棵互不相交的树组成的集合 </p></li><li><p>兄弟(sibling)<br>同一个双亲的孩子之间称为兄弟 </p></li><li><p>无序树和有序树<br>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则是有序树，否则是无序树。</p></li></ul><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>顺序结构和链表结构都是一对一；树可以实现一对多的结构</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指向其双亲结点到链表中的位置。<br><img src="/2019/02/14/树/treeParent.PNG" alt=""></p><p><strong><em>需要知道自己的数据和双亲位置</em></strong></p><p><strong>优点</strong><br>&#160;&#160;&#160;&#160;找到双亲的速度很快，复杂度为O(1)<br><strong>缺点</strong><br>&#160;&#160;&#160;&#160;如果需要找到孩子数据，需要遍历整个结构</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>数组和链表的搭配结合<br>孩子表示法<br><img src="/2019/02/14/树/treeChildren" alt="">  </p><p>双亲孩子表示法<br><img src="/2019/02/14/树/treeChildrenParent" alt="">  </p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>左孩子右兄弟</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BF and KMP</title>
      <link href="/2019/02/12/BF-and-KMP/"/>
      <url>/2019/02/12/BF-and-KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;全称探索与回溯法，是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。<br>&#160;&#160;&#160;&#160;当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择——走不通退一步的技术为回溯法，满足回溯条件的某一个状态的点称为“回溯点” </p><h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><ul><li>针对给定的问题，定义问题的解空间</li><li>确定易于搜索的解空间结构</li><li>以深度优先方式搜索解空间，再广度优先方式搜索</li></ul><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>背包问题，八皇后问题（递归和回溯），多用于树</p><h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;暴风（Brute Force）算法，是普通的模式匹配算法</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>&#160;&#160;&#160;&#160;将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，得到最后的匹配结果，是一个暴力算法。时间复杂度O(M<em>(N-M+1)) = O(M</em>N),其中M&lt;N</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line">/**</span><br><span class="line"> * 暴风算法，简单的模式匹配</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BF &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//主串</span><br><span class="line">String s = &quot;iloveyou&quot;;</span><br><span class="line">String[] S = s.split(&quot;&quot;);</span><br><span class="line">//字串</span><br><span class="line">String t = &quot;loveeee&quot;;</span><br><span class="line">String[] T = t.split(&quot;&quot;);</span><br><span class="line">//从第0位开始匹配</span><br><span class="line">bruteForce(S,T,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void bruteForce(String[] S, String[] T, int pos) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int j = 0;</span><br><span class="line">while(i&lt;S.length &amp;&amp; j&lt;T.length) &#123;</span><br><span class="line">//这里不可以用&quot; == &quot;,我们比较的是内容</span><br><span class="line">if(S[i].equals(T[j])) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i = i-j+1;</span><br><span class="line">j = 0;</span><br><span class="line">&#125;</span><br><span class="line">if(j == T.length) &#123;</span><br><span class="line">System.out.println(&quot;T在S中的下标位置：&quot;+(i-T.length));</span><br><span class="line">break;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">if(i == S.length &amp;&amp; j != T.length) &#123;</span><br><span class="line">System.out.println(&quot;不匹配&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>&#160;&#160;&#160;&#160;由D·E·Knuth、J·H·Morris 和 V·R·Pratt三人设计的线性时间字符串匹配算法。<br>&#160;&#160;&#160;&#160;KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息，时间复杂度为：</p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;O(M+N)</p><h2 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h2><p><strong>前缀</strong>  </p><p>除了最后一个字符以外，一个字符串的全部头部<strong><em>集合</em></strong><br><strong>后缀</strong>     </p><p>除了第一个字符以外，一个字符串的全部尾部<strong><em>集合</em></strong>  </p><p><strong>案例</strong>  </p><ul><li>字符串：A<br>前缀：空集<br>后缀：空集<br>共有长度：0  </li><li>字符串：AB<br>前缀：A<br>后缀：B<br>共有长度：0  </li><li>字符串：ABC<br>前缀：[A,AB]<br>后缀：[B,BC]<br>共有长度：0  </li><li>字符串：ABCD<br>前缀：[A,AB,ABC]<br>后缀：[BCD,CD,D]<br>共有长度：0</li></ul><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>next数组存的是当前字符串前缀和后缀的共有长度，因此对比的时候是需要用两个相同的字符串进行比较。<br>分析：</p><ul><li>若T(模式串),T[i] == T[j]<br>相等，说明 前缀 == 后缀，此时要进行后一位的匹配：i++;&#160;&#160;j++;&#160;&#160;&#160;next[i] = j;</li><li>否则，j要回溯<br>前缀是固定的，后缀是相对的。<br>j = next[j];<br>j为下一次要匹配的位置</li><li>因为i是后缀，j是前缀，初始时，i = j+1;<br>图解：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * KMP字符串匹配模式</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class KMP &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 字符的前后缀最高长度-next数组</span><br><span class="line"> */</span><br><span class="line">public static void getNext(String s) &#123;</span><br><span class="line">char[] p = s.toCharArray();</span><br><span class="line">    int[] next = new int[p.length];</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = -1;</span><br><span class="line">    while (i &lt; p.length - 1) &#123; </span><br><span class="line">       if (j == -1 || p[i] == p[j]) &#123;</span><br><span class="line">       i++;</span><br><span class="line">       j++;</span><br><span class="line">           next[i] = j;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">       //回溯</span><br><span class="line">           j = next[j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">for(int n=0;n&lt;next.length;n++) &#123;</span><br><span class="line">System.out.print(next[n]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String S = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">getNext(S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kmp算法实现"><a href="#kmp算法实现" class="headerlink" title="kmp算法实现"></a>kmp算法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if(needle.length() == 0 &amp;&amp; haystack.length() != 0) &#123;</span><br><span class="line">         return 0;</span><br><span class="line">         &#125;</span><br><span class="line">         if(haystack.equals(needle)) &#123;</span><br><span class="line">         return 0;</span><br><span class="line">         &#125;</span><br><span class="line">         int[] next = getNext(needle);</span><br><span class="line">         int i=0;</span><br><span class="line">         int j=0;</span><br><span class="line">         while(i&lt;haystack.length() &amp;&amp; j&lt;needle.length()) &#123;</span><br><span class="line">         if(-1 == j || haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">         i++;</span><br><span class="line">         j++;</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">         j = next[j];</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         if(j&gt;= needle.length()) &#123;</span><br><span class="line">         return i-j;</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">         return -1;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int[] getNext(String needle) &#123;</span><br><span class="line">int[] next = new int[needle.length()];</span><br><span class="line">        next[0] = -1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = -1;</span><br><span class="line">        String[] T = needle.split(&quot;&quot;);</span><br><span class="line">        while(i&lt;T.length-1) &#123;</span><br><span class="line">        if(-1 == j || T[i].equals(T[j])) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">        j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h2><p>例如当主串为：ssssssssa<br>字串为：sssa时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if(needle.length() == 0 &amp;&amp; haystack.length() != 0) &#123;</span><br><span class="line">         return 0;</span><br><span class="line">         &#125;</span><br><span class="line">         if(haystack.equals(needle)) &#123;</span><br><span class="line">         return 0;</span><br><span class="line">         &#125;</span><br><span class="line">         int[] next = getNext(needle);</span><br><span class="line">         int i=0;</span><br><span class="line">         int j=0;</span><br><span class="line">         while(i&lt;haystack.length() &amp;&amp; j&lt;needle.length()) &#123;</span><br><span class="line">         if(-1 == j || haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">         i++;</span><br><span class="line">         j++;</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">         j = next[j];</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         if(j&gt;= needle.length()) &#123;</span><br><span class="line">         return i-j;</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">         return -1;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int[] getNext(String needle) &#123;</span><br><span class="line">int[] next = new int[needle.length()];</span><br><span class="line">        next[0] = -1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = -1;</span><br><span class="line">        String[] T = needle.split(&quot;&quot;);</span><br><span class="line">        while(i&lt;T.length-1) &#123;</span><br><span class="line">        if(-1 == j || T[i].equals(T[j])) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        if(T[i] != T[j]) &#123;</span><br><span class="line">        next[i] = j;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">        next[i] = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">        j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归与分治</title>
      <link href="/2019/02/08/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/"/>
      <url>/2019/02/08/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>直接或间接调用自身的一种方法，减少了程序的代码量，即：<br>&#160;&#160;&#160;&#160;用有限的语句定义对象的无限集合<br>前提条件：</p><ul><li>不可无限制的调用自己，需要有一个出口</li><li>子问题不可大于原始问题<a id="more"></a>最典型的递归案例是：斐波那契数列，汉诺塔（梵塔），背包问题，快排、树<br><strong>缺点</strong><br>运行效率低，因此除非没有更好的算法，或者是特定条件下，一般不建议使用递归。<br>递归调用的过程中，系统为每一层的返回点、局部变量等都开辟了栈来存储，因此如果过多的使用递归，容易造成栈溢出。</li></ul><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p>源于分而治之的思想，将大问题分成小问题，将小问题再分成更小的问题，一直到最后的子问题可以简单的直接求解。源问题的解即子问题解的合并。<br>经典案例：快排、归并排序，傅里叶转换</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>需要反复执行的子程序，进行一次重复，即重复执行程序中的循环，直到满足某条件为止。</p><h1 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h1><p><img src="/2019/02/08/递归与分治/loop.PNG" alt=""></p><h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><p>递归与分治很相似，但是不同的是，分治是：将大问题划分小问题，递归的去解决，再进行合并</p><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><ul><li>先排序，查找的一定是有序的数组或者链表</li><li>确定中间位置 mid = (left+right)/2</li><li>查找元素与mid进行比较，再对mid和left/right进行重新赋值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 折半查找问题</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Bisearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">System.out.println(&quot;输入要查找的数据&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">scan.close();</span><br><span class="line">getSearch(0,arr.length,n,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getSearch(int left, int right, int n,int[] arr) &#123;</span><br><span class="line">if(right&gt;left) &#123;</span><br><span class="line">int mid = (left+right)/2;</span><br><span class="line">if(n&lt;arr[mid]) &#123;</span><br><span class="line">getSearch(left, mid-1, n, arr);</span><br><span class="line">&#125; else if(n == arr[mid]) &#123;</span><br><span class="line">System.out.println(&quot;找到数据，下标为：&quot;+mid);</span><br><span class="line">&#125; else if(n&gt;arr[mid]) &#123;</span><br><span class="line">getSearch(mid+1, right, n, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;不存在该数据&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>汉诺塔时一个发源于印度的益智游戏，也叫河内塔。相传它源于印度神话中的大梵天创造的三个金刚柱，一根柱子上叠着上下从小到大64个黄金圆盘。大梵天命令婆罗门将这些圆盘按从小到大的顺序移动到另一根柱子上，其中大圆盘不能放在小圆盘上面。当这64个圆盘移动完的时候，世界就将毁灭。</p><p>问题：一个由多个放置在三个塔座上的盘子组成的一个古老的难题。<br>&#160;&#160;&#160;&#160;所有的盘子直径是不同的，并且盘子中央都有一个洞可以使它们刚好放在塔座上，所有的盘子刚开始都放在塔座A上。</p><p>目标是：将所有的盘子都从塔座A移动到塔座C上，每一次只移动一个盘子，并且任何一个盘子都不可以放在比自己小的盘子之上。  </p><p>分析：</p><ul><li>若n == 1<br>直接从A到C</li><li>若n ==2<br>(n-1)到B,n到C，(n-1)到C  </li><li>若n == 3<br>(n-2)到C，(n-1)到B，(n-2)到B，n到C，(n-2)到A，(n-1)到C，(n-2)到C</li></ul><p>分析：</p><ul><li>将A上的(n-1)盘子放在B上，n放在C上，其余再放到C上</li><li>n == 1,A-C</li><li>n == 2,A-B,A-C,B-C</li><li>n == 3, A-C,A-B,C-B,A-C,B-A,B-C,A-C</li></ul><p>思路：</p><ul><li>将(n-1)从A到B上<br>A借助C到B柱子上</li><li>n从A到C上<br> 输出</li><li>(n-1)从B到C上<br>B借助A到C柱子上去</li><li>递归ACB,BAC</li></ul><p><img src="/2019/02/08/递归与分治/hanoi.PNG" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 汉诺塔问题-A换到C柱子上去</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Hanoi &#123;</span><br><span class="line"></span><br><span class="line">private static int count = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共多少个盘子&quot;);</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">while(n&lt;1) &#123;</span><br><span class="line">System.out.println(&quot;请重新输入：&quot;);</span><br><span class="line">n = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">hanoiTest(n,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);</span><br><span class="line">System.out.println(&quot;总步数：&quot;+count);</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void hanoiTest(int n, String A, String B, String C) &#123;</span><br><span class="line">if(n == 1) &#123;</span><br><span class="line">move(A,C);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">hanoiTest(n-1, A, C, B);//n-1个盘子</span><br><span class="line">move(A,C);</span><br><span class="line">hanoiTest(n-1, B, A, C); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void move(String a, String c) &#123;</span><br><span class="line">count++;</span><br><span class="line">System.out.println(a+&quot;---&gt;&quot;+c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>回溯算法的典型例题，这里先用递归实现<br>&#160;&#160;&#160;&#160;是国际西洋棋棋手马克斯·贝瑟尔1848年提出，高斯算出了76种，后有人用图论法解出92种结果。<br>问题：<br>在8X8的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行，同一列，同一斜线上，有多少种解法(92)  </p><p>分析：  </p><ul><li>判断行和列</li><li>判断当前棋格的左上方，右上方，四列是否有皇后</li><li>不判断左或右下方是因为，我们是考虑第一行到本行的棋格</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line">/**</span><br><span class="line"> * 八皇后问题</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class EightQueen &#123;</span><br><span class="line"></span><br><span class="line">private static int count = 1;</span><br><span class="line">private static int[][] arr ;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">arr = init();</span><br><span class="line">//起始行，列数，数组</span><br><span class="line">eightQ(0,arr[0].length,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int[][] init() &#123;</span><br><span class="line">int[][] arr = new int[8][8];</span><br><span class="line">//初始化</span><br><span class="line">for(int i=0;i&lt;8;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;8;j++) &#123;</span><br><span class="line">arr[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 递归算法</span><br><span class="line"> * @param row  行</span><br><span class="line"> * @param length  列</span><br><span class="line"> * @param arr 8X8棋格</span><br><span class="line"> */</span><br><span class="line">private static void eightQ(int row, int length, int[][] arr) &#123;</span><br><span class="line">//这里不对Length做判断，是因为八皇后，，，，，八列</span><br><span class="line">int[][] tmp = arr;</span><br><span class="line">//列</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">if(check(row, i, tmp)) &#123;</span><br><span class="line">tmp[row][i] = 1;</span><br><span class="line">//判断是不是最后一行</span><br><span class="line">if(row == 7) &#123;</span><br><span class="line">show(tmp);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">eightQ(row+1, length, arr);</span><br><span class="line">&#125;</span><br><span class="line">//精华</span><br><span class="line">                //用回溯法，当前行放不了皇后之后，回溯到上一行，将上一行清零 ，</span><br><span class="line">//再判断当前列i之后的列是否可以放皇后</span><br><span class="line">tmp[row][i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否能放皇后</span><br><span class="line"> * @param row</span><br><span class="line"> * @param col</span><br><span class="line"> * @param tmp</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static boolean check(int row, int col,int[][] tmp) &#123;</span><br><span class="line">//上面</span><br><span class="line">for(int i = row-1; i&gt;=0; i--) &#123;</span><br><span class="line">if(tmp[i][col] == 1) &#123;</span><br><span class="line">return false;//不可以放皇后</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//左上（行减小，列减小）</span><br><span class="line">for(int i = row-1,j = col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--) &#123;</span><br><span class="line">if(tmp[i][j] == 1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//右上（行减小，列增大）</span><br><span class="line">for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;8;i--,j++) &#123;</span><br><span class="line">if(tmp[i][j] == 1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 打印棋盘</span><br><span class="line"> */</span><br><span class="line">private static void show(int[][] tmp) &#123;</span><br><span class="line">System.out.println(&quot;第&quot;+count+&quot;种摆放方式&quot;);</span><br><span class="line">for(int i=0;i&lt;8;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;8;j++) &#123;</span><br><span class="line">System.out.print(tmp[i][j]+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列1</title>
      <link href="/2019/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%971/"/>
      <url>/2019/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%971/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>又名堆栈。先进后出（Last in first out,LIFO）的线性表，要求只在&#160;<em>表尾</em>&#160;进行删除和插入操作，只移动栈顶指针，不允许改变栈底指针。<br><a id="more"></a><br>注意：</p><ul><li>一定要判断栈是否满，是否空</li><li>建表时，要考虑栈数据的类型，可能会有多种数据类型<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="顺序栈（数组）"><a href="#顺序栈（数组）" class="headerlink" title="顺序栈（数组）"></a>顺序栈（数组）</h3></li></ul><ol><li>基础操作  </li></ol><ul><li>判断栈是否为空</li><li>判断是否栈满，若满，返回false或者增加容量</li><li>栈的大小</li><li>返回栈顶元素</li><li>入栈</li><li>进栈  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Base &#123;</span><br><span class="line">/** 栈大小 */</span><br><span class="line">private int maxSize ; </span><br><span class="line"></span><br><span class="line">/** 栈顶 */</span><br><span class="line">private int top ; </span><br><span class="line"></span><br><span class="line">/** 数据域 */</span><br><span class="line">private ArrayList&lt;Object&gt; data;</span><br><span class="line"></span><br><span class="line">/** 新增容量 */</span><br><span class="line">private static final int INCREAT = 10;</span><br><span class="line">/** </span><br><span class="line"> * 判断是否为Null栈</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top == -1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Base() &#123;</span><br><span class="line">this.maxSize = 0;</span><br><span class="line">this.data = new ArrayList&lt;&gt;();</span><br><span class="line">this.top = -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断是否栈满</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isFill() &#123;</span><br><span class="line">return top &gt;= maxSize-1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈的大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int Size() &#123;</span><br><span class="line">return maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回栈顶元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object top() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return data.get(top--);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 入栈</span><br><span class="line"> * @param n</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public void Push(Object n) &#123;</span><br><span class="line">//栈满,扩大栈</span><br><span class="line">if(isFill()) &#123;</span><br><span class="line">maxSize += INCREAT;//这里用的是集合，可以不用写，但如果用数组，要写的</span><br><span class="line">&#125;</span><br><span class="line">data.add(n);</span><br><span class="line">top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 弹栈</span><br><span class="line"> * @return Object类型，是因为不知道入栈的到底是什么妖魔鬼怪</span><br><span class="line"> */</span><br><span class="line">public Object Pop() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">Base b = new Base();</span><br><span class="line">b.Push(1);</span><br><span class="line">b.Push(&quot;h&quot;);</span><br><span class="line">System.out.println(&quot;栈顶元素：&quot;+b.top());</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+b.Size());</span><br><span class="line">b.Push(&quot;aa&quot;);</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">栈大小：10</span><br><span class="line">出栈：h</span><br><span class="line">出栈：1</span><br><span class="line">出栈：null</span><br><span class="line">出栈：null</span><br><span class="line">出栈：null</span><br></pre></td></tr></table></figure><h2 id="链表栈"><a href="#链表栈" class="headerlink" title="链表栈"></a>链表栈</h2><p>方法一：</p><ul><li>头尾指针</li><li>头指针 == 尾指针 时，链表为空<br><strong>节点类</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** 指针域 */</span><br><span class="line">private Stack top ; </span><br><span class="line"></span><br><span class="line">/** 数据域 */</span><br><span class="line">private Object data;</span><br><span class="line"></span><br><span class="line">public Stack getTop() &#123;</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTop(Stack top) &#123;</span><br><span class="line">this.top = top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setData(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack(Object data) &#123;</span><br><span class="line">super();</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack(Stack top, Object data) &#123;</span><br><span class="line">super();</span><br><span class="line">this.top = top;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.stack;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表栈</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LinkedStack &#123;</span><br><span class="line">/** 栈顶 */</span><br><span class="line">private Stack top ;</span><br><span class="line"></span><br><span class="line">/** 栈底 */</span><br><span class="line">private Stack base;</span><br><span class="line"></span><br><span class="line">/** 栈大小 */</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> */</span><br><span class="line">public LinkedStack() &#123;</span><br><span class="line">super();</span><br><span class="line">this.top = new Stack();</span><br><span class="line">this.base = top;</span><br><span class="line">this.size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int Size() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为空</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top == base ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回栈顶元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object Top() &#123;</span><br><span class="line">return top.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 入栈</span><br><span class="line"> * @param data</span><br><span class="line"> */</span><br><span class="line">public void Push(Object data) &#123;</span><br><span class="line">Stack newStack = new Stack();</span><br><span class="line">newStack.setData(data);</span><br><span class="line">top.setTop(newStack);</span><br><span class="line">top = newStack;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object Pop() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">Object data = top.getData();</span><br><span class="line">size--;</span><br><span class="line">Stack curr = base;</span><br><span class="line">while(curr.getTop() != top) &#123;</span><br><span class="line">curr = curr.getTop();</span><br><span class="line">&#125;</span><br><span class="line">top = curr;</span><br><span class="line">curr.setTop(null);</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LinkedStack ls = new LinkedStack();</span><br><span class="line">ls.Push(1);</span><br><span class="line">ls.Push(2);</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+ls.Size());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">ls.Push(&quot;a&quot;);</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+ls.size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">栈大小：2</span><br><span class="line">出栈：2</span><br><span class="line">出栈：1</span><br><span class="line">出栈：null</span><br><span class="line">出栈：a</span><br><span class="line">栈大小：0</span><br></pre></td></tr></table></figure></p><p>方法二：使用头插法，这样就不需要尾指针（base）</p><h1 id="进制扩展"><a href="#进制扩展" class="headerlink" title="进制扩展"></a>进制扩展</h1><p>二进制：计算机只有高频和低频<br>十进制：人类常用语言<br>八进制：早期计算机系统都是三的倍数，因此较方便<br>十六进制：一个字节=8位，刚好两个十六进制数可以表示完整，节省空间</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>可查看 java.util.Queue接口<br>先进先出(FIFO)，可查看JAVA API,Queue继承了Collection接口<br>队头：删除<br>队尾：插入<br>也就是说，队尾进，队头出<br>分类： 顺序队列，循环队列<br>每种队列都可以用数组和链表实现</p><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.queue;</span><br><span class="line">/**</span><br><span class="line"> * 队列</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class MyQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;T&gt; data = new ArrayList&lt;T&gt;();</span><br><span class="line">private int front;</span><br><span class="line">private int rear;</span><br><span class="line">public MyQueue() &#123;</span><br><span class="line">front = 0;</span><br><span class="line">rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为空</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return front == rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回队列大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int size() &#123;</span><br><span class="line">return rear-front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回队首元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public T getFront() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return data.get(front++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 出队</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public T outQueue() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return getFront();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 入队</span><br><span class="line"> */</span><br><span class="line">public void InQueue(T item) &#123;</span><br><span class="line">data.add(item);</span><br><span class="line">rear++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyQueue&lt;Integer&gt; mq = new MyQueue&lt;Integer&gt;();</span><br><span class="line">mq.InQueue(1);</span><br><span class="line">mq.InQueue(2);</span><br><span class="line">System.out.println(&quot;队头元素：&quot;+mq.outQueue());</span><br><span class="line">System.out.println(&quot;队大小&quot;+mq.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">队头元素：1</span><br><span class="line">队大小2</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">缺点：队列出队后，空间不能再次使用，造成了内存的浪费，因此需要将队列看成是一个环状空间，而循环队列，是需要用循环链表实现的.   </span><br><span class="line"></span><br><span class="line">## 循环队列 ##  </span><br><span class="line">与顺序队列不同的是，不可用front == rear来区分是否队满或队空，需要新建一个布尔变量或者利用公式：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;(rear+1)%n == front</span><br><span class="line"></span><br><span class="line">方法一：</span><br><span class="line">- 设置一个标志位flag，初始化为0</span><br><span class="line">- 入队为1，出队为0</span><br><span class="line">- 队为空：front == rear &amp;&amp; flag == 0</span><br><span class="line">- 队为满：front == rear &amp;&amp; flag == 1    </span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">- 保留一个元素的存储空间</span><br><span class="line">- 队满：(rear+1)%n == front</span><br><span class="line">- 队空：rear == front</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">- 使用一个计数器，计算队中的元素个数</span><br><span class="line">- 队满：count&gt;0 &amp;&amp; front == rear</span><br><span class="line">- 队空：count == 0</span><br><span class="line"></span><br><span class="line">实现（方法二）</span><br></pre></td></tr></table></figure><p>package timejjc.com.queue;<br>/**</p><ul><li>循环队列—需要考虑队满的情况</li><li>@author 梁翠翠<br><em></em>/</li></ul><p>import java.util.ArrayList;</p><p>public class LoopQueue<t> {</t></p><pre><code>private Object[] data;private int rear;private int front;private int maxSize = 10;private static final int INCREAT = 10;//每次增长10空间public LoopQueue(){    this.rear = 0;    this.front = 0;    this.data = new Object[maxSize];}public boolean isEmpty() {    if(rear == front) {        return true;     }    return false;}public boolean isFill() {    if((rear+1)%maxSize == front) {        return true;    }    return false;}/** * 获取队头元素 * @param n */public Object queueFront(Object n ) {    if(isEmpty()) {        return null;    }    return  data[(front+1)%maxSize];}public void enQueue(Object n) {    if(isFill()) {        System.out.println(&quot;Queue is Fill&quot;);    } else {        rear = (rear+1)%maxSize;        data[rear] = n;    }}public Object deQueue(){    if(isEmpty()) {        return null;    }     return queueFront(front);}public static void main(String[] args) {    LoopQueue&lt;Integer&gt; lq = new LoopQueue&lt;Integer&gt;();    lq.enQueue(1);    lq.enQueue(2);    lq.enQueue(3);    lq.enQueue(4);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    System.out.println(lq.deQueue());//1}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>package timejjc.com.queue;<br>/**</p><ul><li>循环队列–集合不需要判断队满，但需要判断是否为空，因为是坟墓</li><li>@author 梁翠翠<br><em></em>/</li></ul><p>import java.util.ArrayList;</p><p>public class LoopQueue<t> {</t></p><pre><code>private ArrayList&lt;T&gt; data = new ArrayList&lt;T&gt;();private int rear;private int front;public LoopQueue(){    this.rear = 0;    this.front = 0;}public boolean isEmpty() {    if(rear == front) {        return true;     }    return false;}/** * 获取队头元素 * @param n */public T queueFront() {    if(isEmpty()) {        return null;    }    T item = data.get(front%data.size());    front = (front+1)%data.size();    return  item;}public void enQueue(T n) {    if(data.size() == 0) {        rear = rear+1;    } else {        rear = (rear+1)%data.size();    }    data.add(n);}public Object deQueue(){    if(isEmpty()) {        return null;    }     return queueFront();}public static void main(String[] args) {    LoopQueue&lt;Integer&gt; lq = new LoopQueue&lt;Integer&gt;();    lq.enQueue(1);    lq.enQueue(2);    lq.enQueue(3);    lq.enQueue(4);    lq.enQueue(5);    lq.enQueue(6);    lq.enQueue(7);    lq.enQueue(8);    lq.enQueue(9);    lq.enQueue(10);    lq.enQueue(11);    lq.enQueue(12);    lq.enQueue(13);    lq.enQueue(14);    System.out.println(lq.deQueue());//1    System.out.println(lq.deQueue());//2    System.out.println(lq.deQueue());//3    System.out.println(lq.deQueue());//4    System.out.println(lq.deQueue());//5    System.out.println(lq.deQueue());//6    System.out.println(lq.deQueue());//7    System.out.println(lq.deQueue());//8}</code></pre><p>}</p><p><code>`</code></p><p>后续更新的话，需要更新链表的实现方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表之循环链表</title>
      <link href="/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="（单）循环链表"><a href="#（单）循环链表" class="headerlink" title="（单）循环链表"></a>（单）循环链表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>最后一个结点的指针域指向头节点，形成一个环<br><a id="more"></a></p><h2 id="约瑟夫-Josephus-环"><a href="#约瑟夫-Josephus-环" class="headerlink" title="约瑟夫(Josephus)环"></a>约瑟夫(Josephus)环</h2><p>&#160;&#160;&#160;&#160;已知n个人（以编号1,2,3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依次规律重复下去，直到圆桌周围的人全部出列，通常我们设置编号0~n-1  </p><p>循环链表解决思路：</p><ul><li>尾节点不指向头节点，找到要出列结点的前一个结点p</li><li>p指向出列结点的下一个结点</li><li>若尾节点指向头节点，此时只剩下一个结点，则直接输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Josphus &#123;</span><br><span class="line"></span><br><span class="line">public static void josphus(LNode head, int m) &#123;</span><br><span class="line">if(head == null) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">System.out.println();</span><br><span class="line">while(tmp.getNext() != tmp) &#123;</span><br><span class="line">for(int i=0;i&lt;m-1;i++) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(tmp.getNext().getData()+&quot; &quot;);</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">&#125;</span><br><span class="line">//最后一个不要忘了输出</span><br><span class="line">System.out.println(tmp.getData());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接两个链表"><a href="#连接两个链表" class="headerlink" title="连接两个链表"></a>连接两个链表</h2><p>题目： 实现将两个线性表（a1,a2,…,an）和（b1,b2,…,bm）连接成一个线性表（a1,…,an,b1,…,bm）的运算<br>更灵活的循环链表：去掉头指针，增加一个尾指针rear<br><img src="/2019/02/02/线性表之循环链表/loopList.PNG" alt="">  </p><p>思路：</p><ul><li>单链表<br>&#160;&#160;&#160;&#160;如果是单链表或头指针表示的单循环表上做这种连接操作，都需要遍历第一个链表，找到结点an，然后将结点b1放到结点an后面，时间复杂度是O（n）  </li><li>循环链表<br>&#160;&#160;&#160;&#160;因为循环链表有尾指针，所以只需要改变尾指针，无需遍历，时间复杂度是O(1)    </li></ul><p><img src="/2019/02/02/线性表之循环链表/loopListDouble。PNG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TwoToOne &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param a 第一个链表的尾指针</span><br><span class="line"> * @param b 第二个链表的尾指针</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static LNode twoOne(LNode a, LNode b) &#123;</span><br><span class="line">LNode tmp = a.getNext();//a的头节点</span><br><span class="line">System.out.println(&quot;aaa&quot;+b.getNext().getNext().getData());</span><br><span class="line">a.setNext(b.getNext().getNext());</span><br><span class="line">b.setNext(tmp);</span><br><span class="line">return tmp;//新链表的头结点位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="判断单链表中是否有环"><a href="#判断单链表中是否有环" class="headerlink" title="判断单链表中是否有环"></a>判断单链表中是否有环</h2><p><strong>所谓有环，不一定是尾节点指向头节点，尾节点可以指向链表中的任意结点</strong><br>方法一：</p><ul><li>使用p,q两个指针，p总是向前走，但q每次都从头开始走</li><li>对于每个结点，看p走的步数是否和q与q一样，不一样代表有环  </li></ul><p>方法二：</p><ul><li>使用p,q两个指针，p每次向前走一步,q每次向前走两步</li><li>若某个时候p == q,则有环  </li></ul><p>我觉得，第一个好理解一点！！！  因为不知道第二种方法的原因</p><h2 id="魔术师发牌问题"><a href="#魔术师发牌问题" class="headerlink" title="魔术师发牌问题"></a>魔术师发牌问题</h2><p>&#160;&#160;&#160;&#160;魔术师利用一副牌中的13张黑牌，预先将他们排好后叠放在一起，牌面朝下。对观众说：“我不看牌，只数数就可以才到每张牌是什么，我大声叔叔，你们听，不信？现场演示。”魔术师将最上面的那张牌数为1，把他翻过来正好是黑桃A，将黑桃A放在桌子上，第二次数1,2..将第一张牌放在这些牌的下面，将第二张牌翻过来，正好是黑桃2，也将他放在桌子上这样一次进行将13张牌全部翻出，准确无误。  </p><p>问题：拍的开始顺序是如何排放的。<br>思路：</p><h2 id="拉丁方阵问题"><a href="#拉丁方阵问题" class="headerlink" title="拉丁方阵问题"></a>拉丁方阵问题</h2><p>&#160;&#160;&#160;&#160;拉丁方阵是一种n x n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列种恰好出现一次。著名数学家和物理学家欧拉使用拉丁字母来作为拉丁方阵里元素的符号。(嗯哼，数独哎)<br>思路：</p><ul><li>第一行打印：1，2,3,…,n</li><li>第二行打印：2,3,…,n,1</li><li>第三行打印：3,…,n,2</li><li>第n行打印：n,1,2,…,n-1</li></ul><h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><p>双向链表：每个数据结点种都有两个指针，分别指向直接后继和直接前驱。<br><img src="/2019/02/02/线性表之循环链表/doubleList.PNG" alt="">    </p><p>双向循环链表：<br><img src="/2019/02/02/线性表之循环链表/doubleLoopList.PNG" alt="">  </p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="/2019/02/02/线性表之循环链表/insertDouble.PNG" alt="">  </p><ul><li>s指向p的next</li><li>s的前驱指向p的前驱</li><li>p指向s的前驱的next</li><li>p指向s的前驱 </li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="/2019/02/02/线性表之循环链表/doubleDelete.PNG" alt="">  </p><p>后续再更代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表(2)</title>
      <link href="/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8-2/"/>
      <url>/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8-2/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;创建单链表的过程是一个动态生成链表的过程，从“空表”的初始状态起，依次遍历各元素结点并逐个插入链表。<br><a id="more"></a><br>思路：  </p><ul><li>声明一个结点p和计数器变量i；</li><li>初始化一空链表L；</li><li>让L的头节点的指针指向NULL，即建立一个带头节点的单链表；</li><li>循环实现后继结点的赋值和插入。  <h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2>始终把新加进的元素放在表头后的第一个位置：  </li><li>新节点的next指向头节点后面；</li><li>表头的next指向新节点。  </li></ul><p>生成的链表中结点的次序和输入的顺序是相反的！ </p><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>始终把新元素放在表尾：</p><ul><li>当前节点指向新节点</li><li>新节点成为当前结点</li><li>三个结点，head,新节点(newNode)，当前结点（cur）  <h1 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h1>从内存中释放<br>思路：</li><li>声明结点p,q</li><li>将第一个结点赋值给p,下一结点赋值给q</li><li>循环执行释放p和将q赋值给p的操作<br>JAVA中，GC释放  </li></ul><h1 id="比较单链表，顺序表"><a href="#比较单链表，顺序表" class="headerlink" title="比较单链表，顺序表"></a>比较单链表，顺序表</h1><p><img src="/2019/02/02/线性表-2/compare.PNG" alt="">  </p><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>用数组描述的链表 </p><ul><li>包括数据域和游标</li><li>数组的第一个和最后一个元素做特殊处理，data域不存数据</li><li>未使用的数组元素成为备用链表</li><li>数组的第一个元素，即下标为0的哪个元素的游标存放备用链表的第一个结点的下标</li><li>数组的最后一个元素，即下标为MAXSIZE-1的游标存放第一个由数值的元素的下标，相当于头节点  </li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>静态链表是为了给没有指针的变编程语言设计的一种实现单链表功能的方法。</p><p>嘿嘿嘿，不太懂啊</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>题目：快速找到未知长度单链表的中间结点</p><p><strong>方法一</strong></p><ul><li>遍历单链表确定链表长度</li><li>再次从头节点出发循环L/2次找到单链表的中间结点 </li><li>复杂度O(L+L/2) = O(3L/2)     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode minBase(LNode head) &#123;</span><br><span class="line">int size = 0;</span><br><span class="line">LNode p = head;</span><br><span class="line">while(p.getNext() != null) &#123;</span><br><span class="line">p = p.getNext();</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0; i&lt;size/2; i++) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法二</strong><br>快慢指针  </p><ul><li>设置两个指针 search,mid都指向单链表的头节点，其中search的移动速度是mid的2倍，当search指向末尾结点的时候，min正好就在中间了，即标尺的思想。  </li><li>算法复杂度O(L/2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode midD(LNode head) &#123;</span><br><span class="line">LNode search = head;</span><br><span class="line">LNode mid = head;</span><br><span class="line">while(search.getNext() != null) &#123;</span><br><span class="line">if(search.getNext().getNext() != null) &#123;</span><br><span class="line">search = search.getNext().getNext();</span><br><span class="line">mid = mid.getNext();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">search = search.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>题目:写一个完整的程序，实现随机生成20个元素的链表，查找中间节点的值并显示<br>这里展示的代码只是随机生成20个元素的链表，再结合前面的代码就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestMain &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode();</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line">LNode tmp = new LNode(new Random().nextInt(100)+1);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表（List）之增删改查</title>
      <link href="/2019/02/01/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2019/02/01/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;由0或多个数据元素组成的有限个序列，为0时，是空表<br><a id="more"></a></p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>&#160;&#160;&#160;&#160;第一个元素无前驱，最后一个元素无后继，其他元素都<strong><em>有且只有</em></strong>一个前驱和后继。线性关系是不允许有第三者的！！！   </p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>&#160;&#160;&#160;&#160;一组性质相同的值的集合及定义在此集合上的一些操作的总称<br>&#160;&#160;&#160;&#160;JAVA中数据类型分为两种：  </p><ul><li><p>基本数据（原子）类型：不可再分<br><img src="/2019/02/01/线性表/type_base.png" alt="">  </p></li><li><p>引用数据类型<br>&#160;&#160;&#160;&#160;类、接口、数组<br>&#160;&#160;&#160;&#160;很重要！！！，否则无法理解“指针”操作</p></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li>求元素个数</li><li>插入</li><li>删除</li><li>查找</li><li>判断是否为空  </li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>&#160;&#160;&#160;&#160;顺序存储和链表存储  </p><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>&#160;&#160;&#160;&#160;栈内存是顺序结构的<br>&#160;&#160;&#160;&#160;用一段地址连续的存储单元依次存储线性表的数据元素<br>需要封装的属性（3）：</p><ul><li>起始位置</li><li>最大存储容量</li><li>当前长度<br><strong><em><font color="red">注意：线性表的首地址为：1</font></em></strong>    </li></ul><p>时间复杂度</p><ol><li>删除/插入<br>最好情况：不移动元素&#160;O(1)<br>最坏情况:移动n个元素&#160;O(n)<br>平均情况:O((n-1)/2),&#160;即&#160;O(n)   </li></ol><p>&#160;&#160;2.存、取<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;都为&#160;O(1)  </p><p>优点  </p><ol><li>不需要为表中元素之间的逻辑关系增加额外的存储空间 </li><li>快速存取表中任意位置的元素……谁让人家是顺序的呢，嘿嘿嘿  </li></ol><p>缺点  </p><ol><li>插入和删除太慢了，除非数据特别少，否则不要用啊！！！</li><li>若线性表的长度变化较大（大量的插入和删除） ，无法确定存储空格键的容量啊</li><li>存储空间碎片化，毕竟人家存储空间的分配是一整块来着的呀，当一大块空间剩下一小块时，而这一小块空间又不够我们用的，那就只能浪费掉，然后再次申请一大块空间，两个大块之间的小块就属于“碎片”啦  </li></ol><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>位置是随意的哦，但是要求存元素本身及其后继指针  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据域<br>存储数据元素信息的域  </li><li>指针域<br>存储后继位置的域  </li><li>指针<br>指针域中存储的信息  </li><li>结点(存储映像)<br>数据域 + 指针域    <h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><img src="/2019/02/01/线性表/LNode.png" alt="">  </li></ul><h4 id="头指针-头节点-首元节点"><a href="#头指针-头节点-首元节点" class="headerlink" title="头指针/头节点/首元节点"></a>头指针/头节点/首元节点</h4><ul><li>头指针<br>指链表指向的第一个结点的指针，若链表有头结点，则是指向头结点的指针。<br>单链表可由一个头指针唯一确定（标识）</li><li>元首结点<br>指链表中存储第一个元素的结点</li><li>头结点<br>在链表的首元结点之前附设的一个节点，数据域内存放的是空表标志和表长等信息<br><img src="/2019/02/01/线性表/node.png" alt="">  </li></ul><p>&#160;&#160;&#160;&#160;<strong> 无论链表是否为空，头指针均不为 </strong>，人家是唯一标识啊😏     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><ul><li>获得链表第i个数据<br>&#160;1. 声明一个结点p指向链表第一个结点，初始化&#160;j&#160;从1开始<br>&#160;2. 当j&lt;i时，遍历链表，p指针后移，j++;<br>&#160;3. 若循环到末尾p为空，则不存在第i个元素<br>&#160;4. 否则查找成功，返回结点p的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GetIData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode IData(LNode head,int i) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">while(head != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否遍历完整个链表</span><br><span class="line">if(head == null || j&lt;i)</span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160;&#160;&#160;&#160;单链表的循环，建议使用while,因为并不知道单链表的长度</p><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><ul><li>在第i个数据插入结点<br>&#160;1. 新节点指向当前结点的后继<br>&#160;2. 当前结点指向新节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsertData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode insert(LNode head, int i, int newData) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">while (tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">//new一个空结点p</span><br><span class="line">LNode p = new LNode(0);</span><br><span class="line">&lt;font color=red&gt;p.setData(newData);&lt;/font&gt;</span><br><span class="line">//p指向head后继:p.next = head.next</span><br><span class="line">p.setNext(tmp.getNext());</span><br><span class="line">//head指向p:head.next = p;</span><br><span class="line">tmp.setNext(p);</span><br><span class="line">return head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的时head.getNext()是因为，在定义head时，为：</p><blockquote><p>LNode head = new LNode(0);<br>这时head是有头节点的   </p></blockquote><p><img src="/2019/02/01/线性表/head.png" alt="">  </p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>&#160;1. 找到要删除结点的前驱结点（j=1开始）<br>&#160;2. 前驱结点直接指向要删除结点的后继结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DeleteNode &#123;</span><br><span class="line"></span><br><span class="line">public static LNode deleteINode(LNode node, int i) &#123;</span><br><span class="line">int j = 1;</span><br><span class="line">LNode tmp = node;</span><br><span class="line">while(tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">return node.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度与空间复杂度</title>
      <link href="/2019/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2019/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>分类：时间复杂度&#160;和&#160;空间复杂度<br>指在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和空间资源。<br><a id="more"></a><br>方法：</p><ul><li>事前分析估算法（渐进复杂度)<br>&#160;常用的算法，依据统计方法对算法进行估算</li><li>事后统计法<br>&#160;&#160;&#160;&#160;通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。<br>&#160;&#160;&#160;&#160;但是需要花费大量的时间和经历，若测试发现算法不可取，则损失重大。   </li></ul><p>算法效率的度量因素：  </p><ol><li>算法采用的策略、方案</li><li>编译产生的代码质量</li><li>问题的输入规模（输入量）</li><li>及其执行指令的速度<br>&#160;<strong><em>一个程序的运行时间依赖于算法的好坏和问题的输入规模。</em></strong>   </li></ol><p>函数的渐近增长：<br>判断一个算法的效率时，函数中的尝试和其他次要项可忽略，关注的应该是最高项的阶数。 </p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>官方定义：</strong><br>&#160;&#160;&#160;&#160;在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。<br>&#160;&#160;&#160;&#160;算法的时间复杂度，也就是算法的时间量度，记作：<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T(n) = O(f(n))<br>&#160;&#160;表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>，其中f(n)是问题规模n的某个函数<br>比较：<br><img src="/2019/02/01/时间复杂度与空间复杂度/timeComplexity.png" alt="">   </p><p>时间复杂度所消耗的时间从小到大依次为:<br>O(1) &lt; O(lon(n)) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)    </p><h3 id="最坏情况和平均情况"><a href="#最坏情况和平均情况" class="headerlink" title="最坏情况和平均情况"></a>最坏情况和平均情况</h3><ul><li>最坏运行时间<br>&#160;&#160;&#160;&#160;一个算法有最好的情况和最坏的情况。在应用中，这是一个最重要的需求，除了特别指定，我们所提到的运行时间都是最坏情况的运行时间。  </li><li>平均运行时间<br>&#160;&#160;&#160;&#160;期望的运行时间     <h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2>通过计算算法所需要的存储空间实现的，计算公式为:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S(n) = O(f(n));<br>&#160;&#160;&#160;&#160;其中f(n)是关于问题规模n所占存储空间的函数。<br>是对一个算法在运行过程中临时占用存储空间大小的度量</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之链表逆序</title>
      <link href="/2019/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F/"/>
      <url>/2019/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>有一链表，链表数据为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 </li><li>使其逆序，数据为：7 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1  </li></ul><a id="more"></a><h3 id="解决方法（3种）"><a href="#解决方法（3种）" class="headerlink" title="解决方法（3种）"></a>解决方法（3种）</h3><h5 id="1-就地逆序"><a href="#1-就地逆序" class="headerlink" title="1.就地逆序"></a>1.就地逆序</h5><ul><li>新增一节点的指针域，用于存储当前节点的后继节点 </li><li>需要当前节点，前驱节点</li><li>遍历链表，直到最后一个节点  </li></ul><p><strong>节点类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表节点类</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <strong>测试类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基础的链表反转</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Reverse &#123;</span><br><span class="line">/**</span><br><span class="line"> * 直接反转节点指向</span><br><span class="line"> * @param head 头节点</span><br><span class="line"> * @return 逆序后的链表</span><br><span class="line"> */</span><br><span class="line">public static LNode Reverse_base(LNode head) &#123;</span><br><span class="line">//没有节点或只有一个节点则直接返回</span><br><span class="line">if(head == null || head.getNext() == null)</span><br><span class="line">return head;</span><br><span class="line">//前驱节点</span><br><span class="line">LNode pre = null;</span><br><span class="line">//下一节点</span><br><span class="line">LNode next = null;</span><br><span class="line">//当前节点</span><br><span class="line">LNode cur = head;</span><br><span class="line">//循环链表</span><br><span class="line">while(cur != null) &#123;</span><br><span class="line">//next存储当前节点的后继节点，以免丢失</span><br><span class="line">next = cur.getNext();</span><br><span class="line">//当前节点指向下一节点</span><br><span class="line">cur.setNext(pre);</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">return pre;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode(0);</span><br><span class="line">//LNode tail = new LNode(0);</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=1; i&lt;8; i++) &#123;</span><br><span class="line">LNode tmp = new LNode(i);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">LNode lNode = Reverse_base(head);</span><br><span class="line">System.out.println(&quot;逆序链表&quot;);</span><br><span class="line">while(lNode.getNext() != null) &#123;</span><br><span class="line">System.out.print(lNode.getData()+&quot; &quot;);</span><br><span class="line">lNode = lNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是所有的代码<br>在逆序前，存值到链表中：<br><img src="/2019/01/30/数据结构与算法之逆序/variables_head.png" alt="">  </p><p>逆序后，链表pre   </p><p><img src="/2019/01/30/数据结构与算法之逆序/variables_pre.png" alt="">   </p><p>由于第一次使用Markdown pad2  之后会不断优化<br>解法有3种，后续会更新</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/24/hello-world/"/>
      <url>/2019/01/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
