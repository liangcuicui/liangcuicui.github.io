<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性表之循环链表</title>
      <link href="/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="（单）循环链表"><a href="#（单）循环链表" class="headerlink" title="（单）循环链表"></a>（单）循环链表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>最后一个结点的指针域指向头节点，形成一个环  </p><h2 id="约瑟夫-Josephus-环"><a href="#约瑟夫-Josephus-环" class="headerlink" title="约瑟夫(Josephus)环"></a>约瑟夫(Josephus)环</h2><p>&#160;&#160;&#160;&#160;已知n个人（以编号1,2,3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依次规律重复下去，知道圆桌周围的人全部出列，通常我们设置编号0~n-1  </p><p>循环链表解决思路：</p><ul><li>尾节点不指向头节点，找到要出列结点的前一个结点p</li><li>p指向出列结点的下一个结点</li><li>若尾节点指向头节点，此时只剩下一个结点，则直接输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Josphus &#123;</span><br><span class="line"></span><br><span class="line">public static void josphus(LNode head, int m) &#123;</span><br><span class="line">if(head == null) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">System.out.println();</span><br><span class="line">while(tmp.getNext() != tmp) &#123;</span><br><span class="line">for(int i=0;i&lt;m-1;i++) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(tmp.getNext().getData()+&quot; &quot;);</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">&#125;</span><br><span class="line">//最后一个不要忘了输出</span><br><span class="line">System.out.println(tmp.getData());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接两个链表"><a href="#连接两个链表" class="headerlink" title="连接两个链表"></a>连接两个链表</h2><p>题目： 实现将两个线性表（a1,a2,…,an）和（b1,b2,…,bm）连接成一个线性表（a1,…,an,b1,…,bm）的运算<br>更灵活的循环链表：去掉头指针，增加一个尾指针rear<br><img src="/2019/02/02/线性表之循环链表/loopList.PNG" alt="">  </p><p>思路：</p><ul><li>单链表<br>&#160;&#160;&#160;&#160;如果是单链表或头指针表示的单循环表上做这种连接操作，都需要遍历第一个链表，找到结点an，然后将结点b1放到结点an后面，时间复杂度是O（n）  </li><li>循环链表<br>&#160;&#160;&#160;&#160;因为循环链表有尾指针，所以只需要改变尾指针，无需遍历，时间复杂度是O(1)    </li></ul><p><img src="/2019/02/02/线性表之循环链表/loopListDouble。PNG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TwoToOne &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param a 第一个链表的尾指针</span><br><span class="line"> * @param b 第二个链表的尾指针</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static LNode twoOne(LNode a, LNode b) &#123;</span><br><span class="line">LNode tmp = a.getNext();//a的头节点</span><br><span class="line">System.out.println(&quot;aaa&quot;+b.getNext().getNext().getData());</span><br><span class="line">a.setNext(b.getNext().getNext());</span><br><span class="line">b.setNext(tmp);</span><br><span class="line">return tmp;//新链表的头结点位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="判断单链表中是否有环"><a href="#判断单链表中是否有环" class="headerlink" title="判断单链表中是否有环"></a>判断单链表中是否有环</h2><p><strong>所谓有环，不一定是尾节点指向头节点，尾节点可以指向链表中的任意结点</strong><br>方法一：</p><ul><li>使用p,q两个指针，p总是向前走，单q每次都从头开始走</li><li>对于每个结点，看p走的步数是否和q与q一样，不一样代表有环  </li></ul><p>方法二：</p><ul><li>使用p,q两个指针，p每次向前走一步,q每次向前走两步</li><li>若某个时候p == q,则有环  </li></ul><p>我觉得，第一个好理解一点！！！  因为不知道第二种方法的原因</p><h2 id="魔术师发牌问题"><a href="#魔术师发牌问题" class="headerlink" title="魔术师发牌问题"></a>魔术师发牌问题</h2><p>&#160;&#160;&#160;&#160;魔术师利用一副牌中的13张黑牌，预先将他们排好后叠放在一起，牌面朝下。对观众说：“我不看牌，只数数就可以才到每张牌是什么，我大声叔叔，你们听，不信？现场演示。”魔术师将最上面的那张牌数为1，把他翻过来正好是黑桃A，将黑桃A放在桌子上，第二次数1,2..将第一张牌放在这些牌的下面，将第二张牌翻过来，正好是黑桃2，也将他放在桌子上这样一次进行将13张牌全部翻出，准确无误。  </p><p>问题：拍的开始顺序是如何排放的。<br>思路：</p><h2 id="拉丁方阵问题"><a href="#拉丁方阵问题" class="headerlink" title="拉丁方阵问题"></a>拉丁方阵问题</h2><p>&#160;&#160;&#160;&#160;拉丁方阵是一种n x n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列种恰好出现一次。著名数学家和物理学家欧拉使用拉丁字母来作为拉丁方阵里元素的符号。(嗯哼，数独哎)<br>思路：</p><ul><li>第一行打印：1，2,3,…,n</li><li>第二行打印：2,3,…,n,1</li><li>第三行打印：3,…,n,2</li><li>第n行打印：n,1,2,…,n-1</li></ul><h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><p>双向链表：每个数据结点种都有两个指针，分别指向直接后继和直接前驱。<br><img src="/2019/02/02/线性表之循环链表/doubleList.PNG" alt="">    </p><p>双向循环链表：<br><img src="/2019/02/02/线性表之循环链表/doubleLoopList.PNG" alt="">  </p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="/2019/02/02/线性表之循环链表/insertDouble.PNG" alt="">  </p><ul><li>s指向p的next</li><li>s的前驱指向p的前驱</li><li>p指向s的前驱的next</li><li>p指向s的前驱 </li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="/2019/02/02/线性表之循环链表/doubleDelete.PNG" alt="">  </p><p>后续再更代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表(2)</title>
      <link href="/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8-2/"/>
      <url>/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8-2/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;创建单链表的过程是一个动态生成链表的过程，从“空表”的初始状态起，一次简历各元素结点并逐个插入链表。<br><a id="more"></a><br>思路：  </p><ul><li>声明一个结点p和计数器变量i；</li><li>初始化一空链表L；</li><li>让L的头节点的指针指向NULL，即建立一个带头节点的单链表；</li><li>循环实现后继结点的赋值和插入。  <h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2>始终把新加进的元素放在表头后的第一个位置：  </li><li>新节点的next指向头节点后面；</li><li>表头的next指向新节点。  </li></ul><p>生成的链表中结点的次序和输入的顺序是想法的！ </p><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>始终把新元素放在表尾：</p><ul><li>当前节点指向新节点</li><li>新节点成为当前结点</li><li>三个结点，head,新节点(newNode)，当前结点（cur）  <h1 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h1>从内存中释放<br>思路：</li><li>声明结点p,q</li><li>大奖第一个结点赋值给p,下一结点赋值给q</li><li>循环执行释放p和将q赋值给p的操作<br>JAVA中，GC释放  </li></ul><h1 id="比较单链表，顺序表"><a href="#比较单链表，顺序表" class="headerlink" title="比较单链表，顺序表"></a>比较单链表，顺序表</h1><p><img src="/2019/02/02/线性表-2/compare.PNG" alt="">  </p><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>用数组描述的链表 </p><ul><li>包括数据域和游标</li><li>数组的第一个和最后一个元素做特殊处理，data域不存数据</li><li>未使用的数组元素成为备用链表</li><li>数组的第一个元素，即下标为0的哪个元素的游标存放备用链表的第一个结点的下标</li><li>数组的最后一个元素，即下标为MAXSIZE-1的游标存放第一个由数值的元素的下标，相当于头节点  </li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>静态链表是为了给没有指针的变编程语言设计的一种实现单链表功能的方法。</p><p>嘿嘿嘿，不太懂啊</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>题目：快速找到未知长度单链表的中间结点</p><p><strong>方法一</strong></p><ul><li>遍历单链表确定链表长度</li><li>再次从头节点出发循环L/2次找到单链表的中间结点 </li><li>复杂度O(L+L/2) = O(3L/2)     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode minBase(LNode head) &#123;</span><br><span class="line">int size = 0;</span><br><span class="line">LNode p = head;</span><br><span class="line">while(p.getNext() != null) &#123;</span><br><span class="line">p = p.getNext();</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0; i&lt;size/2; i++) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法二</strong><br>快慢指针  </p><ul><li>设置两个指针 search,mid都指向单链表的头节点，其中search的移动速度是mid的2倍，当search指向末尾结点的时候，min正好就在中间了，即标尺的思想。  </li><li>算法复杂度O(L/2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode midD(LNode head) &#123;</span><br><span class="line">LNode search = head;</span><br><span class="line">LNode mid = head;</span><br><span class="line">while(search.getNext() != null) &#123;</span><br><span class="line">if(search.getNext().getNext() != null) &#123;</span><br><span class="line">search = search.getNext().getNext();</span><br><span class="line">mid = mid.getNext();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">search = search.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>题目:写一个完整的程序，实现随机生成20个元素的链表，查找重点节点的值并显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestMain &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode();</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line">LNode tmp = new LNode(new Random().nextInt(100)+1);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表（List）之增删改查</title>
      <link href="/2019/02/01/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2019/02/01/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;由0或多个数据元素组成的有限个序列，为0时，是空表<br><a id="more"></a></p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>&#160;&#160;&#160;&#160;第一个元素无前驱，最后一个元素无后继，其他元素都<strong><em>有且只有</em></strong>一个前驱和后继。线性关系是不允许有第三者的！！！   </p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>&#160;&#160;&#160;&#160;一组性质相同的值的集合及定义在此集合上的一些操作的总称<br>&#160;&#160;&#160;&#160;JAVA中数据类型分为两种：  </p><ul><li><p>基本数据（原子）类型：不可再分<br><img src="/2019/02/01/线性表/type_base.png" alt="">  </p></li><li><p>引用数据类型<br>&#160;&#160;&#160;&#160;类、接口、数组<br>&#160;&#160;&#160;&#160;很重要！！！，否则无法理解“指针”操作</p></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li>求元素个数</li><li>插入</li><li>删除</li><li>查找</li><li>判断是否为空  </li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>&#160;&#160;&#160;&#160;顺序存储和链表存储  </p><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>&#160;&#160;&#160;&#160;栈内存是顺序结构的<br>&#160;&#160;&#160;&#160;用一段地址连续的存储单元依次存储线性表的数据元素<br>需要封装的属性（3）：</p><ul><li>起始位置</li><li>最大存储容量</li><li>当前长度<br><strong><em><font color="red">注意：线性表的首地址为：1</font></em></strong>    </li></ul><p>时间复杂度</p><ol><li>删除/插入<br>最好情况：不移动元素&#160;O(1)<br>最坏情况:移动n个元素&#160;O(n)<br>平均情况:O((n-1)/2),&#160;即&#160;O(n)   </li></ol><p>&#160;&#160;2.存、取<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;都为&#160;O(1)  </p><p>优点  </p><ol><li>不需要为博爱中元素之间的逻辑关系增加额外的存储空间 </li><li>快速存取表中任意位置的元素……虽让人家是顺序的呢，嘿嘿嘿  </li></ol><p>缺点  </p><ol><li>插入和删除太慢了，除非数据特别少，否则不要用啊！！！</li><li>若线性表的长度变化较大（大量的插入和删除） ，无法确定存储空格键的容量啊</li><li>存储空间碎片化，毕竟人家存储空间的分配是一整块来着的呀，当一大块空间剩下一小块时，而这一小块空间又不够我们用的，那就只能浪费掉，然后再次申请一大块空间，两个大块之间的小块就属于“碎片”啦  </li></ol><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>位置是随意的哦，但是要求存元素本身及其后继指针  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据域<br>存储数据元素信息的域  </li><li>指针域<br>存储后继位置的域  </li><li>指针<br>指针域中存储的信息  </li><li>结点(存储映像)<br>数据域 + 指针域    <h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><img src="/2019/02/01/线性表/LNode.png" alt="">  </li></ul><h4 id="头指针-头节点-首元节点"><a href="#头指针-头节点-首元节点" class="headerlink" title="头指针/头节点/首元节点"></a>头指针/头节点/首元节点</h4><ul><li>头指针<br>指链表指向的第一个结点的指针，若链表有头检点，则是指向头结点的指针。<br>单链表可由一个头指针唯一确定（标识）</li><li>元首结点<br>指链表中存储第一个元素的结点</li><li>头结点<br>在链表的首元结点之前附设的一个节点，数据域内存放的是空表标志和表长等信息<br><img src="/2019/02/01/线性表/node.png" alt="">  </li></ul><p>&#160;&#160;&#160;&#160;<strong> 无论链表是否为空，头指针均不为 </strong>，人家是唯一标识啊😏     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><ul><li>获得链表第i个数据<br>&#160;1. 声明一个结点p指向链表第一个结点，初始化&#160;j&#160;从1开始<br>&#160;2. 当j&lt;i时，遍历链表，p指针后移，j++;<br>&#160;3. 若循环到末尾p为空，则不存在第i个元素<br>&#160;4. 否则查找成功，返回结点p的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GetIData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode IData(LNode head,int i) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">while(head != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否遍历完整个链表</span><br><span class="line">if(head == null || j&lt;i)</span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160;&#160;&#160;&#160;单链表的循环，建议使用while,因为并不知道单链表的长度</p><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><ul><li>在第i个数据插入结点<br>&#160;1. 新节点指向当前结点的后继<br>&#160;2. 当前结点指向新节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsertData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode insert(LNode head, int i, int newData) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">while (tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">//new一个空结点p</span><br><span class="line">LNode p = new LNode(0);</span><br><span class="line">&lt;font color=red&gt;p.setData(newData);&lt;/font&gt;</span><br><span class="line">//p指向head后继:p.next = head.next</span><br><span class="line">p.setNext(tmp.getNext());</span><br><span class="line">//head指向p:head.next = p;</span><br><span class="line">tmp.setNext(p);</span><br><span class="line">return head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的时head.getNext()是因为，在定义head时，为：</p><blockquote><p>LNode head = new LNode(0);<br>这时head是有头节点的   </p></blockquote><p><img src="/2019/02/01/线性表/head.png" alt="">  </p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>&#160;1. 找到要删除结点的前驱结点（j=1开始）<br>&#160;2. 前驱结点直接指向要删除结点的后继结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DeleteNode &#123;</span><br><span class="line"></span><br><span class="line">public static LNode deleteINode(LNode node, int i) &#123;</span><br><span class="line">int j = 1;</span><br><span class="line">LNode tmp = node;</span><br><span class="line">while(tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">return node.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度与空间复杂度</title>
      <link href="/2019/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2019/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>分类：时间复杂度&#160;和&#160;空间复杂度<br>指在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和空间资源。<br><a id="more"></a><br>方法：</p><ul><li>事前分析估算法（渐进复杂度)<br>&#160;常用的算法，依据统计方法对算法进行估算</li><li>事后统计法<br>&#160;&#160;&#160;&#160;通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。<br>&#160;&#160;&#160;&#160;但是需要花费大量的时间和经历，若测试发现算法不可取，则损失重大。   </li></ul><p>算法效率的度量因素：  </p><ol><li>算法采用的策略、方案</li><li>编译产生的代码质量</li><li>问题的输入规模（输入量）</li><li>及其执行指令的速度<br>&#160;<strong><em>一个程序的运行时间依赖于算法的好坏和问题的输入规模。</em></strong>   </li></ol><p>函数的渐近增长：<br>判断一个算法的效率时，函数中的尝试和其他次要项可忽略，关注的应该是最高想的阶数。 </p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>官方定义：</strong><br>&#160;&#160;&#160;&#160;在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。<br>&#160;&#160;&#160;&#160;算法的时间复杂度，也就是算法的时间量度，记作：<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T(n) = O(f(n))<br>&#160;&#160;表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>，其中f(n)是问题规模n的某个函数<br>比较：<br><img src="/2019/02/01/时间复杂度与空间复杂度/timeComplexity.png" alt="">   </p><p>时间复杂度所消耗的时间从小到大依次为:<br>O(1) &lt; O(lon(n)) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)    </p><h3 id="最坏情况和平均情况"><a href="#最坏情况和平均情况" class="headerlink" title="最坏情况和平均情况"></a>最坏情况和平均情况</h3><ul><li>最坏运行时间<br>&#160;&#160;&#160;&#160;一个算法有最好的情况和最坏的情况。在应用中，这是一个最中药的需求，除了特别指定，我们所提到的运行时间都是最坏情况的运行时间。  </li><li>平均运行时间<br>&#160;&#160;&#160;&#160;期望的运行时间     <h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2>通过计算算法所需要的存储空间实现的，计算公式为:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S(n) = O(f(n));<br>&#160;&#160;&#160;&#160;其中f(n)是关于问题规模n所占存储空间的函数。<br>是对一个算法在运行过程中临时占用存储空间大小的度量</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F/"/>
      <url>/2019/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 算法之链表逆序<br>date: 2019-01-30 09:46:38<br>tags: </p><ul><li>数据结构</li><li>算法</li></ul><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>有一链表，链表数据为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 </li><li>使其逆序，数据为：7 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1  </li></ul><a id="more"></a><h3 id="解决方法（3种）"><a href="#解决方法（3种）" class="headerlink" title="解决方法（3种）"></a>解决方法（3种）</h3><h5 id="1-就地逆序"><a href="#1-就地逆序" class="headerlink" title="1.就地逆序"></a>1.就地逆序</h5><ul><li>新增一节点的指针域，用于存储当前节点的后继节点 </li><li>需要当前节点，前驱节点</li><li>遍历链表，直到最后一个节点  </li></ul><p><strong>节点类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表节点类</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <strong>测试类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基础的链表反转</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Reverse &#123;</span><br><span class="line">/**</span><br><span class="line"> * 直接反转节点指向</span><br><span class="line"> * @param head 头节点</span><br><span class="line"> * @return 逆序后的链表</span><br><span class="line"> */</span><br><span class="line">public static LNode Reverse_base(LNode head) &#123;</span><br><span class="line">//没有节点或只有一个节点则直接返回</span><br><span class="line">if(head == null || head.getNext() == null)</span><br><span class="line">return head;</span><br><span class="line">//前驱节点</span><br><span class="line">LNode pre = null;</span><br><span class="line">//下一节点</span><br><span class="line">LNode next = null;</span><br><span class="line">//当前节点</span><br><span class="line">LNode cur = head;</span><br><span class="line">//循环链表</span><br><span class="line">while(cur != null) &#123;</span><br><span class="line">//next存储当前节点的后继节点，以免丢失</span><br><span class="line">next = cur.getNext();</span><br><span class="line">//当前节点指向下一节点</span><br><span class="line">cur.setNext(pre);</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">return pre;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode(0);</span><br><span class="line">//LNode tail = new LNode(0);</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=1; i&lt;8; i++) &#123;</span><br><span class="line">LNode tmp = new LNode(i);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">LNode lNode = Reverse_base(head);</span><br><span class="line">System.out.println(&quot;逆序链表&quot;);</span><br><span class="line">while(lNode.getNext() != null) &#123;</span><br><span class="line">System.out.print(lNode.getData()+&quot; &quot;);</span><br><span class="line">lNode = lNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是所有的代码<br>在逆序前，存值到链表中：<br><img src="/2019/01/30/数据结构与算法之逆序/variables_head.png" alt="">  </p><p>逆序后，链表pre   </p><p><img src="/2019/01/30/数据结构与算法之逆序/variables_pre.png" alt="">   </p><p>由于第一次使用Markdown pad2  之后会不断优化<br>解法有3种，后续会更新</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/24/hello-world/"/>
      <url>/2019/01/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
