<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图的遍历</title>
      <link href="/2019/02/26/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2019/02/26/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码习题</title>
      <link href="/2019/02/21/%E4%BB%A3%E7%A0%81%E4%B9%A0%E9%A2%98/"/>
      <url>/2019/02/21/%E4%BB%A3%E7%A0%81%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-对链表进行重新排序"><a href="#1-对链表进行重新排序" class="headerlink" title="1.对链表进行重新排序"></a>1.对链表进行重新排序</h1><p>题目：给定链表 L0-L1-L2-…-Ln-1-Ln,把链表重新排序为L0-Ln-L1-Ln-1-L2-Ln-2-…<br>要求：  </p><ul><li>再原来链表的基础上进行排序，即不能申请新的结点</li><li>只能修改结点的next域，不能修改数据域。</li></ul><p>思路：</p><ul><li>找到链表的中间结点(暴力法或者快慢指针法)</li><li>将链表分成两个来链表</li><li>逆序后面的链表</li><li>依次循环，每次各去除两个链表的一个结点，直至next为空</li></ul><h1 id="2-求两个字符串的最长公共子串"><a href="#2-求两个字符串的最长公共子串" class="headerlink" title="2.求两个字符串的最长公共子串"></a>2.求两个字符串的最长公共子串</h1><ol><li>暴力求解<br>利用动态规划法，双重for循环。</li></ol><ul><li>初始化二维数组max[][]，赋值为0</li><li>双重循环两个字符串，如果字符串在某一位置相等,赋值max+1，</li><li>两个变量，max记录最长公共子串的长度，maxI记录最长公共子串最后一个字符的位置</li><li>最长公共子串的位置是从下标maxI-max开始，下标增加max位的字符</li><li>需要注意的是，比较的时候对max数组的赋值，因为循环是从1开始的</li></ul><p><img src="/2019/02/21/代码习题/maxSubStr.PNG" alt="">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str1 = &quot;GCCCTAGCG&quot;;</span><br><span class="line">String str2 = &quot;GCGCAATG&quot;;</span><br><span class="line">getMaxSubStr(str1, str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getMaxSubStr(String str1, String str2) &#123;</span><br><span class="line">if(str1 == null || str2 == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int[][] m = new int[str1.length()+1][str2.length()+1];</span><br><span class="line">int max = 0;//最长公共子序列的长度</span><br><span class="line">int maxI = 0;//最长公共子序列的最后一个字符的位置</span><br><span class="line">for(int i=0;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">m[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=1;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">if(str1.charAt(i-1) == str2.charAt(j-1)) &#123;</span><br><span class="line">m[i][j] = m[i-1][j-1]+1;</span><br><span class="line">if(max&lt;m[i][j]) &#123;</span><br><span class="line">max = m[i][j];</span><br><span class="line">maxI = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str1.substring(maxI-max, maxI));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>滑动比较法</li></ol><ul><li>保持str1的位置不变，移动str2,比较重叠字符的公共子串</li><li>移动时，如果当前重叠子串的长度大于maxI,更新maxI<h1 id="3-求字符串的所有排序（未去重）"><a href="#3-求字符串的所有排序（未去重）" class="headerlink" title="3.求字符串的所有排序（未去重）"></a>3.求字符串的所有排序（未去重）</h1></li><li>第一步，第一个字符和后面所有字符，依次交换</li><li>第二步，固定第一个字符，对剩余的字符进行全排列（交换）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void swap(char[] str, int start, int i) &#123;</span><br><span class="line">char tmp = str[start];</span><br><span class="line">str[start] = str[i];</span><br><span class="line">str[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">public static void Permutation(char[] str, int start) &#123;</span><br><span class="line">if(str.length == 0 || start&lt;0) &#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(start == str.length-1) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for(int i = start;i&lt;str.length;i++) &#123;</span><br><span class="line">swap(str,start,i);</span><br><span class="line">Permutation(str, start+1);</span><br><span class="line">swap(str,i,start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String string = &quot;abc&quot;;</span><br><span class="line">char[] str = string.toCharArray();</span><br><span class="line">Permutation(str, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2019/02/19/%E5%9B%BE/"/>
      <url>/2019/02/19/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>图(Graph)是由顶点的<em>有穷非空</em>集合和顶点之间边的集合组成。通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br><a id="more"></a><br>注意：</p><ul><li>数据元素，在线性表中叫元素，树中叫结点，图中称为顶点(Vertex)</li></ul><ol><li>无向边（Edge）<br>顶点Vi到Vj之间的边没有方向,用无序偶(Vi,Vj)来表示。</li><li>有向边<br>也称为弧(Arc),用有序偶&lt;Vi,Vj&gt;表示，Vi是弧尾，Vj是弧头</li><li>简单图<br>不存在顶点到其自身的边，且同一条边不重复出现。</li><li>无向完全图<br>在无向图中，任意两个顶点之间都存在边。含有n个项点的无向完全图有n*(n-1)/2条边。</li><li>有向完全图<br>在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。含有n个顶点的有向完全图有n*(n-1)条边。</li><li>稀疏图和稠密图<br>通常认为边或弧数小于n*logn的图为稀疏图。</li><li>权(Weight)<br>与图的边或弧相关的数</li><li>网(Network)<br>带权的图</li><li>度(Degree)<br>顶点和相关联的边的数目.TD(V) = ID(V)+OD(V)</li><li>入度(InDegree)<br>以顶点V为头的弧的数目称为V的入度，记为ID(V)</li><li>初读(OutDegree)<br>以V为尾的弧的数目称为V的出度，记为OD(V)  </li><li>回路或环(Cycle)<br>第一个顶点到最后一个顶点相同的路径<br>顶点不重复出现的是简单环</li><li>连通图<br>无向图中，每个顶点都相连，如果是有向图，称为强连通图</li><li>无向图中的极大连通子图称为连通分量</li></ol><ul><li>首先是子图，且子图是连通的</li><li>连通子图含有极大顶点数</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>是多对多的关系，树是一对多，链表是一对一  </p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>分为有向图邻接矩阵和无向图邻接矩阵</p><ol><li>无向图<br>用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息：0表示不存在，1表示存在。</li><li>有向图<br>与无向图一样，但无向图更浪费空间，因为无向图是对称矩阵</li><li>网<br>没有连线的两个顶点，用无穷∞表示</li></ol><ul><li>入度<br>该顶点所在列的和</li><li>出度<br>该顶点所在行的和</li></ul><ol start="4"><li>实现邻接矩阵<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Graph &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;Object&gt; point;//顶点信息</span><br><span class="line">private int[][] edge;//边信息，</span><br><span class="line">private int numEdge;//边的数目</span><br><span class="line">private int numVertex ;//顶点的数目</span><br><span class="line"></span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumVertex(int numVertex) &#123;</span><br><span class="line">this.numVertex = numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public ArrayList&lt;Object&gt; getPoint() &#123;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">public void setPoint(ArrayList&lt;Object&gt; point) &#123;</span><br><span class="line">this.point = point;</span><br><span class="line">&#125;</span><br><span class="line">public int[][] getEdge() &#123;</span><br><span class="line">return edge;</span><br><span class="line">&#125;</span><br><span class="line">public void setEdge(int[][] edge) &#123;</span><br><span class="line">this.edge = edge;</span><br><span class="line">&#125;</span><br><span class="line">public int getNumEdge() &#123;</span><br><span class="line">return numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumEdge(int numEdge) &#123;</span><br><span class="line">this.numEdge = numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public Graph(int n) &#123;</span><br><span class="line">this.point = new ArrayList&lt;&gt;(n);</span><br><span class="line">this.edge = new int[n][n];</span><br><span class="line">this.numEdge = 0;</span><br><span class="line">&#125;</span><br><span class="line">public Graph() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 建立无向图</span><br><span class="line"> */</span><br><span class="line">public static Graph buildGraph() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共多少个顶点&quot;);</span><br><span class="line">int numVertex  = scan.nextInt();</span><br><span class="line">System.out.println(&quot;一共多少条边&quot;);</span><br><span class="line">int numEdge = scan.nextInt();</span><br><span class="line">Graph g = new Graph();</span><br><span class="line">g.setNumEdge(numEdge);</span><br><span class="line">g.setNumVertex(numVertex);</span><br><span class="line">//读入顶点信息</span><br><span class="line">int vertex = numVertex;</span><br><span class="line">ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">scan.nextLine();</span><br><span class="line">while(vertex&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;请输入顶点&quot;);</span><br><span class="line">String s = scan.nextLine();</span><br><span class="line">list.add(s);</span><br><span class="line">vertex--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">g.setPoint(list);</span><br><span class="line">//初始化</span><br><span class="line">int[][] edge = new int[numVertex][numVertex];</span><br><span class="line">for(int i=0;i&lt;g.getNumVertex();i++) &#123;</span><br><span class="line">for(int j=0;j&lt;g.getNumVertex();j++) &#123;</span><br><span class="line">edge[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//加入到邻接矩阵中，1表示有边</span><br><span class="line">while(numEdge&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;输入连接的两个顶点，用“#”隔开&quot;);</span><br><span class="line">String num = scan.nextLine();</span><br><span class="line">String[] nums = num.split(&quot;#&quot;);</span><br><span class="line">int indexOf0 = list.indexOf(nums[0]);</span><br><span class="line">int indexOf1 = list.indexOf(nums[1]);</span><br><span class="line">if(indexOf0&lt;0 || indexOf1&lt;0) &#123;</span><br><span class="line">System.out.println(&quot;顶点不存在，请重新输入！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edge[list.indexOf(nums[0])][list.indexOf(nums[1])] = 1;</span><br><span class="line">//因为是对称的</span><br><span class="line">edge[list.indexOf(nums[1])][list.indexOf(nums[0])] = 1;</span><br><span class="line">numEdge--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//打印出来</span><br><span class="line">System.out.print(&quot; &quot;);</span><br><span class="line">for(Object li : list) &#123;</span><br><span class="line">System.out.print(li+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;numVertex;i++) &#123;</span><br><span class="line">System.out.print(list.get(i)+&quot; &quot;);</span><br><span class="line">for(int j=0;j&lt;numVertex;j++) &#123;</span><br><span class="line">System.out.print(edge[i][j]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">buildGraph();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果 </p><blockquote><p>一共多少个顶点<br>5<br>一共多少条边<br>5<br>请输入顶点<br>a<br>请输入顶点<br>b<br>请输入顶点<br>c<br>请输入顶点<br>d<br>请输入顶点<br>e<br>[a, b, c, d, e]<br>输入连接的两个顶点，用“#”隔开<br>a#b<br>输入连接的两个顶点，用“#”隔开<br>d#e<br>输入连接的两个顶点，用“#”隔开<br>c#b<br>输入连接的两个顶点，用“#”隔开<br>b#d<br>输入连接的两个顶点，用“#”隔开<br>d#a<br> a b c d e<br>a 0 1 0 1 0<br>b 1 0 1 1 0<br>c 0 1 0 0 0<br>d 1 1 0 0 1<br>e 0 0 0 1 0 </p></blockquote><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>AdjacencyList<br>是链表和数组的结合(树也是链表和数组的结合哟)  </p><ol><li>处理方法  </li></ol><ul><li>图中顶点用一个一维数组存储（或者单链表），用一维数组是为了更快的读取顶点信息，更加方便。  </li><li>图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以用单链表存储。  </li></ul><p><em>邻接表关心出度，不关心入度</em><br>类似于树的孩子表示法</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>邻接矩阵适用于顶点少，边数多的图，邻接表相反</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>把邻接表和逆邻接表结合起来。<br>结构为：tailVex   headVex    headLink   tailLink<br>Vex表示顶点，Link表示结点<br>常用！！！！！！！！</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>是对边的操作</p><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>由两个一维数组组成，一个存储顶点，一个存储边信息，这个边数组每个数据元素由一条边的起点下标，重点下标和全组成。<br><img src="/2019/02/19/图/1.PNG" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/2019/02/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2019/02/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>也称赫夫曼树、最优二叉树，Huffman,是首个实用的压缩编码方案。<br>&#160;&#160;&#160;&#160;给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉为最优二叉树，也称为哈夫曼树。<br><a id="more"></a><br>&#160;&#160;&#160;&#160;哈夫曼树是带权路径最短的树，权值较大的结点离根较近。</p><ul><li>路径长度<br>从根节点到该节点的路径上的连接数</li><li>树的路径长度<br>树中每个叶子结点的路径长度之和</li><li>结点带权路径长度<br>结点的路径长度与结点权值的乘积</li><li>树的带权路径长度<br>WPL(Weighted Path Length)是树中所有叶子结点的带权路径长度之和，WPL越小，树的结构越优。<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1></li><li>定长编码<br>约定8位表示一个字符</li><li>变长编码<br>单个编码的长度不一致，可以根据整体出现频率来调节<br>-前缀码<br>没有任何码字是其他码字的前缀</li></ul><p>约定，左子树用0表示，右子树用1表示<br><strong><em>很很很重要</em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树(Binary Tree)</title>
      <link href="/2019/02/17/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/02/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;也叫 二分树、二元树、对分树等。是n(n&gt;=0)个结点的有限元素的集合,该集合或为空，或为由一个根元素以及两个互不相交的、被分别称为左子树和右子树的二叉树组成。当集合为空时，称该二叉树为空二叉树。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>子树不能大于2哟</li><li>左右子树是有顺序的哟</li><li>如果没有左子树，是允许有右子树的<a id="more"></a><h1 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h1></li></ul><ol><li>斜树<br><img src="/2019/02/17/二叉树/1.PNG" alt=""></li><li>满二叉树<br>如果在一棵二叉树中，所有的分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上面。<br><img src="/2019/02/17/二叉树/2.PNG" alt=""><br>结点数为2^n-1    ,n表示深度</li><li>完全二叉树<br>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下，从左至右的顺序进行编号。如果说编号为i(1&lt;=i &lt;=n )的结点与满二叉树中编号为i的结点在二叉树中的位置相同的话，则称为是完全二叉树<br><strong><em>满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树</em></strong><br><strong>特点：</strong><br>&#160;&#160;&#160;&#160;叶子结点只能出现在最后一层或者倒数第二层上<br>&#160;&#160;&#160;&#160;最下层叶子结点集中在树的左部（根据满二叉树的定义来的）<br>&#160;&#160;&#160;&#160;同样结点数的二叉树，完全二叉树的深度是最小的  </li><li>线索二叉树<br>n个结点的二叉链表中含有n+1个空指针域。利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针（附加的指针称为线索）   <h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2>一维数组存储结点，从上至下，从左至右，不存在的结点可以用-1表示<br>但是如果空结点过多（如斜树）h会造成大量的空间浪费，适用性不强，一般使用链式存储<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2>二叉链表</li></ol><ul><li>数据</li><li>左子树结点，右子树结点  </li></ul><p>结构为：左子树   数据  右子树<br><img src="/2019/02/17/二叉树/3.PNG" alt=""> </p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><em>注意：</em><br>树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点棉面临着不同的选择。  </p><ul><li>前序遍历<br>根-左-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历<br>左-根-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历<br>左-右-根</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层次遍历  </li></ul><p>节点类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tree &#123;</span><br><span class="line">private Object data;</span><br><span class="line">private Tree lchild;</span><br><span class="line">private Tree rchild;</span><br><span class="line">public Object getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">public void setData(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getLchild() &#123;</span><br><span class="line">return lchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setLchild(Tree lchild) &#123;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getRchild() &#123;</span><br><span class="line">return rchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setRchild(Tree rchild) &#123;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data, Tree lchild, Tree rchild) &#123;</span><br><span class="line">super();</span><br><span class="line">this.data = data;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.tree;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 二叉树</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BinaryTree &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Tree root = new Tree(0);</span><br><span class="line">Tree createTree = createTree(root);</span><br><span class="line">System.out.println(&quot;结点\t层次&quot;);</span><br><span class="line">traverse(createTree,1);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 遍历</span><br><span class="line"> * @param root</span><br><span class="line"> */</span><br><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private static void print(Tree root,int level) &#123;</span><br><span class="line">System.out.println(root.getData()+&quot;\t&quot;+level);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 建立二叉树</span><br><span class="line"> * @param root 树结点</span><br><span class="line"> * @param level  层次</span><br><span class="line"> */</span><br><span class="line">private static Tree createTree(Tree root) &#123;</span><br><span class="line"></span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String n = scan.nextLine();</span><br><span class="line">if(&quot;#&quot;.equals(n)) &#123;//叶子结点</span><br><span class="line">return null;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">root.setData(n);</span><br><span class="line">root.setLchild(createTree(new Tree(0)));</span><br><span class="line">root.setRchild(createTree(new Tree(0)));</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入 ：ABD##F##CE###<br>输出：<br>结点    层次<br>A       1<br>B       2<br>D       3<br>F       3<br>C       2<br>E       3</p><p>“#”表示他的双亲是叶子结点</p><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p><img src="/2019/02/17/二叉树/4.PNG" alt=""><br>嘿嘿，不懂<br>😭</p><h1 id="树-森林、二叉树转换"><a href="#树-森林、二叉树转换" class="headerlink" title="树/森林、二叉树转换"></a>树/森林、二叉树转换</h1><p><img src="/2019/02/17/二叉树/5.PNG" alt=""></p><h2 id="树到二叉树的转换"><a href="#树到二叉树的转换" class="headerlink" title="树到二叉树的转换"></a>树到二叉树的转换</h2><ul><li>每个兄弟结点连线</li></ul><p><img src="/2019/02/17/二叉树/6.PNG" alt=""></p><ul><li>去掉与孩子的连线（第一个长子除外）</li></ul><p><img src="/2019/02/17/二叉树/7.PNG" alt=""></p><ul><li>调整位置  </li></ul><p><img src="/2019/02/17/二叉树/8.PNG" alt=""></p><h2 id="森林到二叉树的转换"><a href="#森林到二叉树的转换" class="headerlink" title="森林到二叉树的转换"></a>森林到二叉树的转换</h2><ul><li>将森林中的每棵树转为二叉树</li><li>将根一次连在一起</li><li>调整位置</li></ul><h2 id="二叉树到树、森林的转换"><a href="#二叉树到树、森林的转换" class="headerlink" title="二叉树到树、森林的转换"></a>二叉树到树、森林的转换</h2><ul><li>若结点x是其双亲y的左孩子，则把x的右孩子，有孩子的有孩子，，，，，，都与y用连线连起来</li><li>去除双亲所有右孩子的连线</li></ul><p><em>二叉树的根节点有右孩子就是森林，没有就是树</em></p><h1 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h1><h2 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h2><p>先访问树的根节点，然后再一次访问根的每棵子树</p><h2 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h2><p>先遍历树的每棵子树，再遍历根</p><p><img src="/2019/02/17/二叉树/9.PNG" alt=""></p><p>嗒嗒嗒，森林的遍历，名词叫做前序遍历和后序遍历，其实就是按照树的先根遍历和后根遍历一次来访问森林的每一棵树。</p><p>树、森林的前根遍历和（转变后的）二叉树的前序遍历相同<br>后根遍历和（转变后的）二叉树的中序遍历相同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五个常见算法</title>
      <link href="/2019/02/15/%E4%BA%94%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
      <url>/2019/02/15/%E4%BA%94%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><ol><li>递归<br>&#160;&#160;&#160;&#160;直接或间接地调用自身的算法    </li><li>分治<br>&#160;&#160;&#160;&#160;将一个规模为n的，难以解决的问题分解为k个规模较小的子问题，<em>子问题相互独立</em>  </li></ol><p>将子问题递归解决，得到源问题的解  </p><ol start="3"><li>典型案例<br>Fibonacci数列，阶乘，Hanoi塔，二分法搜索，高速排序，合并排序<a id="more"></a><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Dynamis programming,是运筹学的一个分支，是求解决策过程最优化的数学方法。 </li><li>基本思想<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;类似分治法，将待求解问题分解成若干个子问题，先求解子问题，但是<em>子问题不是相互独立的</em>，避免大量的重复计算，每一次要用到前一问题的解   </li><li><p>分类<br>线性动态规划： 拦截导弹， 合唱队形， 挖地雷， 建学校， 剑客决斗<br>区域动态规划： 石子合并， 加分二叉树， 统计单词个数， 炮兵布阵<br>树形动态规划： 贪吃的九头龙， 二分查找树， 聚会的欢乐， 数字三角形。<br>背包动态规划： 01背包问题， 完全背包问题， 分组背包问题， 二维背包， 装箱问题， 挤牛奶， </p></li><li><p>实例<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最短路径问题， 项目管理， 网络流优化， 最长公共子序列，最大连续子序列和， 矩阵连乘， 凸多边形最优三角剖分， 电路布线。</p></li></ol><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><ol><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;对问题求解时，总是做出再当前看来最好的选择，也就是说，不从整体最优上加以考虑。<br>某个状态以前的过程不会影响以后的状态，只与当前状态有关。  </li><li>与动态规划的区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;贪心算法是自顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为规模更小的子问题，最后得到一个整体最优解。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不能回退，动态规划可以</li><li>思路<br>建立数学模型来描述问题<br>把求解的问题分成若干个子问题<br>对每一子问题求解，得到子问题的局部最优解<br>八字问题的解局部最优解合成原问题的一个解  </li><li>案例<br>01背包问题， 马踏棋盘，最小生成树的Prim算法和Kruskal算法<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;能进则进，不进则退  。类似枚举的搜索尝试过程，主要再搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就返回，尝试别的路径，<em>是一种选优搜索法</em><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;需要深度优先的方式搜索解空间 </li><li>案例<br>八皇后问题<h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1></li><li><p>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生所有儿子结点，在儿子结点中，导致不可行解或者非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。再从活结点中取下一结点成为当前扩展结点。重复……<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;常以广度优先或以最小消耗优先的方式搜索问题的解空间树。</p></li><li><p>方法  </p></li></ol><ul><li>队列式(FIFO)分支限界法<br>按照队列原则选区下一个结点为扩展结点</li><li>优先队列式分支限界法<br>按优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。</li></ul><ol start="3"><li>与回溯法区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是求条件下的所有解，分支限界是一个解<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是深度优先，分支限界是广度优先   </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年第一周</title>
      <link href="/2019/02/15/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2019/02/15/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>作为新年的第一周，真的是，微笑中透露着疲惫</p><ul><li>周二给同学发了简历，周五了，还没给信</li><li>数据结构真的不好复习</li><li>刷题真的伤时间</li><li>第一周13号线停了一周，我单程时间就变成了2小时</li><li>7：40出发，9：40到公司，心态已崩</li><li>家里乱哄哄的，我已经不想管了，忙完这一阵就搬家</li><li>新年愿望：<blockquote><p>换工作<br>顺利毕业<br>皮肤变好<br>瘦<br>如果可以，还有小哥哥</p></blockquote></li></ul><ul><li>最后一定要说：尹腾召是个大傻子，大猪蹄子，糟老头子</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2019/02/14/leetcode/"/>
      <url>/2019/02/14/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                if(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    arr[0] = i;</span><br><span class="line">                    arr[1] = j;</span><br><span class="line">                    return arr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间58ms，属于暴力解法了，击败24.62%的用户，太菜了  </p><ul><li>利用hashmap的动态分配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++) &#123;</span><br><span class="line">       if(map.containsKey(target-nums[i])) &#123;</span><br><span class="line">       arr[0] = map.get(target-nums[i]);</span><br><span class="line">       arr[1] = i;</span><br><span class="line">       return arr;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">       map.put( nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间8ms,击败87.66%的用户</p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p></blockquote><blockquote><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p></blockquote><blockquote><p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode newNode = new ListNode(0);</span><br><span class="line">       ListNode cur = newNode;</span><br><span class="line">        int carry = 0;//进位</span><br><span class="line">        while(l1 !=null || l2 != null)&#123;</span><br><span class="line">            int val1 = (l1 != null)? l1.val : 0;</span><br><span class="line">            int val2 = (l2 != null)? l2.val : 0;</span><br><span class="line">            int num = carry+val1+val2;</span><br><span class="line">            carry = num/10;</span><br><span class="line">            //这里如果用cur.val = num%10;</span><br><span class="line">            //就需要cur.next = new ListNode(0);</span><br><span class="line">            //反正每次结点都需要new</span><br><span class="line">        cur.next = new ListNode(num%10);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">            if(l1 != null)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 != null)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry&gt;0)//最后如果还有进位</span><br><span class="line">            cur.next = new ListNode(carry);</span><br><span class="line">        return newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间68ms,击败19.44%的用户<br>算是最直接（笨）的写法了，看来还要优化  </p><h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><p>示例 1:  </p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:  </p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。  </p></blockquote><pre><code>请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">int result = 0;</span><br><span class="line">int length = s.length();</span><br><span class="line">int i=0,j=0;</span><br><span class="line">//也可以用指针</span><br><span class="line">while(i&lt;length &amp;&amp; j&lt;length) &#123;</span><br><span class="line">if(set.contains(s.charAt(j))) &#123;</span><br><span class="line">//删掉最先出现的那个重复的</span><br><span class="line">set.remove(s.charAt(i++));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">set.add(s.charAt(j++));</span><br><span class="line">//关键的一步</span><br><span class="line">result = Math.max(result, j-i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是官方示例，关键在于对result求最大值，我之前的算法总是不能概括所有情况，后续会更新这道题（链表的形式）</p><h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4.寻找两个有序数组的中位数"></a>4.寻找两个有序数组的中位数</h1><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0<br>示例 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">//1.需要合并两个数组,并排序</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;nums1.length;i++) &#123;</span><br><span class="line">list.add(nums1[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0; j&lt;nums2.length; j++) &#123;</span><br><span class="line">list.add(nums2[j]);</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, null);</span><br><span class="line">//2.分奇偶</span><br><span class="line">int length = list.size();</span><br><span class="line">if(length%2 != 0) &#123;</span><br><span class="line">int result = list.get(length/2);</span><br><span class="line">return (double)result;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return (double)(list.get(length/2)+list.get(length/2-1))/2;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行用时94ms，击败12.56%的用户<br>内存消耗50.8MB，击败30.27%的用户</p><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><p>第一：错误示范，字符串特别长是，超时,答案是对的，但是过于暴力，不符合时间要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> * @param s</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String longestPalindrome(String s) &#123;</span><br><span class="line">//最暴力的方法：1找出所有子串</span><br><span class="line">List&lt;String&gt; list = substringAll(s);</span><br><span class="line">//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line">String result = &quot;&quot;;</span><br><span class="line">if(s.length() == 0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">if(s.length()&gt;0) &#123;</span><br><span class="line">result = s.substring(0, 1);</span><br><span class="line">&#125;</span><br><span class="line">while(list.size()&gt;0)&#123;</span><br><span class="line">String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">String tmp = list.get(0);</span><br><span class="line">for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(list.size()&gt;0 &amp;&amp; list.get(0).equals(tmp)) &#123;</span><br><span class="line">if( list.get(0).length()&gt;result.length()) &#123;</span><br><span class="line">result = list.get(0);</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">String str = s.substring(i, j);</span><br><span class="line">if(str.length()&gt;1  ) &#123;</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String str = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">System.out.println(longestPalindrome(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二：稍微改进了一点，但是还是超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //最暴力的方法：1找出所有子串</span><br><span class="line">if(s.length() == 0) &#123;</span><br><span class="line">return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String result = &quot;&quot;;</span><br><span class="line">if(s.length()&gt;0) &#123;</span><br><span class="line">result = s.substring(0, 1);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; list = substringAll(s);</span><br><span class="line">//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line"></span><br><span class="line">while(list.size()&gt;0)&#123;</span><br><span class="line">/*String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">String tmp = list.get(0);</span><br><span class="line">for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;*/</span><br><span class="line">if( list.get(0).length()&gt;result.length()) </span><br><span class="line">result = list.get(0);</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;</span><br><span class="line">//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">String str = s.substring(i, j);</span><br><span class="line">//是回文</span><br><span class="line">if(str.length()&gt;1 &amp;&amp; new StringBuffer(str).reverse().toString().equals(str)) &#123;</span><br><span class="line">if(list.size()== 0 || !list.get(list.size()-1).contains(str))</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行用时10578ms，击败了0.98%的用户<br>内存消耗380MB，击败了0.97%得用户—-真可怕</p><h1 id="6-Z-N-字形变换"><a href="#6-Z-N-字形变换" class="headerlink" title="6. Z(N)字形变换"></a>6. Z(N)字形变换</h1><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p></blockquote><blockquote><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L&#160;&#160;&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I   &#160;&#160;&#160;&#160;&#160;R<br>E &#160;T &#160;O&#160;&#160;E&#160;&#160;S&#160;&#160;&#160;I&#160;&#160;  I&#160;&#160;&#160;&#160;G<br>E&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;H   &#160;&#160;&#160;&#160;&#160;N          </p></blockquote><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><blockquote><p>string convert(string s, int numRows);  </p></blockquote><p>示例 1:</p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”  </p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;R<br>E&#160;&#160;&#160;&#160;&#160;&#160;&#160;O&#160;&#160;&#160;E&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;I<br>E&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;&#160;&#160;H&#160;&#160;&#160;&#160;&#160;&#160;N<br>T&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 7.0整数反转 #</span><br><span class="line">给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> 示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure><p>class Solution {<br>    public int reverse(int x) {<br>        int rev = 0;<br>            while (x != 0) {<br>                int pop = x % 10;<br>                x /= 10;<br>                if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return 0;<br>                if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return 0;<br>                rev = rev * 10 + pop;<br>            }<br>            return rev;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">执行用时43ms,击败了64.62%的用户  </span><br><span class="line">内存消耗32.6MB,击败了43.26%的用户</span><br><span class="line"></span><br><span class="line">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p> public boolean isPalindrome(int x) {<br>        if(x&lt;0)<br>            return false;<br>        boolean rlt = false;<br>        int rev = 0;<br>        int n = x;<br>        while (n != 0) {<br>            int pop = n % 10;<br>            n /= 10;<br>            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return false;<br>            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return false;<br>            rev = rev * 10 + pop;<br>        }<br>        if(rev == x)<br>            rlt = true;<br>        return rlt;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时146ms，击败了81.29%的用户  </span><br><span class="line">内存消耗：30.3MB，击败了63.98%的用户  </span><br><span class="line"></span><br><span class="line">emmmmm,最快的一次了</span><br><span class="line"></span><br><span class="line"># 11.盛最多水的容器 #</span><br><span class="line"></span><br><span class="line">&gt;给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">&gt;说明：你不能倾斜容器，且 n 的值至少为 2。</span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [1,8,6,2,5,4,8,3,7]  </span><br><span class="line">输出: 49</span><br><span class="line"></span><br><span class="line">暴力解</span><br></pre></td></tr></table></figure></p><p>public int maxArea(int[] height) {<br>        int max = 0;<br>        for(int i=0;i&lt;height.length;i++) {<br>            for(int j=i+1;j&lt;height.length;j++) {</p><pre><code>            int num = Math.min(height[i], height[j])*(j-i);            max = max&lt;num ? num:max;        }    }     return max;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时402ms,击败了22.18%的用户  </span><br><span class="line">内存消耗47.8MB，击败了0.96%的用户</span><br><span class="line"></span><br><span class="line">方法二：双指针法（官方题解）  </span><br><span class="line">思想：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;两线段之间形成的区域总是会受到其中较短那条长度的限制，此外，线段距离越远，得到的面积越大   </span><br><span class="line">分析：</span><br><span class="line">- 两个指针，一个指向头， 一个指向尾  </span><br><span class="line">- 每一步中，比较max，且较短线段的指针向较长线段指针的一侧移动。</span><br></pre></td></tr></table></figure><p> public int maxArea(int[] height) {<br>       int max = 0;<br>        int i=0;<br>        int j = height.length-1;<br>        while(i&lt;j) {<br>            max = Math.max(max, Math.min(height[i], height[j])*(j-i));<br>            if(height[i]&gt;height[j]) {<br>                j–;<br>            } else {<br>                i++;<br>            }<br>        }<br>         return max;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">执行用时：10ms,击败了64.19%的用户  </span><br><span class="line">内存消耗47.1MB,击败了0.96%的用户  </span><br><span class="line"># 接雨水 #</span><br><span class="line"></span><br><span class="line">是一道难题，思路难，以下是百度的答案 (思路是百度给的，但是没有看答案哟)</span><br><span class="line">&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line">![](leetcode/接雨水.PNG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]  </span><br><span class="line">输出: 6  </span><br><span class="line">分析：</span><br><span class="line">如果想接到雨水，需要满足的条件是</span><br><span class="line">- height[i-1]&gt;height[i]</span><br><span class="line">- height[i]&lt;height[i+1]  </span><br><span class="line"></span><br><span class="line">假设已知最高点的坐标macIndex及其高度maxValue,考虑从左逐渐靠近最高点，此时，只需考虑第一个条件，因为始终有height[maxIndex]&gt;height[i]   </span><br><span class="line">*局部最高curRoot*</span><br><span class="line">局部最高与其余高度值得差值和即为积水和。  </span><br><span class="line">例如上例；积水和分别为:</span><br><span class="line">&gt;左侧：[0,1,1,2,2,2,2]（左往右）,那么左侧积水和为1+1+2+1 = 5</span><br><span class="line">&gt;右侧:[2,2,2,1]（右往左）,那么左侧积水和为1+1</span><br><span class="line">积水和为：5+1 = 6    </span><br><span class="line">  </span><br><span class="line">方法：</span><br><span class="line">- 遍历整个数组，找最高点  </span><br><span class="line">- 从左向右遍历至最高点坐标，求积水和</span><br><span class="line">- 从右向左遍历至最高点坐标，求积水和</span><br></pre></td></tr></table></figure></p><p> /**</p><pre><code>  * 接雨水  * @param height  * @return  */ public static int trap(int[] height) {     if(height == null || height.length == 0) {         return 0;     }    int max = 0;    int maxIndex = 0;   //遍历数组找到最高点    for(int i=0;i&lt;height.length;i++) {        if(height[i]&gt;max) {            maxIndex = i;            max = height[i];        }    }    int left = 0,right = 0;    //从左向右遍历至最高点，返回积水和    if(maxIndex&gt;0) {        left = countWaterLeft(0, maxIndex, height);    }    //从右向左遍历至最高点，返回积水和    if(maxIndex&lt;height.length-1) {        right = countWaterRight(maxIndex, height.length-1, height);    }    max = left+right;    return max;  }public static int countWaterRight(int maxIndex, int length, int[] height) {    int res = 0;    int[] result = new int[length - maxIndex];    int j=result.length-2;    //height: 0,1,0,2,1,0,1,3,2,1,2,1     //result:               [2,2,2,1]    result[result.length-1] = height[length];    for(int i=length-1;i&gt;maxIndex;i--) {        result[j] = Math.max(result[j+1], height[i]);        res += Math.abs((result[j]-height[i]));        j--;    }    return res;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时24ms,击败了43.90%的用户  </span><br><span class="line">内存消耗453.MB，击败了0.94%的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">来一份网友答案：：</span><br></pre></td></tr></table></figure><p>找到三个值，第一是头值，第二是尾值，第三是除去头和尾之外，中间的最大值，如果中间的最大值小于头和尾的最小值，那么直接就可以计算出结果，如大于等于最大值（其实等于也可以直接处理，避免下一次递归，但是我为了懒省事没写。。。），则从中间把它们一分为二，再分别求值加到一起。运行时间11ms,超越100%。<br>class Solution {<br>    public int trap(int[] height) {<br>        if(height.length&lt;3){<br>            return 0;<br>        }<br>        return find(height,0,height.length-1);<br>    }<br>    public int find(int[] height,int start,int end){<br>        if(end-start&lt;2){//递归的终点<br>            return 0;<br>        }<br>        int max=-1,tmp=-1,min_two=Math.min(height[start],height[end]),sum=0;;<br>        for(int i=start+1;i&lt;end;i++){<br>            //这一句写在哪里都行<br>            sum=sum+(min_two-height[i]);<br>            if(height[i]&gt;max){<br>                max=height[i];<br>                tmp=i;<br>            }<br>        }</p><pre><code>    if(max&lt;min_two){//上面的加法其实应该在这里，转移到上面和在这里其实都一样        //sum=sum+(min_two-height[i]);        return sum;    }else{//其实这里还可以优化一下当中间的max值等于start或者end的时候，当它等于start,那么直接计算即可，不用进行下一次递归，因为下一次递归会再扫描一遍        return find(height,start,tmp)+find(height,tmp,end);    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 344.反转字符串 #</span><br><span class="line">&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。  </span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。  </span><br><span class="line">你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&gt;示例 1：  </span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]  </span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class="line"></span><br><span class="line">&gt;示例 2：  </span><br><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]  </span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public void reverseString(char[] s) {<br>        for(int i=0,j = s.length-1;i&lt;j;i++,j–) {<br>            char tmp = s[i];<br>            s[i] = s[j];<br>            s[j] = tmp;<br>        }<br>        for(int i=0;i&lt;s.length;i++) {<br>            System.out.print(s[i]);<br>        }<br>    }<br>}<br><code>`</code><br>执行用时</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2019/02/14/%E6%A0%91/"/>
      <url>/2019/02/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是一对多的数据结构<br>树是n个结点的有限集，当n = 0 时称为空树。在任意一棵非空树中：  </p><ul><li>有且仅有一个特定的称为根的结点</li><li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每个集合本身又是一棵树，并称为根的子树(SubTree)   <a id="more"></a>  </li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li><p>度<br>结点拥有的子树，树的度是各结点度的最大值<br>度为 0 的结点称为叶节点(leaf)或者终端结点<br>度不为0 的结点称为分支结点，或非终端节点，除了根节点外，分支结点也称为内部结点。</p></li><li><p>结点的层次(level)<br>结点的层次从根开始定在一起，根为第一层<br>双亲在同一层的结点互为堂兄弟</p></li><li><p>结点的祖先<br>从根节点到该节点所经过分支上的所有结点</p></li><li><p>深度或高度<br>结点的最大层次称为树的深度(depth)或高度</p></li><li><p>森林(fores)<br>由m(m&gt;=0)棵互不相交的树组成的集合 </p></li><li><p>兄弟(sibling)<br>同一个双亲的孩子之间称为兄弟 </p></li><li><p>无序树和有序树<br>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则是有序树，否则是无序树。</p></li></ul><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>顺序结构和链表结构都是一对一；树可以实现一对多的结构</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指向其双亲结点到链表中的位置。<br><img src="/2019/02/14/树/treeParent.PNG" alt=""></p><p><strong><em>需要知道自己的数据和双亲位置</em></strong></p><p><strong>优点</strong><br>&#160;&#160;&#160;&#160;找到双亲的速度很快，复杂度为O(1)<br><strong>缺点</strong><br>&#160;&#160;&#160;&#160;如果需要找到孩子数据，需要遍历整个结构</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>数组和链表的搭配结合<br>孩子表示法<br><img src="/2019/02/14/树/treeChildren" alt="">  </p><p>双亲孩子表示法<br><img src="/2019/02/14/树/treeChildrenParent" alt="">  </p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>左孩子右兄弟</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BF and KMP</title>
      <link href="/2019/02/12/BF-and-KMP/"/>
      <url>/2019/02/12/BF-and-KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;全称探索与回溯法，是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。<br>&#160;&#160;&#160;&#160;当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择——走不通退一步的技术为回溯法，满足回溯条件的某一个状态的点称为“回溯点” </p><h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><ul><li>针对给定的问题，定义问题的解空间</li><li>确定易于搜索的解空间结构</li><li>以深度优先方式搜索解空间，再广度优先方式搜索</li></ul><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>背包问题，八皇后问题（递归和回溯），多用于树</p><h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;暴风（Brute Force）算法，是普通的模式匹配算法</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>&#160;&#160;&#160;&#160;将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，得到最后的匹配结果，是一个暴力算法。时间复杂度O(M<em>(N-M+1)) = O(M</em>N),其中M&lt;N</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line">/**</span><br><span class="line"> * 暴风算法，简单的模式匹配</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BF &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//主串</span><br><span class="line">String s = &quot;iloveyou&quot;;</span><br><span class="line">String[] S = s.split(&quot;&quot;);</span><br><span class="line">//字串</span><br><span class="line">String t = &quot;loveeee&quot;;</span><br><span class="line">String[] T = t.split(&quot;&quot;);</span><br><span class="line">//从第0位开始匹配</span><br><span class="line">bruteForce(S,T,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void bruteForce(String[] S, String[] T, int pos) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int j = 0;</span><br><span class="line">while(i&lt;S.length &amp;&amp; j&lt;T.length) &#123;</span><br><span class="line">//这里不可以用&quot; == &quot;,我们比较的是内容</span><br><span class="line">if(S[i].equals(T[j])) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i++;</span><br><span class="line">j = 0;</span><br><span class="line">&#125;</span><br><span class="line">if(j == T.length) &#123;</span><br><span class="line">System.out.println(&quot;T在S中的下标位置：&quot;+(i-T.length));</span><br><span class="line">break;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">if(i == S.length &amp;&amp; j != T.length) &#123;</span><br><span class="line">System.out.println(&quot;不匹配&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>&#160;&#160;&#160;&#160;由D·E·Knuth、J·H·Morris 和 V·R·Pratt三人设计的线性时间字符串匹配算法。<br>&#160;&#160;&#160;&#160;KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息，时间复杂度为：</p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;O(M+N)</p><h2 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h2><p><strong>前缀</strong>  </p><p>除了最后一个字符以外，一个字符串的全部头部<strong><em>集合</em></strong><br><strong>后缀</strong>     </p><p>除了第一个字符以外，一个字符串的全部尾部<strong><em>集合</em></strong>  </p><p><strong>案例</strong>  </p><ul><li>字符串：A<br>前缀：空集<br>后缀：空集<br>共有长度：0  </li><li>字符串：AB<br>前缀：A<br>后缀：B<br>共有长度：0  </li><li>字符串：ABC<br>前缀：[A,AB]<br>后缀：[B,BC]<br>共有长度：0  </li><li>字符串：ABCD<br>前缀：[A,AB,ABC]<br>后缀：[BCD,CD,D]<br>共有长度：0</li></ul><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>next数组存的是当前字符串前缀和后缀的共有长度，因此对比的时候是需要用两个相同的字符串进行比较。<br>分析：</p><ul><li>若T(模式串),T[i] == T[j]<br>相等，说明 前缀 == 后缀，此时要进行后一位的匹配：i++;&#160;&#160;j++;&#160;&#160;&#160;next[i] = j;</li><li>否则，j要回溯<br>前缀是固定的，后缀是相对的。<br>j = next[j];<br>j为下一次要匹配的位置</li><li>因为i是后缀，j是前缀，初始时，i = j+1;<br>图解：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * KMP字符串匹配模式</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class KMP &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 字符的前后缀最高长度-next数组</span><br><span class="line"> */</span><br><span class="line">public static void getNext(String s) &#123;</span><br><span class="line">char[] p = s.toCharArray();</span><br><span class="line">    int[] next = new int[p.length];</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = -1;</span><br><span class="line">    while (i &lt; p.length - 1) &#123; </span><br><span class="line">       if (j == -1 || p[i] == p[j]) &#123;</span><br><span class="line">       i++;</span><br><span class="line">       j++;</span><br><span class="line">           next[i] = j;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">       //回溯</span><br><span class="line">           j = next[j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">for(int n=0;n&lt;next.length;n++) &#123;</span><br><span class="line">System.out.print(next[n]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String S = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">getNext(S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kmp算法实现"><a href="#kmp算法实现" class="headerlink" title="kmp算法实现"></a>kmp算法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * KMP字符串匹配模式</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class KMP &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回字串T在主串S中的位置</span><br><span class="line"> * @param s</span><br><span class="line"> * @param t</span><br><span class="line"> * @param pos</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int KMPPlay(String[] s, String[] t, int pos) &#123;</span><br><span class="line">int i=pos;</span><br><span class="line">int j=-1;</span><br><span class="line">int[] next = new int[s.length+1];</span><br><span class="line">next[0] = -1;</span><br><span class="line">while(i&lt;s.length &amp;&amp; j&lt;t.length) &#123;</span><br><span class="line">if(-1 == j || s[i].equals(t[j])) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(j&gt;= t.length) &#123;</span><br><span class="line">return i-t.length;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;//不存在</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个模式串字符串：&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String S = scan.nextLine();</span><br><span class="line">System.out.println(&quot;请输入一个字串：&quot;);</span><br><span class="line">String T = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">System.out.println(KMPPlay(S.split(&quot;&quot;), T.split(&quot;&quot;), 0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h2><p>例如当主串为：ssssssssa<br>字串为：sssa时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * KMP字符串匹配模式</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class KMP &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回字串T在主串S中的位置</span><br><span class="line"> * @param s</span><br><span class="line"> * @param t</span><br><span class="line"> * @param pos</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int KMPPlay(String[] s, String[] t, int pos) &#123;</span><br><span class="line">int i=pos;</span><br><span class="line">int j=-1;</span><br><span class="line">int[] next = new int[s.length+1];</span><br><span class="line">next[0] = -1;</span><br><span class="line">while(i&lt;s.length &amp;&amp; j&lt;t.length) &#123;</span><br><span class="line">if(-1 == j || s[i].equals(t[j])) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">if(i&lt;s.length &amp;&amp; s[i].equals(t[j])) &#123;</span><br><span class="line">next[i] = next[j];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(j&gt;= t.length) &#123;</span><br><span class="line">return i-j;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;//不存在</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个模式串字符串：&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String S = scan.nextLine();</span><br><span class="line">System.out.println(&quot;请输入一个字串：&quot;);</span><br><span class="line">String T = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">System.out.println(KMPPlay(S.split(&quot;&quot;), T.split(&quot;&quot;), 0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归与分治</title>
      <link href="/2019/02/08/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/"/>
      <url>/2019/02/08/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>直接或间接调用自身的一种方法，减少了程序的代码量，即：<br>&#160;&#160;&#160;&#160;用有限的语句定义对象的无限集合<br>前提条件：</p><ul><li>不可无限制的调用自己，需要有一个出口</li><li>子问题不可大于原始问题<a id="more"></a>最典型的递归案例是：斐波那契数列，汉诺塔（梵塔），背包问题，快排、树<br><strong>缺点</strong><br>运行效率低，因此除非没有更好的算法，或者是特定条件下，一般不建议使用递归。<br>递归调用的过程中，系统为每一层的返回点、局部变量等都开辟了栈来存储，因此如果过多的使用递归，容易造成栈溢出。</li></ul><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p>源于分而治之的思想，将大问题分成小问题，将小问题再分成更小的问题，一直到最后的子问题可以简单的直接求解。源问题的解即子问题解的合并。<br>经典案例：快排、归并排序，傅里叶转换</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>需要反复执行的子程序，进行一次重复，即重复执行程序中的循环，直到满足某条件为止。</p><h1 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h1><p><img src="/2019/02/08/递归与分治/loop.PNG" alt=""></p><h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><p>递归与分治很相似，但是不同的是，分治是：将大问题划分小问题，递归的去解决，再进行合并</p><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><ul><li>先排序，查找的一定是有序的数组或者链表</li><li>确定中间位置 mid = (left+right)/2</li><li>查找元素与mid进行比较，再对mid和left/right进行重新赋值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 折半查找问题</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Bisearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">System.out.println(&quot;输入要查找的数据&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">scan.close();</span><br><span class="line">getSearch(0,arr.length,n,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getSearch(int left, int right, int n,int[] arr) &#123;</span><br><span class="line">if(right&gt;left) &#123;</span><br><span class="line">int mid = (left+right)/2;</span><br><span class="line">if(n&lt;arr[mid]) &#123;</span><br><span class="line">getSearch(left, mid-1, n, arr);</span><br><span class="line">&#125; else if(n == arr[mid]) &#123;</span><br><span class="line">System.out.println(&quot;找到数据，下标为：&quot;+mid);</span><br><span class="line">&#125; else if(n&gt;arr[mid]) &#123;</span><br><span class="line">getSearch(mid+1, right, n, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;不存在该数据&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>汉诺塔时一个发源于印度的益智游戏，也叫河内塔。相传它源于印度神话中的大梵天创造的三个金刚柱，一根柱子上叠着上下从小到大64个黄金圆盘。大梵天命令婆罗门将这些圆盘按从小到大的顺序移动到另一根柱子上，其中大圆盘不能放在小圆盘上面。当这64个圆盘移动完的时候，世界就将毁灭。</p><p>问题：一个由多个放置在三个塔座上的盘子组成的一个古老的难题。<br>&#160;&#160;&#160;&#160;所有的盘子直径是不同的，并且盘子中央都有一个洞可以使它们刚好放在塔座上，所有的盘子刚开始都放在塔座A上。</p><p>目标是：将所有的盘子都从塔座A移动到塔座C上，每一次只移动一个盘子，并且任何一个盘子都不可以放在比自己小的盘子之上。  </p><p>分析：</p><ul><li>若n == 1<br>直接从A到C</li><li>若n ==2<br>(n-1)到B,n到C，(n-1)到C  </li><li>若n == 3<br>(n-2)到C，(n-1)到B，(n-2)到B，n到C，(n-2)到A，(n-1)到C，(n-2)到C</li></ul><p>分析：</p><ul><li>将A上的(n-1)盘子放在B上，n放在C上，其余再放到C上</li><li>n == 1,A-C</li><li>n == 2,A-B,A-C,B-C</li><li>n == 3, A-C,A-B,C-B,A-C,B-A,B-C,A-C</li></ul><p>思路：</p><ul><li>将(n-1)从A到B上<br>A借助C到B柱子上</li><li>n从A到C上<br> 输出</li><li>(n-1)从B到C上<br>B借助A到C柱子上去</li><li>递归ACB,BAC</li></ul><p><img src="/2019/02/08/递归与分治/hanoi.PNG" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 汉诺塔问题-A换到C柱子上去</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Hanoi &#123;</span><br><span class="line"></span><br><span class="line">private static int count = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共多少个盘子&quot;);</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">while(n&lt;1) &#123;</span><br><span class="line">System.out.println(&quot;请重新输入：&quot;);</span><br><span class="line">n = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">hanoiTest(n,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);</span><br><span class="line">System.out.println(&quot;总步数：&quot;+count);</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void hanoiTest(int n, String A, String B, String C) &#123;</span><br><span class="line">if(n == 1) &#123;</span><br><span class="line">move(A,C);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">hanoiTest(n-1, A, C, B);//n-1个盘子</span><br><span class="line">move(A,C);</span><br><span class="line">hanoiTest(n-1, B, A, C); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void move(String a, String c) &#123;</span><br><span class="line">count++;</span><br><span class="line">System.out.println(a+&quot;---&gt;&quot;+c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>回溯算法的典型例题，这里先用递归实现<br>&#160;&#160;&#160;&#160;是国际西洋棋棋手马克斯·贝瑟尔1848年提出，高斯算出了76种，后有人用图论法解出92种结果。<br>问题：<br>在8X8的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行，同一列，同一斜线上，有多少种解法(92)  </p><p>分析：  </p><ul><li>判断行和列</li><li>判断当前棋格的左上方，右上方，四列是否有皇后</li><li>不判断左或右下方是因为，我们是考虑第一行到本行的棋格</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line">/**</span><br><span class="line"> * 八皇后问题</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class EightQueen &#123;</span><br><span class="line"></span><br><span class="line">private static int count = 1;</span><br><span class="line">private static int[][] arr ;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">arr = init();</span><br><span class="line">//起始行，列数，数组</span><br><span class="line">eightQ(0,arr[0].length,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int[][] init() &#123;</span><br><span class="line">int[][] arr = new int[8][8];</span><br><span class="line">//初始化</span><br><span class="line">for(int i=0;i&lt;8;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;8;j++) &#123;</span><br><span class="line">arr[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 递归算法</span><br><span class="line"> * @param row  行</span><br><span class="line"> * @param length  列</span><br><span class="line"> * @param arr 8X8棋格</span><br><span class="line"> */</span><br><span class="line">private static void eightQ(int row, int length, int[][] arr) &#123;</span><br><span class="line">//这里不对Length做判断，是因为八皇后，，，，，八列</span><br><span class="line">int[][] tmp = arr;</span><br><span class="line">//列</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">if(check(row, i, tmp)) &#123;</span><br><span class="line">tmp[row][i] = 1;</span><br><span class="line">//判断是不是最后一行</span><br><span class="line">if(row == 7) &#123;</span><br><span class="line">show(tmp);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">eightQ(row+1, length, arr);</span><br><span class="line">&#125;</span><br><span class="line">//精华</span><br><span class="line">                //用回溯法，当前行放不了皇后之后，回溯到上一行，将上一行清零 ，</span><br><span class="line">//再判断当前列i之后的列是否可以放皇后</span><br><span class="line">tmp[row][i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否能放皇后</span><br><span class="line"> * @param row</span><br><span class="line"> * @param col</span><br><span class="line"> * @param tmp</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static boolean check(int row, int col,int[][] tmp) &#123;</span><br><span class="line">//上面</span><br><span class="line">for(int i = row-1; i&gt;=0; i--) &#123;</span><br><span class="line">if(tmp[i][col] == 1) &#123;</span><br><span class="line">return false;//不可以放皇后</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//左上（行减小，列减小）</span><br><span class="line">for(int i = row-1,j = col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--) &#123;</span><br><span class="line">if(tmp[i][j] == 1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//右上（行减小，列增大）</span><br><span class="line">for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;8;i--,j++) &#123;</span><br><span class="line">if(tmp[i][j] == 1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 打印棋盘</span><br><span class="line"> */</span><br><span class="line">private static void show(int[][] tmp) &#123;</span><br><span class="line">System.out.println(&quot;第&quot;+count+&quot;种摆放方式&quot;);</span><br><span class="line">for(int i=0;i&lt;8;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;8;j++) &#123;</span><br><span class="line">System.out.print(tmp[i][j]+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列1</title>
      <link href="/2019/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%971/"/>
      <url>/2019/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%971/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>又名堆栈。先进后出（Last in first out,LIFO）的线性表，要求只在&#160;<em>表尾</em>&#160;进行删除和插入操作，只移动栈顶指针，不允许改变栈底指针。<br><a id="more"></a><br>注意：</p><ul><li>一定要判断栈是否满，是否空</li><li>建表时，要考虑栈数据的类型，可能会有多种数据类型<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="顺序栈（数组）"><a href="#顺序栈（数组）" class="headerlink" title="顺序栈（数组）"></a>顺序栈（数组）</h3></li></ul><ol><li>基础操作  </li></ol><ul><li>判断栈是否为空</li><li>判断是否栈满，若满，返回false或者增加容量</li><li>栈的大小</li><li>返回栈顶元素</li><li>入栈</li><li>进栈  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Base &#123;</span><br><span class="line">/** 栈大小 */</span><br><span class="line">private int maxSize ; </span><br><span class="line"></span><br><span class="line">/** 栈顶 */</span><br><span class="line">private int top ; </span><br><span class="line"></span><br><span class="line">/** 数据域 */</span><br><span class="line">private ArrayList&lt;Object&gt; data;</span><br><span class="line"></span><br><span class="line">/** 新增容量 */</span><br><span class="line">private static final int INCREAT = 10;</span><br><span class="line">/** </span><br><span class="line"> * 判断是否为Null栈</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top == -1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Base() &#123;</span><br><span class="line">this.maxSize = 0;</span><br><span class="line">this.data = new ArrayList&lt;&gt;();</span><br><span class="line">this.top = -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断是否栈满</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isFill() &#123;</span><br><span class="line">return top &gt;= maxSize-1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈的大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int Size() &#123;</span><br><span class="line">return maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回栈顶元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object top() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return data.get(top--);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 入栈</span><br><span class="line"> * @param n</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public void Push(Object n) &#123;</span><br><span class="line">//栈满,扩大栈</span><br><span class="line">if(isFill()) &#123;</span><br><span class="line">maxSize += INCREAT;//这里用的是集合，可以不用写，但如果用数组，要写的</span><br><span class="line">&#125;</span><br><span class="line">data.add(n);</span><br><span class="line">top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 弹栈</span><br><span class="line"> * @return Object类型，是因为不知道入栈的到底是什么妖魔鬼怪</span><br><span class="line"> */</span><br><span class="line">public Object Pop() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">Base b = new Base();</span><br><span class="line">b.Push(1);</span><br><span class="line">b.Push(&quot;h&quot;);</span><br><span class="line">System.out.println(&quot;栈顶元素：&quot;+b.top());</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+b.Size());</span><br><span class="line">b.Push(&quot;aa&quot;);</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">栈大小：10</span><br><span class="line">出栈：h</span><br><span class="line">出栈：1</span><br><span class="line">出栈：null</span><br><span class="line">出栈：null</span><br><span class="line">出栈：null</span><br></pre></td></tr></table></figure><h2 id="链表栈"><a href="#链表栈" class="headerlink" title="链表栈"></a>链表栈</h2><p>方法一：</p><ul><li>头尾指针</li><li>头指针 == 尾指针 时，链表为空<br><strong>节点类</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** 指针域 */</span><br><span class="line">private Stack top ; </span><br><span class="line"></span><br><span class="line">/** 数据域 */</span><br><span class="line">private Object data;</span><br><span class="line"></span><br><span class="line">public Stack getTop() &#123;</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTop(Stack top) &#123;</span><br><span class="line">this.top = top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setData(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack(Object data) &#123;</span><br><span class="line">super();</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack(Stack top, Object data) &#123;</span><br><span class="line">super();</span><br><span class="line">this.top = top;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.stack;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表栈</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LinkedStack &#123;</span><br><span class="line">/** 栈顶 */</span><br><span class="line">private Stack top ;</span><br><span class="line"></span><br><span class="line">/** 栈底 */</span><br><span class="line">private Stack base;</span><br><span class="line"></span><br><span class="line">/** 栈大小 */</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> */</span><br><span class="line">public LinkedStack() &#123;</span><br><span class="line">super();</span><br><span class="line">this.top = new Stack();</span><br><span class="line">this.base = top;</span><br><span class="line">this.size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int Size() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为空</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top == base ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回栈顶元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object Top() &#123;</span><br><span class="line">return top.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 入栈</span><br><span class="line"> * @param data</span><br><span class="line"> */</span><br><span class="line">public void Push(Object data) &#123;</span><br><span class="line">Stack newStack = new Stack();</span><br><span class="line">newStack.setData(data);</span><br><span class="line">top.setTop(newStack);</span><br><span class="line">top = newStack;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object Pop() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">Object data = top.getData();</span><br><span class="line">size--;</span><br><span class="line">Stack curr = base;</span><br><span class="line">while(curr.getTop() != top) &#123;</span><br><span class="line">curr = curr.getTop();</span><br><span class="line">&#125;</span><br><span class="line">top = curr;</span><br><span class="line">curr.setTop(null);</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LinkedStack ls = new LinkedStack();</span><br><span class="line">ls.Push(1);</span><br><span class="line">ls.Push(2);</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+ls.Size());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">ls.Push(&quot;a&quot;);</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+ls.size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">栈大小：2</span><br><span class="line">出栈：2</span><br><span class="line">出栈：1</span><br><span class="line">出栈：null</span><br><span class="line">出栈：a</span><br><span class="line">栈大小：0</span><br></pre></td></tr></table></figure></p><p>方法二：使用头插法，这样就不需要尾指针（base）</p><h1 id="进制扩展"><a href="#进制扩展" class="headerlink" title="进制扩展"></a>进制扩展</h1><p>二进制：计算机只有高频和低频<br>十进制：人类常用语言<br>八进制：早期计算机系统都是三的倍数，因此较方便<br>十六进制：一个字节=8位，刚好两个十六进制数可以表示完整，节省空间</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>可查看 java.util.Queue接口<br>先进先出(FIFO)，可查看JAVA API,Queue继承了Collection接口<br>队头：删除<br>队尾：插入<br>也就是说，队尾进，队头出<br>分类： 顺序队列，循环队列<br>每种队列都可以用数组和链表实现</p><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.queue;</span><br><span class="line">/**</span><br><span class="line"> * 队列</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class MyQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;T&gt; data = new ArrayList&lt;T&gt;();</span><br><span class="line">private int front;</span><br><span class="line">private int rear;</span><br><span class="line">public MyQueue() &#123;</span><br><span class="line">front = 0;</span><br><span class="line">rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为空</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return front == rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回队列大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int size() &#123;</span><br><span class="line">return rear-front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回队首元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public T getFront() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return data.get(front++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 出队</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public T outQueue() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return getFront();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 入队</span><br><span class="line"> */</span><br><span class="line">public void InQueue(T item) &#123;</span><br><span class="line">data.add(item);</span><br><span class="line">rear++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyQueue&lt;Integer&gt; mq = new MyQueue&lt;Integer&gt;();</span><br><span class="line">mq.InQueue(1);</span><br><span class="line">mq.InQueue(2);</span><br><span class="line">System.out.println(&quot;队头元素：&quot;+mq.outQueue());</span><br><span class="line">System.out.println(&quot;队大小&quot;+mq.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">队头元素：1</span><br><span class="line">队大小2</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">缺点：队列出队后，空间不能再次使用，造成了内存的浪费，因此需要将队列看成是一个环状空间，而循环队列，是需要用循环链表实现的.   </span><br><span class="line"></span><br><span class="line">## 循环队列 ##  </span><br><span class="line">与顺序队列不同的是，不可用front == rear来区分是否队满或队空，需要新建一个布尔变量或者利用公式：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;(rear+1)%n == front</span><br><span class="line"></span><br><span class="line">方法一：</span><br><span class="line">- 设置一个标志位flag，初始化为0</span><br><span class="line">- 入队为1，出队为0</span><br><span class="line">- 队为空：front == rear &amp;&amp; flag == 0</span><br><span class="line">- 队为满：front == rear &amp;&amp; flag == 1    </span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">- 保留一个元素的存储空间</span><br><span class="line">- 队满：(rear+1)%n == front</span><br><span class="line">- 队空：rear == front</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">- 使用一个计数器，计算队中的元素个数</span><br><span class="line">- 队满：count&gt;0 &amp;&amp; front == rear</span><br><span class="line">- 队空：count == 0</span><br><span class="line"></span><br><span class="line">实现（方法二）</span><br></pre></td></tr></table></figure><p>package timejjc.com.queue;<br>/**</p><ul><li>循环队列—需要考虑队满的情况</li><li>@author 梁翠翠<br><em></em>/</li></ul><p>import java.util.ArrayList;</p><p>public class LoopQueue<t> {</t></p><pre><code>private Object[] data;private int rear;private int front;private int maxSize = 10;private static final int INCREAT = 10;//每次增长10空间public LoopQueue(){    this.rear = 0;    this.front = 0;    this.data = new Object[maxSize];}public boolean isEmpty() {    if(rear == front) {        return true;     }    return false;}public boolean isFill() {    if((rear+1)%maxSize == front) {        return true;    }    return false;}/** * 获取队头元素 * @param n */public Object queueFront(Object n ) {    if(isEmpty()) {        return null;    }    return  data[(front+1)%maxSize];}public void enQueue(Object n) {    if(isFill()) {        System.out.println(&quot;Queue is Fill&quot;);    } else {        rear = (rear+1)%maxSize;        data[rear] = n;    }}public Object deQueue(){    if(isEmpty()) {        return null;    }     return queueFront(front);}public static void main(String[] args) {    LoopQueue&lt;Integer&gt; lq = new LoopQueue&lt;Integer&gt;();    lq.enQueue(1);    lq.enQueue(2);    lq.enQueue(3);    lq.enQueue(4);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    System.out.println(lq.deQueue());//1}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>package timejjc.com.queue;<br>/**</p><ul><li>循环队列–集合不需要判断队满，但需要判断是否为空，因为是坟墓</li><li>@author 梁翠翠<br><em></em>/</li></ul><p>import java.util.ArrayList;</p><p>public class LoopQueue<t> {</t></p><pre><code>private ArrayList&lt;T&gt; data = new ArrayList&lt;T&gt;();private int rear;private int front;public LoopQueue(){    this.rear = 0;    this.front = 0;}public boolean isEmpty() {    if(rear == front) {        return true;     }    return false;}/** * 获取队头元素 * @param n */public T queueFront() {    if(isEmpty()) {        return null;    }    T item = data.get(front%data.size());    front = (front+1)%data.size();    return  item;}public void enQueue(T n) {    if(data.size() == 0) {        rear = rear+1;    } else {        rear = (rear+1)%data.size();    }    data.add(n);}public Object deQueue(){    if(isEmpty()) {        return null;    }     return queueFront();}public static void main(String[] args) {    LoopQueue&lt;Integer&gt; lq = new LoopQueue&lt;Integer&gt;();    lq.enQueue(1);    lq.enQueue(2);    lq.enQueue(3);    lq.enQueue(4);    lq.enQueue(5);    lq.enQueue(6);    lq.enQueue(7);    lq.enQueue(8);    lq.enQueue(9);    lq.enQueue(10);    lq.enQueue(11);    lq.enQueue(12);    lq.enQueue(13);    lq.enQueue(14);    System.out.println(lq.deQueue());//1    System.out.println(lq.deQueue());//2    System.out.println(lq.deQueue());//3    System.out.println(lq.deQueue());//4    System.out.println(lq.deQueue());//5    System.out.println(lq.deQueue());//6    System.out.println(lq.deQueue());//7    System.out.println(lq.deQueue());//8}</code></pre><p>}</p><p><code>`</code></p><p>后续更新的话，需要更新链表的实现方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表之循环链表</title>
      <link href="/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="（单）循环链表"><a href="#（单）循环链表" class="headerlink" title="（单）循环链表"></a>（单）循环链表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>最后一个结点的指针域指向头节点，形成一个环<br><a id="more"></a></p><h2 id="约瑟夫-Josephus-环"><a href="#约瑟夫-Josephus-环" class="headerlink" title="约瑟夫(Josephus)环"></a>约瑟夫(Josephus)环</h2><p>&#160;&#160;&#160;&#160;已知n个人（以编号1,2,3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依次规律重复下去，直到圆桌周围的人全部出列，通常我们设置编号0~n-1  </p><p>循环链表解决思路：</p><ul><li>尾节点不指向头节点，找到要出列结点的前一个结点p</li><li>p指向出列结点的下一个结点</li><li>若尾节点指向头节点，此时只剩下一个结点，则直接输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Josphus &#123;</span><br><span class="line"></span><br><span class="line">public static void josphus(LNode head, int m) &#123;</span><br><span class="line">if(head == null) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">System.out.println();</span><br><span class="line">while(tmp.getNext() != tmp) &#123;</span><br><span class="line">for(int i=0;i&lt;m-1;i++) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(tmp.getNext().getData()+&quot; &quot;);</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">&#125;</span><br><span class="line">//最后一个不要忘了输出</span><br><span class="line">System.out.println(tmp.getData());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接两个链表"><a href="#连接两个链表" class="headerlink" title="连接两个链表"></a>连接两个链表</h2><p>题目： 实现将两个线性表（a1,a2,…,an）和（b1,b2,…,bm）连接成一个线性表（a1,…,an,b1,…,bm）的运算<br>更灵活的循环链表：去掉头指针，增加一个尾指针rear<br><img src="/2019/02/02/线性表之循环链表/loopList.PNG" alt="">  </p><p>思路：</p><ul><li>单链表<br>&#160;&#160;&#160;&#160;如果是单链表或头指针表示的单循环表上做这种连接操作，都需要遍历第一个链表，找到结点an，然后将结点b1放到结点an后面，时间复杂度是O（n）  </li><li>循环链表<br>&#160;&#160;&#160;&#160;因为循环链表有尾指针，所以只需要改变尾指针，无需遍历，时间复杂度是O(1)    </li></ul><p><img src="/2019/02/02/线性表之循环链表/loopListDouble。PNG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TwoToOne &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param a 第一个链表的尾指针</span><br><span class="line"> * @param b 第二个链表的尾指针</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static LNode twoOne(LNode a, LNode b) &#123;</span><br><span class="line">LNode tmp = a.getNext();//a的头节点</span><br><span class="line">System.out.println(&quot;aaa&quot;+b.getNext().getNext().getData());</span><br><span class="line">a.setNext(b.getNext().getNext());</span><br><span class="line">b.setNext(tmp);</span><br><span class="line">return tmp;//新链表的头结点位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="判断单链表中是否有环"><a href="#判断单链表中是否有环" class="headerlink" title="判断单链表中是否有环"></a>判断单链表中是否有环</h2><p><strong>所谓有环，不一定是尾节点指向头节点，尾节点可以指向链表中的任意结点</strong><br>方法一：</p><ul><li>使用p,q两个指针，p总是向前走，但q每次都从头开始走</li><li>对于每个结点，看p走的步数是否和q与q一样，不一样代表有环  </li></ul><p>方法二：</p><ul><li>使用p,q两个指针，p每次向前走一步,q每次向前走两步</li><li>若某个时候p == q,则有环  </li></ul><p>我觉得，第一个好理解一点！！！  因为不知道第二种方法的原因</p><h2 id="魔术师发牌问题"><a href="#魔术师发牌问题" class="headerlink" title="魔术师发牌问题"></a>魔术师发牌问题</h2><p>&#160;&#160;&#160;&#160;魔术师利用一副牌中的13张黑牌，预先将他们排好后叠放在一起，牌面朝下。对观众说：“我不看牌，只数数就可以才到每张牌是什么，我大声叔叔，你们听，不信？现场演示。”魔术师将最上面的那张牌数为1，把他翻过来正好是黑桃A，将黑桃A放在桌子上，第二次数1,2..将第一张牌放在这些牌的下面，将第二张牌翻过来，正好是黑桃2，也将他放在桌子上这样一次进行将13张牌全部翻出，准确无误。  </p><p>问题：拍的开始顺序是如何排放的。<br>思路：</p><h2 id="拉丁方阵问题"><a href="#拉丁方阵问题" class="headerlink" title="拉丁方阵问题"></a>拉丁方阵问题</h2><p>&#160;&#160;&#160;&#160;拉丁方阵是一种n x n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列种恰好出现一次。著名数学家和物理学家欧拉使用拉丁字母来作为拉丁方阵里元素的符号。(嗯哼，数独哎)<br>思路：</p><ul><li>第一行打印：1，2,3,…,n</li><li>第二行打印：2,3,…,n,1</li><li>第三行打印：3,…,n,2</li><li>第n行打印：n,1,2,…,n-1</li></ul><h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><p>双向链表：每个数据结点种都有两个指针，分别指向直接后继和直接前驱。<br><img src="/2019/02/02/线性表之循环链表/doubleList.PNG" alt="">    </p><p>双向循环链表：<br><img src="/2019/02/02/线性表之循环链表/doubleLoopList.PNG" alt="">  </p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="/2019/02/02/线性表之循环链表/insertDouble.PNG" alt="">  </p><ul><li>s指向p的next</li><li>s的前驱指向p的前驱</li><li>p指向s的前驱的next</li><li>p指向s的前驱 </li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="/2019/02/02/线性表之循环链表/doubleDelete.PNG" alt="">  </p><p>后续再更代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表(2)</title>
      <link href="/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8-2/"/>
      <url>/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8-2/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;创建单链表的过程是一个动态生成链表的过程，从“空表”的初始状态起，依次遍历各元素结点并逐个插入链表。<br><a id="more"></a><br>思路：  </p><ul><li>声明一个结点p和计数器变量i；</li><li>初始化一空链表L；</li><li>让L的头节点的指针指向NULL，即建立一个带头节点的单链表；</li><li>循环实现后继结点的赋值和插入。  <h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2>始终把新加进的元素放在表头后的第一个位置：  </li><li>新节点的next指向头节点后面；</li><li>表头的next指向新节点。  </li></ul><p>生成的链表中结点的次序和输入的顺序是相反的！ </p><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>始终把新元素放在表尾：</p><ul><li>当前节点指向新节点</li><li>新节点成为当前结点</li><li>三个结点，head,新节点(newNode)，当前结点（cur）  <h1 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h1>从内存中释放<br>思路：</li><li>声明结点p,q</li><li>将第一个结点赋值给p,下一结点赋值给q</li><li>循环执行释放p和将q赋值给p的操作<br>JAVA中，GC释放  </li></ul><h1 id="比较单链表，顺序表"><a href="#比较单链表，顺序表" class="headerlink" title="比较单链表，顺序表"></a>比较单链表，顺序表</h1><p><img src="/2019/02/02/线性表-2/compare.PNG" alt="">  </p><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>用数组描述的链表 </p><ul><li>包括数据域和游标</li><li>数组的第一个和最后一个元素做特殊处理，data域不存数据</li><li>未使用的数组元素成为备用链表</li><li>数组的第一个元素，即下标为0的哪个元素的游标存放备用链表的第一个结点的下标</li><li>数组的最后一个元素，即下标为MAXSIZE-1的游标存放第一个由数值的元素的下标，相当于头节点  </li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>静态链表是为了给没有指针的变编程语言设计的一种实现单链表功能的方法。</p><p>嘿嘿嘿，不太懂啊</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>题目：快速找到未知长度单链表的中间结点</p><p><strong>方法一</strong></p><ul><li>遍历单链表确定链表长度</li><li>再次从头节点出发循环L/2次找到单链表的中间结点 </li><li>复杂度O(L+L/2) = O(3L/2)     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode minBase(LNode head) &#123;</span><br><span class="line">int size = 0;</span><br><span class="line">LNode p = head;</span><br><span class="line">while(p.getNext() != null) &#123;</span><br><span class="line">p = p.getNext();</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0; i&lt;size/2; i++) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法二</strong><br>快慢指针  </p><ul><li>设置两个指针 search,mid都指向单链表的头节点，其中search的移动速度是mid的2倍，当search指向末尾结点的时候，min正好就在中间了，即标尺的思想。  </li><li>算法复杂度O(L/2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode midD(LNode head) &#123;</span><br><span class="line">LNode search = head;</span><br><span class="line">LNode mid = head;</span><br><span class="line">while(search.getNext() != null) &#123;</span><br><span class="line">if(search.getNext().getNext() != null) &#123;</span><br><span class="line">search = search.getNext().getNext();</span><br><span class="line">mid = mid.getNext();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">search = search.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>题目:写一个完整的程序，实现随机生成20个元素的链表，查找中间节点的值并显示<br>这里展示的代码只是随机生成20个元素的链表，再结合前面的代码就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestMain &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode();</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line">LNode tmp = new LNode(new Random().nextInt(100)+1);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表（List）之增删改查</title>
      <link href="/2019/02/01/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2019/02/01/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;由0或多个数据元素组成的有限个序列，为0时，是空表<br><a id="more"></a></p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>&#160;&#160;&#160;&#160;第一个元素无前驱，最后一个元素无后继，其他元素都<strong><em>有且只有</em></strong>一个前驱和后继。线性关系是不允许有第三者的！！！   </p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>&#160;&#160;&#160;&#160;一组性质相同的值的集合及定义在此集合上的一些操作的总称<br>&#160;&#160;&#160;&#160;JAVA中数据类型分为两种：  </p><ul><li><p>基本数据（原子）类型：不可再分<br><img src="/2019/02/01/线性表/type_base.png" alt="">  </p></li><li><p>引用数据类型<br>&#160;&#160;&#160;&#160;类、接口、数组<br>&#160;&#160;&#160;&#160;很重要！！！，否则无法理解“指针”操作</p></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li>求元素个数</li><li>插入</li><li>删除</li><li>查找</li><li>判断是否为空  </li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>&#160;&#160;&#160;&#160;顺序存储和链表存储  </p><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>&#160;&#160;&#160;&#160;栈内存是顺序结构的<br>&#160;&#160;&#160;&#160;用一段地址连续的存储单元依次存储线性表的数据元素<br>需要封装的属性（3）：</p><ul><li>起始位置</li><li>最大存储容量</li><li>当前长度<br><strong><em><font color="red">注意：线性表的首地址为：1</font></em></strong>    </li></ul><p>时间复杂度</p><ol><li>删除/插入<br>最好情况：不移动元素&#160;O(1)<br>最坏情况:移动n个元素&#160;O(n)<br>平均情况:O((n-1)/2),&#160;即&#160;O(n)   </li></ol><p>&#160;&#160;2.存、取<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;都为&#160;O(1)  </p><p>优点  </p><ol><li>不需要为表中元素之间的逻辑关系增加额外的存储空间 </li><li>快速存取表中任意位置的元素……谁让人家是顺序的呢，嘿嘿嘿  </li></ol><p>缺点  </p><ol><li>插入和删除太慢了，除非数据特别少，否则不要用啊！！！</li><li>若线性表的长度变化较大（大量的插入和删除） ，无法确定存储空格键的容量啊</li><li>存储空间碎片化，毕竟人家存储空间的分配是一整块来着的呀，当一大块空间剩下一小块时，而这一小块空间又不够我们用的，那就只能浪费掉，然后再次申请一大块空间，两个大块之间的小块就属于“碎片”啦  </li></ol><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>位置是随意的哦，但是要求存元素本身及其后继指针  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据域<br>存储数据元素信息的域  </li><li>指针域<br>存储后继位置的域  </li><li>指针<br>指针域中存储的信息  </li><li>结点(存储映像)<br>数据域 + 指针域    <h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><img src="/2019/02/01/线性表/LNode.png" alt="">  </li></ul><h4 id="头指针-头节点-首元节点"><a href="#头指针-头节点-首元节点" class="headerlink" title="头指针/头节点/首元节点"></a>头指针/头节点/首元节点</h4><ul><li>头指针<br>指链表指向的第一个结点的指针，若链表有头结点，则是指向头结点的指针。<br>单链表可由一个头指针唯一确定（标识）</li><li>元首结点<br>指链表中存储第一个元素的结点</li><li>头结点<br>在链表的首元结点之前附设的一个节点，数据域内存放的是空表标志和表长等信息<br><img src="/2019/02/01/线性表/node.png" alt="">  </li></ul><p>&#160;&#160;&#160;&#160;<strong> 无论链表是否为空，头指针均不为 </strong>，人家是唯一标识啊😏     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><ul><li>获得链表第i个数据<br>&#160;1. 声明一个结点p指向链表第一个结点，初始化&#160;j&#160;从1开始<br>&#160;2. 当j&lt;i时，遍历链表，p指针后移，j++;<br>&#160;3. 若循环到末尾p为空，则不存在第i个元素<br>&#160;4. 否则查找成功，返回结点p的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GetIData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode IData(LNode head,int i) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">while(head != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否遍历完整个链表</span><br><span class="line">if(head == null || j&lt;i)</span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160;&#160;&#160;&#160;单链表的循环，建议使用while,因为并不知道单链表的长度</p><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><ul><li>在第i个数据插入结点<br>&#160;1. 新节点指向当前结点的后继<br>&#160;2. 当前结点指向新节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsertData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode insert(LNode head, int i, int newData) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">while (tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">//new一个空结点p</span><br><span class="line">LNode p = new LNode(0);</span><br><span class="line">&lt;font color=red&gt;p.setData(newData);&lt;/font&gt;</span><br><span class="line">//p指向head后继:p.next = head.next</span><br><span class="line">p.setNext(tmp.getNext());</span><br><span class="line">//head指向p:head.next = p;</span><br><span class="line">tmp.setNext(p);</span><br><span class="line">return head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的时head.getNext()是因为，在定义head时，为：</p><blockquote><p>LNode head = new LNode(0);<br>这时head是有头节点的   </p></blockquote><p><img src="/2019/02/01/线性表/head.png" alt="">  </p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>&#160;1. 找到要删除结点的前驱结点（j=1开始）<br>&#160;2. 前驱结点直接指向要删除结点的后继结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DeleteNode &#123;</span><br><span class="line"></span><br><span class="line">public static LNode deleteINode(LNode node, int i) &#123;</span><br><span class="line">int j = 1;</span><br><span class="line">LNode tmp = node;</span><br><span class="line">while(tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">return node.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度与空间复杂度</title>
      <link href="/2019/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2019/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>分类：时间复杂度&#160;和&#160;空间复杂度<br>指在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和空间资源。<br><a id="more"></a><br>方法：</p><ul><li>事前分析估算法（渐进复杂度)<br>&#160;常用的算法，依据统计方法对算法进行估算</li><li>事后统计法<br>&#160;&#160;&#160;&#160;通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。<br>&#160;&#160;&#160;&#160;但是需要花费大量的时间和经历，若测试发现算法不可取，则损失重大。   </li></ul><p>算法效率的度量因素：  </p><ol><li>算法采用的策略、方案</li><li>编译产生的代码质量</li><li>问题的输入规模（输入量）</li><li>及其执行指令的速度<br>&#160;<strong><em>一个程序的运行时间依赖于算法的好坏和问题的输入规模。</em></strong>   </li></ol><p>函数的渐近增长：<br>判断一个算法的效率时，函数中的尝试和其他次要项可忽略，关注的应该是最高项的阶数。 </p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>官方定义：</strong><br>&#160;&#160;&#160;&#160;在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。<br>&#160;&#160;&#160;&#160;算法的时间复杂度，也就是算法的时间量度，记作：<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T(n) = O(f(n))<br>&#160;&#160;表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>，其中f(n)是问题规模n的某个函数<br>比较：<br><img src="/2019/02/01/时间复杂度与空间复杂度/timeComplexity.png" alt="">   </p><p>时间复杂度所消耗的时间从小到大依次为:<br>O(1) &lt; O(lon(n)) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)    </p><h3 id="最坏情况和平均情况"><a href="#最坏情况和平均情况" class="headerlink" title="最坏情况和平均情况"></a>最坏情况和平均情况</h3><ul><li>最坏运行时间<br>&#160;&#160;&#160;&#160;一个算法有最好的情况和最坏的情况。在应用中，这是一个最重要的需求，除了特别指定，我们所提到的运行时间都是最坏情况的运行时间。  </li><li>平均运行时间<br>&#160;&#160;&#160;&#160;期望的运行时间     <h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2>通过计算算法所需要的存储空间实现的，计算公式为:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S(n) = O(f(n));<br>&#160;&#160;&#160;&#160;其中f(n)是关于问题规模n所占存储空间的函数。<br>是对一个算法在运行过程中临时占用存储空间大小的度量</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之链表逆序</title>
      <link href="/2019/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F/"/>
      <url>/2019/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>有一链表，链表数据为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 </li><li>使其逆序，数据为：7 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1  </li></ul><a id="more"></a><h3 id="解决方法（3种）"><a href="#解决方法（3种）" class="headerlink" title="解决方法（3种）"></a>解决方法（3种）</h3><h5 id="1-就地逆序"><a href="#1-就地逆序" class="headerlink" title="1.就地逆序"></a>1.就地逆序</h5><ul><li>新增一节点的指针域，用于存储当前节点的后继节点 </li><li>需要当前节点，前驱节点</li><li>遍历链表，直到最后一个节点  </li></ul><p><strong>节点类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表节点类</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <strong>测试类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基础的链表反转</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Reverse &#123;</span><br><span class="line">/**</span><br><span class="line"> * 直接反转节点指向</span><br><span class="line"> * @param head 头节点</span><br><span class="line"> * @return 逆序后的链表</span><br><span class="line"> */</span><br><span class="line">public static LNode Reverse_base(LNode head) &#123;</span><br><span class="line">//没有节点或只有一个节点则直接返回</span><br><span class="line">if(head == null || head.getNext() == null)</span><br><span class="line">return head;</span><br><span class="line">//前驱节点</span><br><span class="line">LNode pre = null;</span><br><span class="line">//下一节点</span><br><span class="line">LNode next = null;</span><br><span class="line">//当前节点</span><br><span class="line">LNode cur = head;</span><br><span class="line">//循环链表</span><br><span class="line">while(cur != null) &#123;</span><br><span class="line">//next存储当前节点的后继节点，以免丢失</span><br><span class="line">next = cur.getNext();</span><br><span class="line">//当前节点指向下一节点</span><br><span class="line">cur.setNext(pre);</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">return pre;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode(0);</span><br><span class="line">//LNode tail = new LNode(0);</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=1; i&lt;8; i++) &#123;</span><br><span class="line">LNode tmp = new LNode(i);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">LNode lNode = Reverse_base(head);</span><br><span class="line">System.out.println(&quot;逆序链表&quot;);</span><br><span class="line">while(lNode.getNext() != null) &#123;</span><br><span class="line">System.out.print(lNode.getData()+&quot; &quot;);</span><br><span class="line">lNode = lNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是所有的代码<br>在逆序前，存值到链表中：<br><img src="/2019/01/30/数据结构与算法之逆序/variables_head.png" alt="">  </p><p>逆序后，链表pre   </p><p><img src="/2019/01/30/数据结构与算法之逆序/variables_pre.png" alt="">   </p><p>由于第一次使用Markdown pad2  之后会不断优化<br>解法有3种，后续会更新</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/24/hello-world/"/>
      <url>/2019/01/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
