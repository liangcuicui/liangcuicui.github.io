<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="CC">



<meta name="description" content="1.两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。">
<meta name="keywords" content="算法题">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode">
<meta property="og:url" content="http://yoursite.com/2019/02/14/leetcode/index.html">
<meta property="og:site_name" content="TimeJjc&#39;s Blog">
<meta property="og:description" content="1.两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-06T06:57:32.813Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode">
<meta name="twitter:description" content="1.两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="TimeJjc&#39;s Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/bitbug_favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>leetcode | TimeJjc&#39;s Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">CC</a></h1>
        </hgroup>

        
        <p class="header-subtitle">新的开始,加油哦</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false">
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:981192445@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/liangcuicui" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" href="https://blog.csdn.net/TimeJjc" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图/">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务器/">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法题/">算法题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">你想知道啥呢</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">CC</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">CC</a></h1>
            </hgroup>
            
            <p class="header-subtitle">新的开始,加油哦</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:981192445@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/liangcuicui" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/TimeJjc" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap"><article id="post-leetcode" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/14/leetcode/" class="article-date">
      <time datetime="2019-02-14T02:23:04.000Z" itemprop="datePublished">2019-02-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      leetcode
    </h1>
  

		
		   <div style="margin-top:10px;">
    <span class="post-time">
      <span class="post-meta-item-icon">
        <i class="fa fa-keyboard-o"></i>
        <span class="post-meta-item-text">  字数统计: </span>
        <span class="post-count">8.4k字</span>
      </span>
    </span>

    <span class="post-time">
      &nbsp; | &nbsp;
      <span class="post-meta-item-icon">
        <i class="fa fa-hourglass-half"></i>
        <span class="post-meta-item-text">  阅读时长: </span>
        <span class="post-count">39分</span>
      </span>
    </span>
</div>
        
      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法题/">算法题</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                if(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    arr[0] = i;</span><br><span class="line">                    arr[1] = j;</span><br><span class="line">                    return arr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时间58ms，属于暴力解法了，击败24.62%的用户，太菜了  </p>
<ul>
<li>利用hashmap的动态分配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++) &#123;</span><br><span class="line">    	   if(map.containsKey(target-nums[i])) &#123;</span><br><span class="line">    		   arr[0] = map.get(target-nums[i]);</span><br><span class="line">    		   arr[1] = i;</span><br><span class="line">    		   return arr;</span><br><span class="line">    	   &#125;else &#123;</span><br><span class="line">    		   map.put( nums[i],i);</span><br><span class="line">    	   &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时间8ms,击败87.66%的用户</p>
<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><blockquote>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
</blockquote>
<blockquote>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<blockquote>
<p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode newNode = new ListNode(0);</span><br><span class="line">       ListNode cur = newNode;</span><br><span class="line">        int carry = 0;//进位</span><br><span class="line">        while(l1 !=null || l2 != null)&#123;</span><br><span class="line">            int val1 = (l1 != null)? l1.val : 0;</span><br><span class="line">            int val2 = (l2 != null)? l2.val : 0;</span><br><span class="line">            int num = carry+val1+val2;</span><br><span class="line">            carry = num/10;</span><br><span class="line">            //这里如果用cur.val = num%10;</span><br><span class="line">            //就需要cur.next = new ListNode(0);</span><br><span class="line">            //反正每次结点都需要new</span><br><span class="line">	        cur.next = new ListNode(num%10);</span><br><span class="line">	        cur = cur.next;</span><br><span class="line">            if(l1 != null)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 != null)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry&gt;0)//最后如果还有进位</span><br><span class="line">            cur.next = new ListNode(carry);</span><br><span class="line">        return newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时间68ms,击败19.44%的用户<br>算是最直接（笨）的写法了，看来还要优化  </p>
<h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h1><blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
</blockquote>
<p>示例 1:  </p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p>示例 2:  </p>
<blockquote>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。  </p>
</blockquote>
<pre><code>请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">		int result = 0;</span><br><span class="line">		int length = s.length();</span><br><span class="line">		int i=0,j=0;</span><br><span class="line">		//也可以用指针</span><br><span class="line">		while(i&lt;length &amp;&amp; j&lt;length) &#123;</span><br><span class="line">			if(set.contains(s.charAt(j))) &#123;</span><br><span class="line">				//删掉最先出现的那个重复的</span><br><span class="line">				set.remove(s.charAt(i++));</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				set.add(s.charAt(j++));</span><br><span class="line">				//关键的一步</span><br><span class="line">				result = Math.max(result, j-i);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是官方示例，关键在于对result求最大值，我之前的算法总是不能概括所有情况，后续会更新这道题（链表的形式）</p>
<h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4.寻找两个有序数组的中位数"></a>4.寻找两个有序数组的中位数</h1><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p>示例 1:</p>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0<br>示例 2:</p>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">		//1.需要合并两个数组,并排序</span><br><span class="line">		List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		for(int i=0; i&lt;nums1.length;i++) &#123;</span><br><span class="line">			list.add(nums1[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=0; j&lt;nums2.length; j++) &#123;</span><br><span class="line">			list.add(nums2[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.sort(list, null);</span><br><span class="line">		//2.分奇偶</span><br><span class="line">		int length = list.size();</span><br><span class="line">		if(length%2 != 0) &#123;</span><br><span class="line">			int result = list.get(length/2);</span><br><span class="line">			return (double)result;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			</span><br><span class="line">			return (double)(list.get(length/2)+list.get(length/2-1))/2;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行用时94ms，击败12.56%的用户<br>内存消耗50.8MB，击败30.27%的用户</p>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><p>第一：错误示范，字符串特别长是，超时,答案是对的，但是过于暴力，不符合时间要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 最长回文子串</span><br><span class="line">	 * @param s</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static String longestPalindrome(String s) &#123;</span><br><span class="line">		//最暴力的方法：1找出所有子串</span><br><span class="line">		List&lt;String&gt; list = substringAll(s);</span><br><span class="line">		//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line">		String result = &quot;&quot;;</span><br><span class="line">		if(s.length() == 0) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		if(s.length()&gt;0) &#123;</span><br><span class="line">			result = s.substring(0, 1);</span><br><span class="line">		&#125;</span><br><span class="line">		while(list.size()&gt;0)&#123;</span><br><span class="line">			String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">			String tmp = list.get(0);</span><br><span class="line">			for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">				if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">					list.remove(0);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(list.size()&gt;0 &amp;&amp; list.get(0).equals(tmp)) &#123;</span><br><span class="line">				if( list.get(0).length()&gt;result.length()) &#123;</span><br><span class="line">					result = list.get(0);</span><br><span class="line">					list.remove(0);</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					list.remove(0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">	return result;</span><br><span class="line">    &#125;</span><br><span class="line">	public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">			for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">				String str = s.substring(i, j);</span><br><span class="line">				if(str.length()&gt;1  ) &#123;</span><br><span class="line">					list.add(str);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Scanner scan = new Scanner(System.in);</span><br><span class="line">		String str = scan.nextLine();</span><br><span class="line">		scan.close();</span><br><span class="line">		System.out.println(longestPalindrome(str));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：稍微改进了一点，但是还是超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //最暴力的方法：1找出所有子串</span><br><span class="line">		if(s.length() == 0) &#123;</span><br><span class="line">			return &quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		String result = &quot;&quot;;</span><br><span class="line">		if(s.length()&gt;0) &#123;</span><br><span class="line">			result = s.substring(0, 1);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; list = substringAll(s);</span><br><span class="line">		//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line">		</span><br><span class="line">		while(list.size()&gt;0)&#123;</span><br><span class="line">			/*String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">			String tmp = list.get(0);</span><br><span class="line">			for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">				if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">					list.remove(0);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;*/</span><br><span class="line">				if( list.get(0).length()&gt;result.length()) </span><br><span class="line">					result = list.get(0);</span><br><span class="line">					list.remove(0);</span><br><span class="line">		&#125;</span><br><span class="line">		//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">	return result;</span><br><span class="line">    &#125;</span><br><span class="line">	public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">		List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">			for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">				String str = s.substring(i, j);</span><br><span class="line">				//是回文</span><br><span class="line">				if(str.length()&gt;1 &amp;&amp; new StringBuffer(str).reverse().toString().equals(str)) &#123;</span><br><span class="line">					if(list.size()== 0 || !list.get(list.size()-1).contains(str))</span><br><span class="line">						list.add(str);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行用时10578ms，击败了0.98%的用户<br>内存消耗380MB，击败了0.97%得用户—-真可怕</p>
<h1 id="6-Z-N-字形变换"><a href="#6-Z-N-字形变换" class="headerlink" title="6. Z(N)字形变换"></a>6. Z(N)字形变换</h1><blockquote>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
</blockquote>
<blockquote>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L&#160;&#160;&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I   &#160;&#160;&#160;&#160;&#160;R<br>E &#160;T &#160;O&#160;&#160;E&#160;&#160;S&#160;&#160;&#160;I&#160;&#160;  I&#160;&#160;&#160;&#160;G<br>E&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;H   &#160;&#160;&#160;&#160;&#160;N          </p>
</blockquote>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<blockquote>
<p>string convert(string s, int numRows);  </p>
</blockquote>
<p>示例 1:</p>
<blockquote>
<p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”  </p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;R<br>E&#160;&#160;&#160;&#160;&#160;&#160;&#160;O&#160;&#160;&#160;E&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;I<br>E&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;&#160;&#160;H&#160;&#160;&#160;&#160;&#160;&#160;N<br>T&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 7.整数反转 #</span><br><span class="line">给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> 示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>    public int reverse(int x) {<br>        int rev = 0;<br>            while (x != 0) {<br>                int pop = x % 10;<br>                x /= 10;<br>                if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return 0;<br>                if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return 0;<br>                rev = rev * 10 + pop;<br>            }<br>            return rev;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">执行用时43ms,击败了64.62%的用户  </span><br><span class="line">内存消耗32.6MB,击败了43.26%的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 8.字符串转换整数 #</span><br><span class="line">这道题怎么说，我完全就是暴力求解，然后，，，，限制条件太多， 我提交了8次才对！  </span><br><span class="line"></span><br><span class="line">请你来实现一个 atoi 函数，使其能将字符串转换成整数。  </span><br><span class="line"></span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。  </span><br><span class="line"></span><br><span class="line">当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。  </span><br><span class="line"></span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。  </span><br><span class="line"></span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。  </span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。  </span><br><span class="line"></span><br><span class="line">说明：  </span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。  </span><br><span class="line"></span><br><span class="line">示例 1:  </span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;42&quot;  </span><br><span class="line">输出: 42 </span><br><span class="line"> </span><br><span class="line">示例 2:  </span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;   -42&quot;  </span><br><span class="line">输出: -42  </span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。  </span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。  </span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;4193 with words&quot;  </span><br><span class="line">输出: 4193  </span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。  </span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;words and 987&quot;  </span><br><span class="line">输出: 0  </span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。  </span><br><span class="line">     因此无法执行有效的转换。  </span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;-91283472332&quot;  </span><br><span class="line">输出: -2147483648  </span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。   </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></p>
<p> public static  int myAtoi(String str) {<br>         String trim = str.trim();<br>         if(str.length() == 0 || trim.length() == 0) {<br>             return 0;<br>         }<br>         int indexOf = trim.indexOf(“ “);<br>         Integer result = 0;<br>         if(indexOf != -1) {//存在空格<br>             result= getNumber(trim, indexOf);<br>         } else {<br>             result = getNumber(trim, trim.length());<br>         }<br>         return result;<br>     }<br>     private static int getNumber(String trim, int indexOf) {<br>         StringBuffer buffer = new StringBuffer();<br>         int sign = 1;<br>         boolean  flag = false; //判断是否有符号<br>         if(trim.charAt(0) == ‘-‘ ){<br>             sign = -1;<br>             flag = false;<br>         } else if(trim.charAt(0) == ‘+’ ) {<br>             sign = 1;<br>             flag = true;<br>         } else if(trim.charAt(0)&gt;=’0’ &amp;&amp; trim.charAt(0)&lt;=’9’) {<br>             if(trim.charAt(0)&gt;’0’ &amp;&amp; trim.charAt(0)&lt;=’9’) {<br>                 buffer.append(trim.charAt(0));<br>                 flag = true;<br>             }</p>
<pre><code>     }else {
         return 0;
     }
     char[] charArray = trim.toCharArray();
     for(int i=1;i&lt; charArray.length;i++) {
         if(charArray[i]&gt;=&apos;0&apos; &amp;&amp; charArray[i]&lt;=&apos;9&apos;) {
             if(charArray[i] == &apos;0&apos;) {
                 if(buffer.length()&gt;0 &amp;&amp; buffer.charAt(0)&gt;&apos;0&apos;) {
                     buffer.append(charArray[i]);
                 }
             }else {
                 buffer.append(charArray[i]);
             }

         }else {
             break;
         }
     }

     if(buffer.length()&gt;10) {
         if(flag) {
             return Integer.MAX_VALUE;
         }else {
             return Integer.MIN_VALUE;
         }
     }
     if(buffer.length() == 0) {
         return 0;
     }
     if(buffer.length() == 10) {
        String str = new String(buffer);
        Integer consult = Integer.valueOf(str.substring(0, 9));
        Integer residue = Integer.valueOf(str.substring(9, 10));
        System.out.println(consult);
        System.out.println(residue);
         if(consult&gt;Integer.MAX_VALUE/10) {
             if(flag) {
                 return Integer.MAX_VALUE;
             } else {
                 return Integer.MIN_VALUE;
             }
         }else if(consult == Integer.MAX_VALUE/10) {
             if(residue &lt;= Integer.MAX_VALUE%10) {
                 System.out.println(Integer.valueOf(new String(buffer))*sign);
                 return Integer.valueOf(new String(buffer))*sign;
             } else {
                 if(flag) {
                     return Integer.MAX_VALUE;
                 } else {
                     return Integer.MIN_VALUE;
                 }
             }
         } else {
             return Integer.valueOf(new String(buffer))*sign;
         }
     }
    return Integer.valueOf(new String(buffer))*sign;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">执行用时 50ms,击败了40.37%的用户  </span><br><span class="line">内存消耗47.9MB  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 9. 回文数 #</span><br><span class="line">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p> public boolean isPalindrome(int x) {<br>        if(x&lt;0)<br>            return false;<br>        boolean rlt = false;<br>        int rev = 0;<br>        int n = x;<br>        while (n != 0) {<br>            int pop = n % 10;<br>            n /= 10;<br>            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return false;<br>            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return false;<br>            rev = rev * 10 + pop;<br>        }<br>        if(rev == x)<br>            rlt = true;<br>        return rlt;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时146ms，击败了81.29%的用户  </span><br><span class="line">内存消耗：30.3MB，击败了63.98%的用户  </span><br><span class="line"></span><br><span class="line">emmmmm,最快的一次了</span><br><span class="line"></span><br><span class="line"># 11.盛最多水的容器 #</span><br><span class="line"></span><br><span class="line">&gt;给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">&gt;说明：你不能倾斜容器，且 n 的值至少为 2。</span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [1,8,6,2,5,4,8,3,7]  </span><br><span class="line">输出: 49</span><br><span class="line"></span><br><span class="line">暴力解</span><br></pre></td></tr></table></figure></p>
<p>public int maxArea(int[] height) {<br>        int max = 0;<br>        for(int i=0;i&lt;height.length;i++) {<br>            for(int j=i+1;j&lt;height.length;j++) {</p>
<pre><code>            int num = Math.min(height[i], height[j])*(j-i);
            max = max&lt;num ? num:max;
        }
    }
     return max;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时402ms,击败了22.18%的用户  </span><br><span class="line">内存消耗47.8MB，击败了0.96%的用户</span><br><span class="line"></span><br><span class="line">方法二：双指针法（官方题解）  </span><br><span class="line">思想：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;两线段之间形成的区域总是会受到其中较短那条长度的限制，此外，线段距离越远，得到的面积越大   </span><br><span class="line">分析：</span><br><span class="line">- 两个指针，一个指向头， 一个指向尾  </span><br><span class="line">- 每一步中，比较max，且较短线段的指针向较长线段指针的一侧移动。</span><br></pre></td></tr></table></figure>
<p> public int maxArea(int[] height) {<br>       int max = 0;<br>        int i=0;<br>        int j = height.length-1;<br>        while(i&lt;j) {<br>            max = Math.max(max, Math.min(height[i], height[j])*(j-i));<br>            if(height[i]&gt;height[j]) {<br>                j–;<br>            } else {<br>                i++;<br>            }<br>        }<br>         return max;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">执行用时：10ms,击败了64.19%的用户  </span><br><span class="line">内存消耗47.1MB,击败了0.96%的用户 </span><br><span class="line"></span><br><span class="line"># 13.罗马数字转整数 #</span><br><span class="line">问题</span><br><span class="line">&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。  </span><br><span class="line">字符          数值  </span><br><span class="line">I             1  </span><br><span class="line">V             5  </span><br><span class="line">X             10  </span><br><span class="line">L             50  </span><br><span class="line">C             100  </span><br><span class="line">D             500  </span><br><span class="line">M             1000  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">&gt;   通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。   </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。  </span><br><span class="line"></span><br><span class="line">给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。  </span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">输入: &quot;III&quot;  </span><br><span class="line">输出: 3  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:  </span><br><span class="line">输入: &quot;IV&quot;  </span><br><span class="line">输出: 4  </span><br><span class="line"></span><br><span class="line">&gt;示例 3:  </span><br><span class="line">输入: &quot;IX&quot;  </span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p>
<pre><code>public static int romanToInt(String s) {
    int num = 0;
    for(int i=0;i&lt;s.length();i++) {
        char charAt = s.charAt(i);
        switch(charAt) {
        case &apos;I&apos;:    num += 1;    break;
        case &apos;V&apos;:    num += 5;    break;
        case &apos;X&apos;:    num += 10;    break;
        case &apos;L&apos;:   num += 50;    break;
        case &apos;C&apos;:    num += 100;    break;
        case &apos;D&apos;:    num += 500;    break;
        case &apos;M&apos;:    num += 1000;    break;
        default:    break;
        }
        //六种特殊情况
        if(i != 0) {
            if(( s.charAt(i) == &apos;V&apos; || s.charAt(i) == &apos;X&apos;) &amp;&amp;s.charAt(i-1) == &apos;I&apos; ) {
                num -= 1*2; //*2是因为（i-1）的值之前加了一遍
            }
            if(( s.charAt(i) == &apos;L&apos; || s.charAt(i) == &apos;C&apos;) &amp;&amp;s.charAt(i-1) == &apos;X&apos; ) {
                num -= 10*2;
            }
            if(( s.charAt(i) == &apos;D&apos; || s.charAt(i) == &apos;M&apos;) &amp;&amp;s.charAt(i-1) == &apos;C&apos; ) {
                num -= 100*2;
            }
        }

    }
    return num;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">过于暴力啊  </span><br><span class="line">执行用时：108ms,击败了46.6%的用户  </span><br><span class="line">内存消耗：66MB,击败了0.95%的用户  </span><br><span class="line"></span><br><span class="line"># 14.最长公共前缀 #</span><br><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]  </span><br><span class="line">输出: &quot;fl&quot;  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:</span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]  </span><br><span class="line">输出: &quot;&quot;  </span><br><span class="line">解释: 输入不存在公共前缀。  </span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br><span class="line"></span><br><span class="line">方法1-横向扫描，依次对比每一个字符串</span><br></pre></td></tr></table></figure>
<p>if(strs == null || strs.length == 0) {<br>            return “”;<br>        }<br>        String str = strs[0];<br>        for(int i=1;i&lt;strs.length;i++) {<br>            while(strs[i].indexOf(str) != 0) {<br>                //indexOf对于数组，相同为0，不同为-1<br>                str = str.substring(0, str.length()-1);<br>                if(str.isEmpty()) {<br>                    return “”;<br>                }<br>            }<br>        }<br>        return str;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时10ms,击败了65.5%的用户  </span><br><span class="line">内存消耗38.7MB,击败了1.37%的用户  </span><br><span class="line">方法2- 二分查找法</span><br><span class="line">思想：如果（1-mid）不是所有串的公共前缀，舍弃后半个区间  </span><br><span class="line">否则，再次分割，进行查找</span><br></pre></td></tr></table></figure></p>
<p>public static String longestCommonPrefix(String[] strs) {<br>        if(strs == null || strs.length == 0) {<br>            return “”;<br>        }<br>        //找出最短的那个串<br>        int minLen = Integer.MAX_VALUE;<br>        for (String string : strs) {<br>            minLen = Math.min(minLen, string.length());<br>        }<br>        int low = 1;<br>        int hight = minLen;<br>        while(low&lt;= hight) {<br>            int middle = (low+hight)/2;<br>            if(isLongStr(strs,middle)){<br>                low = middle +1;<br>            }else {<br>                hight = middle-1;<br>            }<br>        }<br>        return strs[0].substring(0, (low+hight)/2);<br>    }</p>
<pre><code>private static boolean isLongStr(String[] strs, int middle) {
    String str1 = strs[0].substring(0, middle);
    for(int i=1;i&lt;strs.length;i++) {
        if(!strs[i].startsWith(str1)) {
            return false;
        }
    }
    return true;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时10ms,击败了65.5%的用户  </span><br><span class="line">内存消耗40.5MB，击败了1.02%的用户  </span><br><span class="line">时间复杂度为O(s*log(n)),s表示字符中字符数量总数，n表示长度为m的相同的字符串</span><br><span class="line"></span><br><span class="line"># 20.有效的括号 #</span><br><span class="line"></span><br><span class="line">给定一个只包括 &apos;(&apos;，&apos;)&apos;，&apos;&#123;&apos;，&apos;&#125;&apos;，&apos;[&apos;，&apos;]&apos; 的字符串，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：  </span><br><span class="line"></span><br><span class="line">左括号必须用相同类型的右括号闭合。  </span><br><span class="line">左括号必须以正确的顺序闭合。  </span><br><span class="line">注意空字符串可被认为是有效字符串。  </span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;()&quot;  </span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;([)]&quot;  </span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>public static  boolean isValid(String s) {<br>        Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;();<br>        map.put(‘)’, ‘(‘);<br>        map.put(‘]’, ‘[‘);<br>        map.put(‘}’, ‘{‘);<br>        if(s == “”) {<br>            return true;<br>        }<br>       Stack<character> stack = new Stack<character>();<br>       for(int i=0;i&lt;s.length();i++) {<br>           // 如果遇到闭括号<br>           if(map.containsKey(s.charAt(i))) {<br>               char ch = stack.isEmpty()?’#’: stack.pop();<br>                //ch和值不相等，说明开括号和闭括号是不匹配的<br>                 if(ch != map.get(s.charAt(i))) {<br>                   return false;<br>               }<br>           }else {<br>               stack.push(s.charAt(i));<br>           }<br>       }</character></character></p>
<pre><code>   return stack.isEmpty();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行用时：14ms,击败了23.95%的用户  </span><br><span class="line">内存消耗：35.7MB，击败了2.27%的用户  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 21.合并两个有序链表 #</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span><br><span class="line"></span><br><span class="line">&gt;示例：  </span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4  </span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>public class ListNode {</li>
<li>int val;</li>
<li>ListNode next;</li>
<li>ListNode(int x) { val = x; }</li>
<li><p>}<br>*/<br>class Solution {<br> public ListNode mergeTwoLists(ListNode l1, ListNode l2) {</p>
<pre><code>ListNode newNode = new ListNode(0);
ListNode cur = newNode;
while(l1 != null &amp;&amp; l2 != null) {
    if(l1.val&lt;l2.val) {
        cur.next = l1;
        cur = cur.next;
        l1 = l1.next;
    }else {
        cur.next = l2;
        cur = cur.next;
        l2 = l2.next;

    }
</code></pre></li>
</ul>
<pre><code>    }
    if(l1 == null ) {
        cur.next = l2;
    }
    if(l2 == null) {
        cur.next = l1;
    }
    return newNode.next;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">执行用时16ms，击败了59.56%的用户</span><br><span class="line">内存消耗42.9MB,击败了0.97%的用户 </span><br><span class="line"></span><br><span class="line"># 26.删除排序数组中的重复项 #</span><br><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。  </span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;给定数组 nums = [1,1,2],  </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [0,0,1,1,1,2,2,3,3,4],  </span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">思路：在看到这道题的时候，首先根据题目意思：有序   </span><br><span class="line">意味着，是递增或者递减的，而且因为是引用，那么删除之后的数组也是有序的</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        if(nums.length&lt;=1){<br>            return nums.length;<br>        }<br>        int count = 0;<br>        for(int i=0;i&lt;nums.length-1;) {<br>             while(nums[i] == nums[i+1] &amp;&amp; i&lt;(nums.length-count-1)) {<br>                 for(int j=i;j&lt;nums.length-1;j++) {<br>                     nums[j] = nums[j+1];<br>                 }<br>                 count++;<br>                 if(nums[i] != nums[i+1]) {<br>                     i = i+1;<br>                 }</p>
<pre><code>         }
         if(nums[i] == nums[nums.length-1]) {
             break;
         }else if(nums[i] != nums[i+1]) {
             i++;
         }
     }
     return (nums.length-count);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不知道是不是几天没碰代码，这道题写的过于暴力：  </span><br><span class="line">执行用时114ms,击败了6.88%的提交记录，  </span><br><span class="line">内存消耗47MB   </span><br><span class="line">估计是这道题最笨的一种解法了</span><br><span class="line"></span><br><span class="line">然后看了一下官方实例，真的是，巧妙了：</span><br></pre></td></tr></table></figure></p>
<p>public int removeDuplicates(int[] nums) {<br>    if (nums.length == 0) return 0;<br>    int i = 0;<br>    for (int j = 1; j &lt; nums.length; j++) {<br>        if (nums[j] != nums[i]) {<br>            i++;<br>            nums[i] = nums[j];<br>        }<br>    }<br>    return i + 1;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">利用了快慢指针的思想,i是慢指针，j是快指针，只要nums[i] == nums[j]就利用j++来跳过重复项</span><br><span class="line"># 27.移除元素 #</span><br><span class="line"></span><br><span class="line">给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。  </span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。  </span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">给定 nums = [3,2,2,3], val = 3,  </span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。  </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:  </span><br><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,  </span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。  </span><br><span class="line">注意这五个元素可为任意顺序。  </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">说明:  </span><br><span class="line"></span><br><span class="line">为什么返回数值是整数，但输出的答案是数组呢?  </span><br><span class="line"></span><br><span class="line">请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。  </span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:  </span><br><span class="line"></span><br><span class="line">&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝  </span><br><span class="line">int len = removeElement(nums, val);  </span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。  </span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。  </span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;  </span><br><span class="line">    print(nums[i]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>public static int removeElement(int[] nums, int val) {<br>        int i=0;<br>        int j=nums.length-1;<br>        int len = 0;<br>        while(i&lt;=j) {<br>            if(nums[i] == val) {<br>                int tmp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = tmp;<br>                j–;<br>            }else {<br>                i++;<br>                ++len;<br>            }<br>        }<br>        return len;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时：9ms,击败了69.33%的用户  </span><br><span class="line">内存消耗：69.6MB,击败了0.97%的用户  </span><br><span class="line"># 28.实现strStr() #</span><br><span class="line">实现 strStr() 函数。</span><br><span class="line"></span><br><span class="line">给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;  </span><br><span class="line">输出: 2  </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;  </span><br><span class="line">输出: -1  </span><br><span class="line"></span><br><span class="line">&gt;当needle为空字符串时，返回0</span><br><span class="line"></span><br><span class="line">实际上就是字符串匹配问题，这里用到了KMP算法</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>    public int strStr(String haystack, String needle) {<br>        if(needle.length() == 0 &amp;&amp; haystack.length() != 0) {<br>             return 0;<br>         }<br>         if(haystack.equals(needle)) {<br>             return 0;<br>         }<br>         int[] next = getNext(needle);<br>         int i=0;<br>         int j=0;<br>         while(i&lt;haystack.length() &amp;&amp; j&lt;needle.length()) {<br>             if(-1 == j || haystack.charAt(i) == needle.charAt(j)) {<br>                 i++;<br>                 j++;<br>             }else {<br>                 j = next[j];<br>             }<br>         }<br>         if(j&gt;= needle.length()) {<br>             return i-j;<br>         }else {<br>             return -1;<br>         }<br>    }<br>    public int[] getNext(String needle) {<br>        int[] next = new int[needle.length()];<br>        next[0] = -1;<br>        int i = 0;<br>        int j = -1;<br>        String[] T = needle.split(“”);<br>        while(i&lt;T.length-1) {<br>                if(-1 == j || T[i].equals(T[j])) {<br>                    i++;<br>                    j++;<br>                    if(T[i] != T[j]) {<br>                        next[i] = j;<br>                    }else {<br>                        next[i] = next[j];<br>                    }<br>                }else {<br>                    j = next[j];<br>                }<br>        }<br>        return next;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时73ms,击败了8.92%的用户  </span><br><span class="line">内存消耗37.5MB,击败了0.93%的用户</span><br><span class="line"></span><br><span class="line">但是不知道为啥，用BF算法竟然要快？？</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>    public int strStr(String haystack, String needle) {<br>        if(needle.length() == 0) {<br>             return 0;<br>         }<br>         if(haystack == needle) {<br>             return 0;<br>         }<br>         String[] S = haystack.split(“”);<br>         String[] T = needle.split(“”);<br>         int i = 0;<br>          int j = 0;<br>          while(i&lt;S.length &amp;&amp; j&lt;T.length) {<br>             if(S[i].equals(T[j])) {<br>                 i++;<br>                 j++;<br>             } else {<br>                 i = i-j+1;<br>                 j = 0;<br>             }<br>             if(j == T.length) {<br>                 return i-T.length;</p>
<pre><code>         } 
      }

     return -1;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时44ms,击败了9.28%的用户 </span><br><span class="line">内存消耗41.8MB</span><br><span class="line"># 42.接雨水 #</span><br><span class="line"></span><br><span class="line">是一道难题，思路难，以下是百度的答案 (思路是百度给的，但是没有看答案哟)</span><br><span class="line">&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line">![](leetcode/接雨水.PNG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]  </span><br><span class="line">输出: 6  </span><br><span class="line">分析：</span><br><span class="line">如果想接到雨水，需要满足的条件是</span><br><span class="line">- height[i-1]&gt;height[i]</span><br><span class="line">- height[i]&lt;height[i+1]  </span><br><span class="line"></span><br><span class="line">假设已知最高点的坐标macIndex及其高度maxValue,考虑从左逐渐靠近最高点，此时，只需考虑第一个条件，因为始终有height[maxIndex]&gt;height[i]   </span><br><span class="line">*局部最高curRoot*</span><br><span class="line">局部最高与其余高度值得差值和即为积水和。  </span><br><span class="line">例如上例；积水和分别为:</span><br><span class="line">&gt;左侧：[0,1,1,2,2,2,2]（左往右）,那么左侧积水和为1+1+2+1 = 5</span><br><span class="line">&gt;右侧:[2,2,2,1]（右往左）,那么左侧积水和为1+1</span><br><span class="line">积水和为：5+1 = 6    </span><br><span class="line">  </span><br><span class="line">方法：</span><br><span class="line">- 遍历整个数组，找最高点  </span><br><span class="line">- 从左向右遍历至最高点坐标，求积水和</span><br><span class="line">- 从右向左遍历至最高点坐标，求积水和</span><br></pre></td></tr></table></figure></p>
<p> /**</p>
<pre><code>  * 接雨水
  * @param height
  * @return
  */
 public static int trap(int[] height) {
     if(height == null || height.length == 0) {
         return 0;
     }
    int max = 0;
    int maxIndex = 0;
   //遍历数组找到最高点
    for(int i=0;i&lt;height.length;i++) {
        if(height[i]&gt;max) {
            maxIndex = i;
            max = height[i];
        }
    }
    int left = 0,right = 0;
    //从左向右遍历至最高点，返回积水和
    if(maxIndex&gt;0) {
        left = countWaterLeft(0, maxIndex, height);
    }
    //从右向左遍历至最高点，返回积水和
    if(maxIndex&lt;height.length-1) {
        right = countWaterRight(maxIndex, height.length-1, height);
    }

    max = left+right;
    return max;
  }

public static int countWaterRight(int maxIndex, int length, int[] height) {
    int res = 0;
    int[] result = new int[length - maxIndex];
    int j=result.length-2;
    //height: 0,1,0,2,1,0,1,3,2,1,2,1
     //result:               [2,2,2,1]
    result[result.length-1] = height[length];
    for(int i=length-1;i&gt;maxIndex;i--) {
        result[j] = Math.max(result[j+1], height[i]);
        res += Math.abs((result[j]-height[i]));
        j--;
    }
    return res;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时24ms,击败了43.90%的用户  </span><br><span class="line">内存消耗453.MB，击败了0.94%的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">来一份网友答案：：</span><br></pre></td></tr></table></figure>
<p>找到三个值，第一是头值，第二是尾值，第三是除去头和尾之外，中间的最大值，如果中间的最大值小于头和尾的最小值，那么直接就可以计算出结果，如大于等于最大值（其实等于也可以直接处理，避免下一次递归，但是我为了懒省事没写。。。），则从中间把它们一分为二，再分别求值加到一起。运行时间11ms,超越100%。<br>class Solution {<br>    public int trap(int[] height) {<br>        if(height.length&lt;3){<br>            return 0;<br>        }<br>        return find(height,0,height.length-1);<br>    }<br>    public int find(int[] height,int start,int end){<br>        if(end-start&lt;2){//递归的终点<br>            return 0;<br>        }<br>        int max=-1,tmp=-1,min_two=Math.min(height[start],height[end]),sum=0;;<br>        for(int i=start+1;i&lt;end;i++){<br>            //这一句写在哪里都行<br>            sum=sum+(min_two-height[i]);<br>            if(height[i]&gt;max){<br>                max=height[i];<br>                tmp=i;<br>            }<br>        }</p>
<pre><code>    if(max&lt;min_two){//上面的加法其实应该在这里，转移到上面和在这里其实都一样
        //sum=sum+(min_two-height[i]);
        return sum;
    }else{//其实这里还可以优化一下当中间的max值等于start或者end的时候，当它等于start,那么直接计算即可，不用进行下一次递归，因为下一次递归会再扫描一遍
        return find(height,start,tmp)+find(height,tmp,end);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 80.删除排序数组中的重复项II #</span><br><span class="line"></span><br><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [1,1,1,2,2,3],  </span><br><span class="line">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [0,0,1,1,1,1,2,3,3],  </span><br><span class="line">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        if(nums.length == 0)<br>            return 0;<br>        int i = 0;<br>         int j = 1;<br>         for(j=1;j&lt;nums.length;j++) {<br>             if(nums[i] != nums[j] ) {<br>                 i++;<br>                 if((j-i)&gt;=1) {<br>                     nums[i+1] = nums[j];<br>                 }</p>
<pre><code>         }
     }
    return i+2;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在做完第26题之后趁热打铁，哈哈哈哈   </span><br><span class="line">执行用时2ms,击败了91.59%的用户  </span><br><span class="line">执行用时38.4MB,击败了0.89%的用户    </span><br><span class="line"></span><br><span class="line">但是看了大神的，啊啊啊，难受：</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        int i = 0;<br>        for (int n : nums)<br>            if (i &lt; 2 || n &gt; nums[i-2])<br>                nums[i++] = n;<br>        return i;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 88.合并两个有序数组 #</span><br><span class="line">给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</span><br><span class="line"></span><br><span class="line">&gt;说明:  </span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n。  </span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入:  </span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3  </span><br><span class="line">nums2 = [2,5,6],       n = 3  </span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 102.二叉树的层次遍历 #</span><br><span class="line">要求，使用迭代的方法  </span><br><span class="line">利用队列先进先出的特点，每次入队一层，出队，再进行下一层</span><br></pre></td></tr></table></figure>
<p>class Solution{<br>    public List&lt;List<integer>&gt; levelOrder(TreeNode root){<br>        List&lt;List<integer>&gt; rlt = new ArrayList&lt;List<integer>&gt;();<br>        if(root != null){<br>            return rlt;<br>        }<br>        Queue<treenode> queue = new LinkedList<treenode>();<br>        queue.offer(root);<br>        while(!quque.isEmpty()){<br>            List<integer> list = new ArrayList<integer>();<br>            int count = queue.size();<br>            while(count&gt;0){<br>                TreeNode node = queue.poll();<br>                list.add(node.val);<br>                if(node.left != null){<br>                    queue.offer(node.left);<br>                }<br>                if(node.right != null){<br>                    queue.offer(node.right);<br>                }<br>            }<br>            rlt.add(list);<br>        }<br>        return rlt;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行用时2ms,击败了68.09%的用户  </span><br><span class="line">内存消耗35.8MB,击败了0.84%的用户</span><br><span class="line"></span><br><span class="line"># 144.二叉树的前序遍历 #</span><br><span class="line">注意，这里因为前序遍历的时候是：根-左-右  </span><br><span class="line">所以遍历的时候，是先右后左</span><br></pre></td></tr></table></figure></integer></integer></treenode></treenode></integer></integer></integer></p>
<p>class Solution{<br>    public List<integer> preorderTraversal(TreeNode root){<br>    List<integer> list = new ArrayList<integer>();<br>    if(root == null)<br>        return list;<br>    }<br>    Stack<treenode> stack = new Stack<treenode>();<br>    stack.push(root);<br>    while(!stack.isEmpty()){<br>        TreeNode node = stack.pop();<br>        list.add(node.val);<br>        if(node.right != null){<br>            stack.push(node.right);<br>        }<br>        if(node.left != null){<br>            stack.push(node.left);<br>        }<br>    }<br>    return list;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行用时1ms,击败了86.31%的用户  </span><br><span class="line">内存消耗33.5MB,击败了0.75%的用户  </span><br><span class="line"># 136.只出现一次的数字#</span><br><span class="line"></span><br><span class="line">利用了异或的原理，1^1 = 0，0^n = n;</span><br></pre></td></tr></table></figure></treenode></treenode></integer></integer></integer></p>
<p>class Solution{<br>    public int singleNumber(int[] nums){<br>        int result = nums[0];<br>        for(int i=1;i&lt;nums.length;i++){<br>            result = nums[i]^result;<br>        }<br>        return result;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行用时1ms,击败了99.44%的用户  </span><br><span class="line">内存消耗38.7MB,击败了0.89%的用户  </span><br><span class="line"></span><br><span class="line"># 344.反转字符串 #</span><br><span class="line">&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。  </span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。  </span><br><span class="line">你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&gt;示例 1：  </span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]  </span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class="line"></span><br><span class="line">&gt;示例 2：  </span><br><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]  </span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>    public void reverseString(char[] s) {<br>        for(int i=0,j = s.length-1;i&lt;j;i++,j–) {<br>            char tmp = s[i];<br>            s[i] = s[j];<br>            s[j] = tmp;<br>        }<br>        for(int i=0;i&lt;s.length;i++) {<br>            System.out.print(s[i]);<br>        }<br>    }<br>}<br><code>`</code><br>执行用时</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/02/14/leetcode/">leetcode</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">CC</a></p>
        <p><span>发布时间:</span>2019-02-14, 10:23:04</p>
        <p><span>最后更新:</span>2019-04-06, 14:57:32</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/02/14/leetcode/" title="leetcode">http://yoursite.com/2019/02/14/leetcode/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2019/02/14/leetcode/　　作者: CC" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/02/15/新年第一周/">
                    新年第一周
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/02/14/树/">
                    树
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-两数之和"><span class="toc-number">1.</span> <span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-两数相加"><span class="toc-number">2.</span> <span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-无重复字符的最长字串"><span class="toc-number">3.</span> <span class="toc-text">3.无重复字符的最长字串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-寻找两个有序数组的中位数"><span class="toc-number">4.</span> <span class="toc-text">4.寻找两个有序数组的中位数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-最长回文子串"><span class="toc-number">5.</span> <span class="toc-text">5.最长回文子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Z-N-字形变换"><span class="toc-number">6.</span> <span class="toc-text">6. Z(N)字形变换</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"leetcode　| TimeJjc's Blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/02/15/新年第一周/" title="上一篇: 新年第一周">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/02/14/树/" title="下一篇: 树">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/27/C-Primer学习之旅/">C++ Primer学习之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/面试/">面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/02/三次握手四次挥手/">三次握手四次挥手</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/树之4个迭代遍历/">树之4个迭代遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/经典排序算法/">经典排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/树之平衡二叉树/">树之平衡二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/树之二叉排序树/">树之二叉排序树</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/图论之关键路径/">图论之关键路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/18/图论之拓扑结构/">图论之拓扑结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/关联分析之Apriori/">关联分析之Apriori</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/来京第一次搬家/">来京第一次搬家</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/正向代理和反向代理/">正向代理和反向代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/图论之最小生成树/">树之最小生成树</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/图论之最短路径/">图论之最短路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/26/图的遍历/">图的遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/21/代码习题/">代码习题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/19/图/">图</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/树之哈夫曼树/">哈夫曼树</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/树之二叉树/">二叉树(Binary Tree)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/15/五个常见算法/">五个常见算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/15/新年第一周/">新年第一周</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/leetcode/">leetcode</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/树/">树</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/12/BF-and-KMP/">BF and KMP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/递归与分治/">递归与分治</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/03/栈和队列1/">栈和队列1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/02/线性表之循环链表/">线性表之循环链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/02/线性表-2/">线性表(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/线性表/">线性表（List）之增删改查</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/时间复杂度与空间复杂度/">时间复杂度与空间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/30/数据结构与算法之逆序/">算法之链表逆序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/24/hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019 CC
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
		
			<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
			<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
			<script type="text/javascript" src="/js/src/fireworks.js"></script>
		
		
		  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
		
    </div>
	<div>
		<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
		<script>
			var now = new Date(); 
			function createtime() { 
				var grt = new Date("2019/01/24 13:27:47");
				now.setTime(now.getTime()+250); 
				days = (now - grt ) / 1000 / 60 / 60 / 24; 
				dnum = Math.floor(days); 
				hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
				if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
				mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
				seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
				snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
				document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 "; 
				document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
			} 
			setInterval("createtime()",250);
		</script>
	</div>
	<div>
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
			<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			<span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span>
		</script>
	</div>

</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 2;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
             tags: ".article-tag a", 
             categories: ".article-category a, a.tag-list-link", 
             articleNav: "#article-nav a, #post-nav-button a", 
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
             menu: ".header-menu a", 
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>