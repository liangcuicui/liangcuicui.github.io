<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimeJjc&#39;s Blog</title>
  
  <subtitle>新的开始,加油哦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-14T06:15:44.592Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode</title>
    <link href="http://yoursite.com/2019/02/14/leetcode/"/>
    <id>http://yoursite.com/2019/02/14/leetcode/</id>
    <published>2019-02-14T02:23:04.000Z</published>
    <updated>2019-02-14T06:15:44.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                if(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    arr[0] = i;</span><br><span class="line">                    arr[1] = j;</span><br><span class="line">                    return arr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行时间58ms，属于暴力解法了，击败24.62%的用户，太菜了  </p><ul><li>利用hashmap的动态分配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++) &#123;</span><br><span class="line">       if(map.containsKey(target-nums[i])) &#123;</span><br><span class="line">       arr[0] = map.get(target-nums[i]);</span><br><span class="line">       arr[1] = i;</span><br><span class="line">       return arr;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">       map.put( nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间8ms,击败87.66%的用户</p><h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p></blockquote><blockquote><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p></blockquote><blockquote><p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode newNode = new ListNode(0);</span><br><span class="line">       ListNode cur = newNode;</span><br><span class="line">        int carry = 0;//进位</span><br><span class="line">        while(l1 !=null || l2 != null)&#123;</span><br><span class="line">            int val1 = (l1 != null)? l1.val : 0;</span><br><span class="line">            int val2 = (l2 != null)? l2.val : 0;</span><br><span class="line">            int num = carry+val1+val2;</span><br><span class="line">            carry = num/10;</span><br><span class="line">            //这里如果用cur.val = num%10;</span><br><span class="line">            //就需要cur.next = new ListNode(0);</span><br><span class="line">            //反正每次结点都需要new</span><br><span class="line">        cur.next = new ListNode(num%10);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">            if(l1 != null)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 != null)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry&gt;0)//最后如果还有进位</span><br><span class="line">            cur.next = new ListNode(carry);</span><br><span class="line">        return newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间68ms,击败19.44%的用户<br>算是最直接的写法了，看来还要优化  </p><h1 id="无重复字符的最长字串"><a href="#无重复字符的最长字串" class="headerlink" title="无重复字符的最长字串"></a>无重复字符的最长字串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><p>示例 1:  </p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:  </p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。  </p></blockquote><pre><code>请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="http://yoursite.com/2019/02/14/%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/14/树/</id>
    <published>2019-02-13T16:57:24.000Z</published>
    <updated>2019-02-13T17:12:53.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是一对多的数据结构<br>树是n个结点的有限集，当n = 0 时称为空树。在任意一棵非空树中：  </p><ul><li>有且仅有一个特定的称为根的结点</li><li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每个集合本身又是一棵树，并称为根的子树(SubTree)   <a id="more"></a><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2></li><li>度<br>结点拥有的子树，树的度是各结点度的最大值  </li></ul><ol><li>度为 0 的结点称为叶节点(leaf)或者终端结点</li><li>度不为0 的结点称为分支结点，或非终端节点，除了根节点外，分支结点也称为内部结点。</li></ol><ul><li>结点的层次(level)  </li></ul><ol><li>结点的层次从根开始定在一起，根为第一层</li><li>双亲在同一层的结点互为堂兄弟</li><li>结点的最大层次称为树的深度(depth)或高度</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;是一对多的数据结构&lt;br&gt;树是n个结点的有限集，当n = 0 时称为空树。在任意一棵非空树中：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有且仅有一个特定的称为根的结点&lt;/li&gt;
&lt;li&gt;当n&amp;gt;1时，其余结点可分为m(m&amp;gt;0)个互不相交的有限集，其中每个集合本身又是一棵树，并称为根的子树(SubTree)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BF and KMP</title>
    <link href="http://yoursite.com/2019/02/12/BF-and-KMP/"/>
    <id>http://yoursite.com/2019/02/12/BF-and-KMP/</id>
    <published>2019-02-12T01:44:52.000Z</published>
    <updated>2019-02-13T16:56:10.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;全称探索与回溯法，是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。<br>&#160;&#160;&#160;&#160;当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择——走不通退一步的技术为回溯法，满足回溯条件的某一个状态的点称为“回溯点” </p><h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><ul><li>针对给定的问题，定义问题的解空间</li><li>确定易于搜索的解空间结构</li><li>以深度优先方式搜索解空间，再广度优先方式搜索</li></ul><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>背包问题，八皇后问题（递归和回溯），多用于树</p><h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;暴风（Brute Force）算法，是普通的模式匹配算法</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>&#160;&#160;&#160;&#160;将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，得到最后的匹配结果，是一个暴力算法。时间复杂度O(M<em>(N-M+1)) = O(M</em>N),其中M&lt;N</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line">/**</span><br><span class="line"> * 暴风算法，简单的模式匹配</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BF &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//主串</span><br><span class="line">String s = &quot;iloveyou&quot;;</span><br><span class="line">String[] S = s.split(&quot;&quot;);</span><br><span class="line">//字串</span><br><span class="line">String t = &quot;loveeee&quot;;</span><br><span class="line">String[] T = t.split(&quot;&quot;);</span><br><span class="line">//从第0位开始匹配</span><br><span class="line">bruteForce(S,T,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void bruteForce(String[] S, String[] T, int pos) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int j = 0;</span><br><span class="line">while(i&lt;S.length &amp;&amp; j&lt;T.length) &#123;</span><br><span class="line">//这里不可以用&quot; == &quot;,我们比较的是内容</span><br><span class="line">if(S[i].equals(T[j])) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i++;</span><br><span class="line">j = 0;</span><br><span class="line">&#125;</span><br><span class="line">if(j == T.length) &#123;</span><br><span class="line">System.out.println(&quot;T在S中的下标位置：&quot;+(i-T.length));</span><br><span class="line">break;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">if(i == S.length &amp;&amp; j != T.length) &#123;</span><br><span class="line">System.out.println(&quot;不匹配&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>&#160;&#160;&#160;&#160;由D·E·Knuth、J·H·Morris 和 V·R·Pratt三人设计的线性时间字符串匹配算法。<br>&#160;&#160;&#160;&#160;KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息，时间复杂度为：</p><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;O(M+N)</p><h2 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h2><p><strong>前缀</strong>  </p><p>除了最后一个字符以外，一个字符串的全部头部<strong><em>集合</em></strong><br><strong>后缀</strong>     </p><p>除了第一个字符以外，一个字符串的全部尾部<strong><em>集合</em></strong>  </p><p><strong>案例</strong>  </p><ul><li>字符串：A<br>前缀：空集<br>后缀：空集<br>共有长度：0  </li><li>字符串：AB<br>前缀：A<br>后缀：B<br>共有长度：0  </li><li>字符串：ABC<br>前缀：[A,AB]<br>后缀：[B,BC]<br>共有长度：0  </li><li>字符串：ABCD<br>前缀：[A,AB,ABC]<br>后缀：[BCD,CD,D]<br>共有长度：0</li></ul><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>next数组存的是当前字符串前缀和后缀的共有长度，因此对比的时候是需要用两个相同的字符串进行比较。<br>分析：</p><ul><li>若T(模式串),T[i] == T[j]<br>相等，说明 前缀 == 后缀，此时要进行后一位的匹配：i++;&#160;&#160;j++;&#160;&#160;&#160;next[i] = j;</li><li>否则，j要回溯<br>前缀是固定的，后缀是相对的。<br>j = next[j];<br>j为下一次要匹配的位置</li><li>因为i是后缀，j是前缀，初始时，i = j+1;<br>图解：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * KMP字符串匹配模式</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class KMP &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 字符的前后缀最高长度-next数组</span><br><span class="line"> */</span><br><span class="line">public static void getNext(String s) &#123;</span><br><span class="line">char[] p = s.toCharArray();</span><br><span class="line">    int[] next = new int[p.length];</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = -1;</span><br><span class="line">    while (i &lt; p.length - 1) &#123; </span><br><span class="line">       if (j == -1 || p[i] == p[j]) &#123;</span><br><span class="line">       i++;</span><br><span class="line">       j++;</span><br><span class="line">           next[i] = j;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">       //回溯</span><br><span class="line">           j = next[j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">for(int n=0;n&lt;next.length;n++) &#123;</span><br><span class="line">System.out.print(next[n]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个字符串：&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String S = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">getNext(S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kmp算法实现"><a href="#kmp算法实现" class="headerlink" title="kmp算法实现"></a>kmp算法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * KMP字符串匹配模式</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class KMP &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回字串T在主串S中的位置</span><br><span class="line"> * @param s</span><br><span class="line"> * @param t</span><br><span class="line"> * @param pos</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int KMPPlay(String[] s, String[] t, int pos) &#123;</span><br><span class="line">int i=pos;</span><br><span class="line">int j=-1;</span><br><span class="line">int[] next = new int[s.length+1];</span><br><span class="line">next[0] = -1;</span><br><span class="line">while(i&lt;s.length &amp;&amp; j&lt;t.length) &#123;</span><br><span class="line">if(-1 == j || s[i].equals(t[j])) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(j&gt;= t.length) &#123;</span><br><span class="line">return i-t.length;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;//不存在</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个模式串字符串：&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String S = scan.nextLine();</span><br><span class="line">System.out.println(&quot;请输入一个字串：&quot;);</span><br><span class="line">String T = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">System.out.println(KMPPlay(S.split(&quot;&quot;), T.split(&quot;&quot;), 0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h2><p>例如当主串为：ssssssssa<br>字串为：sssa时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.patternmatch;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * KMP字符串匹配模式</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class KMP &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回字串T在主串S中的位置</span><br><span class="line"> * @param s</span><br><span class="line"> * @param t</span><br><span class="line"> * @param pos</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int KMPPlay(String[] s, String[] t, int pos) &#123;</span><br><span class="line">int i=pos;</span><br><span class="line">int j=-1;</span><br><span class="line">int[] next = new int[s.length+1];</span><br><span class="line">next[0] = -1;</span><br><span class="line">while(i&lt;s.length &amp;&amp; j&lt;t.length) &#123;</span><br><span class="line">if(-1 == j || s[i].equals(t[j])) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">if(i&lt;s.length &amp;&amp; s[i].equals(t[j])) &#123;</span><br><span class="line">next[i] = next[j];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(j&gt;= t.length) &#123;</span><br><span class="line">return i-j;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;//不存在</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个模式串字符串：&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String S = scan.nextLine();</span><br><span class="line">System.out.println(&quot;请输入一个字串：&quot;);</span><br><span class="line">String T = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">System.out.println(KMPPlay(S.split(&quot;&quot;), T.split(&quot;&quot;), 0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回溯&quot;&gt;&lt;a href=&quot;#回溯&quot; class=&quot;headerlink&quot; title=&quot;回溯&quot;&gt;&lt;/a&gt;回溯&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;全称探索与回溯法，是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择——走不通退一步的技术为回溯法，满足回溯条件的某一个状态的点称为“回溯点” &lt;/p&gt;
&lt;h2 id=&quot;要素&quot;&gt;&lt;a href=&quot;#要素&quot; class=&quot;headerlink&quot; title=&quot;要素&quot;&gt;&lt;/a&gt;要素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;针对给定的问题，定义问题的解空间&lt;/li&gt;
&lt;li&gt;确定易于搜索的解空间结构&lt;/li&gt;
&lt;li&gt;以深度优先方式搜索解空间，再广度优先方式搜索&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归与分治</title>
    <link href="http://yoursite.com/2019/02/08/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/02/08/递归与分治/</id>
    <published>2019-02-08T14:59:34.000Z</published>
    <updated>2019-02-12T02:09:45.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>直接或间接调用自身的一种方法，减少了程序的代码量，即：<br>&#160;&#160;&#160;&#160;用有限的语句定义对象的无限集合<br>前提条件：</p><ul><li>不可无限制的调用自己，需要有一个出口</li><li>子问题不可大于原始问题<a id="more"></a>最典型的递归案例是：斐波那契数列，汉诺塔（梵塔），背包问题，快排、树<br><strong>缺点</strong><br>运行效率低，因此除非没有更好的算法，或者是特定条件下，一般不建议使用递归。<br>递归调用的过程中，系统为每一层的返回点、局部变量等都开辟了栈来存储，因此如果过多的使用递归，容易造成栈溢出。</li></ul><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p>源于分而治之的思想，将大问题分成小问题，将小问题再分成更小的问题，一直到最后的子问题可以简单的直接求解。源问题的解即子问题解的合并。<br>经典案例：快排、归并排序，傅里叶转换</p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>需要反复执行的子程序，进行一次重复，即重复执行程序中的循环，直到满足某条件为止。</p><h1 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h1><p><img src="/2019/02/08/递归与分治/loop.PNG" alt=""></p><h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><p>递归与分治很相似，但是不同的是，分治是：将大问题划分小问题，递归的去解决，再进行合并</p><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><ul><li>先排序，查找的一定是有序的数组或者链表</li><li>确定中间位置 mid = (left+right)/2</li><li>查找元素与mid进行比较，再对mid和left/right进行重新赋值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 折半查找问题</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Bisearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">System.out.println(&quot;输入要查找的数据&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">scan.close();</span><br><span class="line">getSearch(0,arr.length,n,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getSearch(int left, int right, int n,int[] arr) &#123;</span><br><span class="line">if(right&gt;left) &#123;</span><br><span class="line">int mid = (left+right)/2;</span><br><span class="line">if(n&lt;arr[mid]) &#123;</span><br><span class="line">getSearch(left, mid-1, n, arr);</span><br><span class="line">&#125; else if(n == arr[mid]) &#123;</span><br><span class="line">System.out.println(&quot;找到数据，下标为：&quot;+mid);</span><br><span class="line">&#125; else if(n&gt;arr[mid]) &#123;</span><br><span class="line">getSearch(mid+1, right, n, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;不存在该数据&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>汉诺塔时一个发源于印度的益智游戏，也叫河内塔。相传它源于印度神话中的大梵天创造的三个金刚柱，一根柱子上叠着上下从小到大64个黄金圆盘。大梵天命令婆罗门将这些圆盘按从小到大的顺序移动到另一根柱子上，其中大圆盘不能放在小圆盘上面。当这64个圆盘移动完的时候，世界就将毁灭。</p><p>问题：一个由多个放置在三个塔座上的盘子组成的一个古老的难题。<br>&#160;&#160;&#160;&#160;所有的盘子直径是不同的，并且盘子中央都有一个洞可以使它们刚好放在塔座上，所有的盘子刚开始都放在塔座A上。</p><p>目标是：将所有的盘子都从塔座A移动到塔座C上，每一次只移动一个盘子，并且任何一个盘子都不可以放在比自己小的盘子之上。  </p><p>分析：</p><ul><li>若n == 1<br>直接从A到C</li><li>若n ==2<br>(n-1)到B,n到C，(n-1)到C  </li><li>若n == 3<br>(n-2)到C，(n-1)到B，(n-2)到B，n到C，(n-2)到A，(n-1)到C，(n-2)到C</li></ul><p>分析：</p><ul><li>将A上的(n-1)盘子放在B上，n放在C上，其余再放到C上</li><li>n == 1,A-C</li><li>n == 2,A-B,A-C,B-C</li><li>n == 3, A-C,A-B,C-B,A-C,B-A,B-C,A-C</li></ul><p>思路：</p><ul><li>将(n-1)从A到B上<br>A借助C到B柱子上</li><li>n从A到C上<br> 输出</li><li>(n-1)从B到C上<br>B借助A到C柱子上去</li><li>递归ACB,BAC</li></ul><p><img src="/2019/02/08/递归与分治/hanoi.PNG" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 汉诺塔问题-A换到C柱子上去</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Hanoi &#123;</span><br><span class="line"></span><br><span class="line">private static int count = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共多少个盘子&quot;);</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">while(n&lt;1) &#123;</span><br><span class="line">System.out.println(&quot;请重新输入：&quot;);</span><br><span class="line">n = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">hanoiTest(n,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);</span><br><span class="line">System.out.println(&quot;总步数：&quot;+count);</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void hanoiTest(int n, String A, String B, String C) &#123;</span><br><span class="line">if(n == 1) &#123;</span><br><span class="line">move(A,C);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">hanoiTest(n-1, A, C, B);//n-1个盘子</span><br><span class="line">move(A,C);</span><br><span class="line">hanoiTest(n-1, B, A, C); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void move(String a, String c) &#123;</span><br><span class="line">count++;</span><br><span class="line">System.out.println(a+&quot;---&gt;&quot;+c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p>回溯算法的典型例题，这里先用递归实现<br>&#160;&#160;&#160;&#160;是国际西洋棋棋手马克斯·贝瑟尔1848年提出，高斯算出了76种，后有人用图论法解出92种结果。<br>问题：<br>在8X8的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行，同一列，同一斜线上，有多少种解法(92)  </p><p>分析：  </p><ul><li>判断行和列</li><li>判断当前棋格的左上方，右上方，四列是否有皇后</li><li>不判断左或右下方是因为，我们是考虑第一行到本行的棋格</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.recursion;</span><br><span class="line">/**</span><br><span class="line"> * 八皇后问题</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class EightQueen &#123;</span><br><span class="line"></span><br><span class="line">private static int count = 1;</span><br><span class="line">private static int[][] arr ;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">arr = init();</span><br><span class="line">//起始行，列数，数组</span><br><span class="line">eightQ(0,arr[0].length,arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int[][] init() &#123;</span><br><span class="line">int[][] arr = new int[8][8];</span><br><span class="line">//初始化</span><br><span class="line">for(int i=0;i&lt;8;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;8;j++) &#123;</span><br><span class="line">arr[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 递归算法</span><br><span class="line"> * @param row  行</span><br><span class="line"> * @param length  列</span><br><span class="line"> * @param arr 8X8棋格</span><br><span class="line"> */</span><br><span class="line">private static void eightQ(int row, int length, int[][] arr) &#123;</span><br><span class="line">//这里不对Length做判断，是因为八皇后，，，，，八列</span><br><span class="line">int[][] tmp = arr;</span><br><span class="line">//列</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">if(check(row, i, tmp)) &#123;</span><br><span class="line">tmp[row][i] = 1;</span><br><span class="line">//判断是不是最后一行</span><br><span class="line">if(row == 7) &#123;</span><br><span class="line">show(tmp);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">eightQ(row+1, length, arr);</span><br><span class="line">&#125;</span><br><span class="line">//精华</span><br><span class="line">                //用回溯法，当前行放不了皇后之后，回溯到上一行，将上一行清零 ，</span><br><span class="line">//再判断当前列i之后的列是否可以放皇后</span><br><span class="line">tmp[row][i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否能放皇后</span><br><span class="line"> * @param row</span><br><span class="line"> * @param col</span><br><span class="line"> * @param tmp</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static boolean check(int row, int col,int[][] tmp) &#123;</span><br><span class="line">//上面</span><br><span class="line">for(int i = row-1; i&gt;=0; i--) &#123;</span><br><span class="line">if(tmp[i][col] == 1) &#123;</span><br><span class="line">return false;//不可以放皇后</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//左上（行减小，列减小）</span><br><span class="line">for(int i = row-1,j = col-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--) &#123;</span><br><span class="line">if(tmp[i][j] == 1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//右上（行减小，列增大）</span><br><span class="line">for(int i=row-1,j=col+1;i&gt;=0 &amp;&amp; j&lt;8;i--,j++) &#123;</span><br><span class="line">if(tmp[i][j] == 1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 打印棋盘</span><br><span class="line"> */</span><br><span class="line">private static void show(int[][] tmp) &#123;</span><br><span class="line">System.out.println(&quot;第&quot;+count+&quot;种摆放方式&quot;);</span><br><span class="line">for(int i=0;i&lt;8;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;8;j++) &#123;</span><br><span class="line">System.out.print(tmp[i][j]+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h1&gt;&lt;p&gt;直接或间接调用自身的一种方法，减少了程序的代码量，即：&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;用有限的语句定义对象的无限集合&lt;br&gt;前提条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可无限制的调用自己，需要有一个出口&lt;/li&gt;
&lt;li&gt;子问题不可大于原始问题&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列1</title>
    <link href="http://yoursite.com/2019/02/03/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%971/"/>
    <id>http://yoursite.com/2019/02/03/栈和队列1/</id>
    <published>2019-02-03T05:05:21.000Z</published>
    <updated>2019-02-08T14:56:58.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>又名堆栈。先进后出（Last in first out,LIFO）的线性表，要求只在&#160;<em>表尾</em>&#160;进行删除和插入操作，只移动栈顶指针，不允许改变栈底指针。<br><a id="more"></a><br>注意：</p><ul><li>一定要判断栈是否满，是否空</li><li>建表时，要考虑栈数据的类型，可能会有多种数据类型<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="顺序栈（数组）"><a href="#顺序栈（数组）" class="headerlink" title="顺序栈（数组）"></a>顺序栈（数组）</h3></li></ul><ol><li>基础操作  </li></ol><ul><li>判断栈是否为空</li><li>判断是否栈满，若满，返回false或者增加容量</li><li>栈的大小</li><li>返回栈顶元素</li><li>入栈</li><li>进栈  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Base &#123;</span><br><span class="line">/** 栈大小 */</span><br><span class="line">private int maxSize ; </span><br><span class="line"></span><br><span class="line">/** 栈顶 */</span><br><span class="line">private int top ; </span><br><span class="line"></span><br><span class="line">/** 数据域 */</span><br><span class="line">private ArrayList&lt;Object&gt; data;</span><br><span class="line"></span><br><span class="line">/** 新增容量 */</span><br><span class="line">private static final int INCREAT = 10;</span><br><span class="line">/** </span><br><span class="line"> * 判断是否为Null栈</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top == -1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Base() &#123;</span><br><span class="line">this.maxSize = 0;</span><br><span class="line">this.data = new ArrayList&lt;&gt;();</span><br><span class="line">this.top = -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断是否栈满</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isFill() &#123;</span><br><span class="line">return top &gt;= maxSize-1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈的大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int Size() &#123;</span><br><span class="line">return maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回栈顶元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object top() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return data.get(top--);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 入栈</span><br><span class="line"> * @param n</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public void Push(Object n) &#123;</span><br><span class="line">//栈满,扩大栈</span><br><span class="line">if(isFill()) &#123;</span><br><span class="line">maxSize += INCREAT;//这里用的是集合，可以不用写，但如果用数组，要写的</span><br><span class="line">&#125;</span><br><span class="line">data.add(n);</span><br><span class="line">top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 弹栈</span><br><span class="line"> * @return Object类型，是因为不知道入栈的到底是什么妖魔鬼怪</span><br><span class="line"> */</span><br><span class="line">public Object Pop() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">Base b = new Base();</span><br><span class="line">b.Push(1);</span><br><span class="line">b.Push(&quot;h&quot;);</span><br><span class="line">System.out.println(&quot;栈顶元素：&quot;+b.top());</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+b.Size());</span><br><span class="line">b.Push(&quot;aa&quot;);</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+b.Pop());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">栈大小：10</span><br><span class="line">出栈：h</span><br><span class="line">出栈：1</span><br><span class="line">出栈：null</span><br><span class="line">出栈：null</span><br><span class="line">出栈：null</span><br></pre></td></tr></table></figure><h2 id="链表栈"><a href="#链表栈" class="headerlink" title="链表栈"></a>链表栈</h2><p>方法一：</p><ul><li>头尾指针</li><li>头指针 == 尾指针 时，链表为空<br><strong>节点类</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** 指针域 */</span><br><span class="line">private Stack top ; </span><br><span class="line"></span><br><span class="line">/** 数据域 */</span><br><span class="line">private Object data;</span><br><span class="line"></span><br><span class="line">public Stack getTop() &#123;</span><br><span class="line">return top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTop(Stack top) &#123;</span><br><span class="line">this.top = top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setData(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack(Object data) &#123;</span><br><span class="line">super();</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Stack(Stack top, Object data) &#123;</span><br><span class="line">super();</span><br><span class="line">this.top = top;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.stack;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表栈</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LinkedStack &#123;</span><br><span class="line">/** 栈顶 */</span><br><span class="line">private Stack top ;</span><br><span class="line"></span><br><span class="line">/** 栈底 */</span><br><span class="line">private Stack base;</span><br><span class="line"></span><br><span class="line">/** 栈大小 */</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> */</span><br><span class="line">public LinkedStack() &#123;</span><br><span class="line">super();</span><br><span class="line">this.top = new Stack();</span><br><span class="line">this.base = top;</span><br><span class="line">this.size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 栈大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int Size() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为空</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top == base ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回栈顶元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object Top() &#123;</span><br><span class="line">return top.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 入栈</span><br><span class="line"> * @param data</span><br><span class="line"> */</span><br><span class="line">public void Push(Object data) &#123;</span><br><span class="line">Stack newStack = new Stack();</span><br><span class="line">newStack.setData(data);</span><br><span class="line">top.setTop(newStack);</span><br><span class="line">top = newStack;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object Pop() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">Object data = top.getData();</span><br><span class="line">size--;</span><br><span class="line">Stack curr = base;</span><br><span class="line">while(curr.getTop() != top) &#123;</span><br><span class="line">curr = curr.getTop();</span><br><span class="line">&#125;</span><br><span class="line">top = curr;</span><br><span class="line">curr.setTop(null);</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LinkedStack ls = new LinkedStack();</span><br><span class="line">ls.Push(1);</span><br><span class="line">ls.Push(2);</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+ls.Size());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">ls.Push(&quot;a&quot;);</span><br><span class="line">System.out.println(&quot;出栈：&quot;+ls.Pop());</span><br><span class="line">System.out.println(&quot;栈大小：&quot;+ls.size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">栈大小：2</span><br><span class="line">出栈：2</span><br><span class="line">出栈：1</span><br><span class="line">出栈：null</span><br><span class="line">出栈：a</span><br><span class="line">栈大小：0</span><br></pre></td></tr></table></figure></p><p>方法二：使用头插法，这样就不需要尾指针（base）</p><h1 id="进制扩展"><a href="#进制扩展" class="headerlink" title="进制扩展"></a>进制扩展</h1><p>二进制：计算机只有高频和低频<br>十进制：人类常用语言<br>八进制：早期计算机系统都是三的倍数，因此较方便<br>十六进制：一个字节=8位，刚好两个十六进制数可以表示完整，节省空间</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>可查看 java.util.Queue接口<br>先进先出(FIFO)，可查看JAVA API,Queue继承了Collection接口<br>队头：删除<br>队尾：插入<br>也就是说，队尾进，队头出<br>分类： 顺序队列，循环队列<br>每种队列都可以用数组和链表实现</p><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.queue;</span><br><span class="line">/**</span><br><span class="line"> * 队列</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class MyQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;T&gt; data = new ArrayList&lt;T&gt;();</span><br><span class="line">private int front;</span><br><span class="line">private int rear;</span><br><span class="line">public MyQueue() &#123;</span><br><span class="line">front = 0;</span><br><span class="line">rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为空</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return front == rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回队列大小</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int size() &#123;</span><br><span class="line">return rear-front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回队首元素</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public T getFront() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return data.get(front++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 出队</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public T outQueue() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return getFront();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 入队</span><br><span class="line"> */</span><br><span class="line">public void InQueue(T item) &#123;</span><br><span class="line">data.add(item);</span><br><span class="line">rear++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyQueue&lt;Integer&gt; mq = new MyQueue&lt;Integer&gt;();</span><br><span class="line">mq.InQueue(1);</span><br><span class="line">mq.InQueue(2);</span><br><span class="line">System.out.println(&quot;队头元素：&quot;+mq.outQueue());</span><br><span class="line">System.out.println(&quot;队大小&quot;+mq.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">队头元素：1</span><br><span class="line">队大小2</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">缺点：队列出队后，空间不能再次使用，造成了内存的浪费，因此需要将队列看成是一个环状空间，而循环队列，是需要用循环链表实现的.   </span><br><span class="line"></span><br><span class="line">## 循环队列 ##  </span><br><span class="line">与顺序队列不同的是，不可用front == rear来区分是否队满或队空，需要新建一个布尔变量或者利用公式：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;(rear+1)%n == front</span><br><span class="line"></span><br><span class="line">方法一：</span><br><span class="line">- 设置一个标志位flag，初始化为0</span><br><span class="line">- 入队为1，出队为0</span><br><span class="line">- 队为空：front == rear &amp;&amp; flag == 0</span><br><span class="line">- 队为满：front == rear &amp;&amp; flag == 1    </span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">- 保留一个元素的存储空间</span><br><span class="line">- 队满：(rear+1)%n == front</span><br><span class="line">- 队空：rear == front</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">- 使用一个计数器，计算队中的元素个数</span><br><span class="line">- 队满：count&gt;0 &amp;&amp; front == rear</span><br><span class="line">- 队空：count == 0</span><br><span class="line"></span><br><span class="line">实现（方法二）</span><br></pre></td></tr></table></figure><p>package timejjc.com.queue;<br>/**</p><ul><li>循环队列—需要考虑队满的情况</li><li>@author 梁翠翠<br><em></em>/</li></ul><p>import java.util.ArrayList;</p><p>public class LoopQueue<t> {</t></p><pre><code>private Object[] data;private int rear;private int front;private int maxSize = 10;private static final int INCREAT = 10;//每次增长10空间public LoopQueue(){    this.rear = 0;    this.front = 0;    this.data = new Object[maxSize];}public boolean isEmpty() {    if(rear == front) {        return true;     }    return false;}public boolean isFill() {    if((rear+1)%maxSize == front) {        return true;    }    return false;}/** * 获取队头元素 * @param n */public Object queueFront(Object n ) {    if(isEmpty()) {        return null;    }    return  data[(front+1)%maxSize];}public void enQueue(Object n) {    if(isFill()) {        System.out.println(&quot;Queue is Fill&quot;);    } else {        rear = (rear+1)%maxSize;        data[rear] = n;    }}public Object deQueue(){    if(isEmpty()) {        return null;    }     return queueFront(front);}public static void main(String[] args) {    LoopQueue&lt;Integer&gt; lq = new LoopQueue&lt;Integer&gt;();    lq.enQueue(1);    lq.enQueue(2);    lq.enQueue(3);    lq.enQueue(4);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    lq.enQueue(5);    System.out.println(lq.deQueue());//1}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>package timejjc.com.queue;<br>/**</p><ul><li>循环队列–集合不需要判断队满，但需要判断是否为空，因为是坟墓</li><li>@author 梁翠翠<br><em></em>/</li></ul><p>import java.util.ArrayList;</p><p>public class LoopQueue<t> {</t></p><pre><code>private ArrayList&lt;T&gt; data = new ArrayList&lt;T&gt;();private int rear;private int front;public LoopQueue(){    this.rear = 0;    this.front = 0;}public boolean isEmpty() {    if(rear == front) {        return true;     }    return false;}/** * 获取队头元素 * @param n */public T queueFront() {    if(isEmpty()) {        return null;    }    T item = data.get(front%data.size());    front = (front+1)%data.size();    return  item;}public void enQueue(T n) {    if(data.size() == 0) {        rear = rear+1;    } else {        rear = (rear+1)%data.size();    }    data.add(n);}public Object deQueue(){    if(isEmpty()) {        return null;    }     return queueFront();}public static void main(String[] args) {    LoopQueue&lt;Integer&gt; lq = new LoopQueue&lt;Integer&gt;();    lq.enQueue(1);    lq.enQueue(2);    lq.enQueue(3);    lq.enQueue(4);    lq.enQueue(5);    lq.enQueue(6);    lq.enQueue(7);    lq.enQueue(8);    lq.enQueue(9);    lq.enQueue(10);    lq.enQueue(11);    lq.enQueue(12);    lq.enQueue(13);    lq.enQueue(14);    System.out.println(lq.deQueue());//1    System.out.println(lq.deQueue());//2    System.out.println(lq.deQueue());//3    System.out.println(lq.deQueue());//4    System.out.println(lq.deQueue());//5    System.out.println(lq.deQueue());//6    System.out.println(lq.deQueue());//7    System.out.println(lq.deQueue());//8}</code></pre><p>}</p><p><code>`</code></p><p>后续更新的话，需要更新链表的实现方式</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;p&gt;又名堆栈。先进后出（Last in first out,LIFO）的线性表，要求只在&amp;#160;&lt;em&gt;表尾&lt;/em&gt;&amp;#160;进行删除和插入操作，只移动栈顶指针，不允许改变栈底指针。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性表之循环链表</title>
    <link href="http://yoursite.com/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/02/02/线性表之循环链表/</id>
    <published>2019-02-02T07:51:44.000Z</published>
    <updated>2019-02-03T05:04:57.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（单）循环链表"><a href="#（单）循环链表" class="headerlink" title="（单）循环链表"></a>（单）循环链表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>最后一个结点的指针域指向头节点，形成一个环<br><a id="more"></a></p><h2 id="约瑟夫-Josephus-环"><a href="#约瑟夫-Josephus-环" class="headerlink" title="约瑟夫(Josephus)环"></a>约瑟夫(Josephus)环</h2><p>&#160;&#160;&#160;&#160;已知n个人（以编号1,2,3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依次规律重复下去，知道圆桌周围的人全部出列，通常我们设置编号0~n-1  </p><p>循环链表解决思路：</p><ul><li>尾节点不指向头节点，找到要出列结点的前一个结点p</li><li>p指向出列结点的下一个结点</li><li>若尾节点指向头节点，此时只剩下一个结点，则直接输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Josphus &#123;</span><br><span class="line"></span><br><span class="line">public static void josphus(LNode head, int m) &#123;</span><br><span class="line">if(head == null) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">System.out.println();</span><br><span class="line">while(tmp.getNext() != tmp) &#123;</span><br><span class="line">for(int i=0;i&lt;m-1;i++) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(tmp.getNext().getData()+&quot; &quot;);</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">&#125;</span><br><span class="line">//最后一个不要忘了输出</span><br><span class="line">System.out.println(tmp.getData());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接两个链表"><a href="#连接两个链表" class="headerlink" title="连接两个链表"></a>连接两个链表</h2><p>题目： 实现将两个线性表（a1,a2,…,an）和（b1,b2,…,bm）连接成一个线性表（a1,…,an,b1,…,bm）的运算<br>更灵活的循环链表：去掉头指针，增加一个尾指针rear<br><img src="/2019/02/02/线性表之循环链表/loopList.PNG" alt="">  </p><p>思路：</p><ul><li>单链表<br>&#160;&#160;&#160;&#160;如果是单链表或头指针表示的单循环表上做这种连接操作，都需要遍历第一个链表，找到结点an，然后将结点b1放到结点an后面，时间复杂度是O（n）  </li><li>循环链表<br>&#160;&#160;&#160;&#160;因为循环链表有尾指针，所以只需要改变尾指针，无需遍历，时间复杂度是O(1)    </li></ul><p><img src="/2019/02/02/线性表之循环链表/loopListDouble。PNG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TwoToOne &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param a 第一个链表的尾指针</span><br><span class="line"> * @param b 第二个链表的尾指针</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static LNode twoOne(LNode a, LNode b) &#123;</span><br><span class="line">LNode tmp = a.getNext();//a的头节点</span><br><span class="line">System.out.println(&quot;aaa&quot;+b.getNext().getNext().getData());</span><br><span class="line">a.setNext(b.getNext().getNext());</span><br><span class="line">b.setNext(tmp);</span><br><span class="line">return tmp;//新链表的头结点位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="判断单链表中是否有环"><a href="#判断单链表中是否有环" class="headerlink" title="判断单链表中是否有环"></a>判断单链表中是否有环</h2><p><strong>所谓有环，不一定是尾节点指向头节点，尾节点可以指向链表中的任意结点</strong><br>方法一：</p><ul><li>使用p,q两个指针，p总是向前走，单q每次都从头开始走</li><li>对于每个结点，看p走的步数是否和q与q一样，不一样代表有环  </li></ul><p>方法二：</p><ul><li>使用p,q两个指针，p每次向前走一步,q每次向前走两步</li><li>若某个时候p == q,则有环  </li></ul><p>我觉得，第一个好理解一点！！！  因为不知道第二种方法的原因</p><h2 id="魔术师发牌问题"><a href="#魔术师发牌问题" class="headerlink" title="魔术师发牌问题"></a>魔术师发牌问题</h2><p>&#160;&#160;&#160;&#160;魔术师利用一副牌中的13张黑牌，预先将他们排好后叠放在一起，牌面朝下。对观众说：“我不看牌，只数数就可以才到每张牌是什么，我大声叔叔，你们听，不信？现场演示。”魔术师将最上面的那张牌数为1，把他翻过来正好是黑桃A，将黑桃A放在桌子上，第二次数1,2..将第一张牌放在这些牌的下面，将第二张牌翻过来，正好是黑桃2，也将他放在桌子上这样一次进行将13张牌全部翻出，准确无误。  </p><p>问题：拍的开始顺序是如何排放的。<br>思路：</p><h2 id="拉丁方阵问题"><a href="#拉丁方阵问题" class="headerlink" title="拉丁方阵问题"></a>拉丁方阵问题</h2><p>&#160;&#160;&#160;&#160;拉丁方阵是一种n x n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列种恰好出现一次。著名数学家和物理学家欧拉使用拉丁字母来作为拉丁方阵里元素的符号。(嗯哼，数独哎)<br>思路：</p><ul><li>第一行打印：1，2,3,…,n</li><li>第二行打印：2,3,…,n,1</li><li>第三行打印：3,…,n,2</li><li>第n行打印：n,1,2,…,n-1</li></ul><h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><p>双向链表：每个数据结点种都有两个指针，分别指向直接后继和直接前驱。<br><img src="/2019/02/02/线性表之循环链表/doubleList.PNG" alt="">    </p><p>双向循环链表：<br><img src="/2019/02/02/线性表之循环链表/doubleLoopList.PNG" alt="">  </p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="/2019/02/02/线性表之循环链表/insertDouble.PNG" alt="">  </p><ul><li>s指向p的next</li><li>s的前驱指向p的前驱</li><li>p指向s的前驱的next</li><li>p指向s的前驱 </li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="/2019/02/02/线性表之循环链表/doubleDelete.PNG" alt="">  </p><p>后续再更代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;（单）循环链表&quot;&gt;&lt;a href=&quot;#（单）循环链表&quot; class=&quot;headerlink&quot; title=&quot;（单）循环链表&quot;&gt;&lt;/a&gt;（单）循环链表&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;最后一个结点的指针域指向头节点，形成一个环&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性表(2)</title>
    <link href="http://yoursite.com/2019/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8-2/"/>
    <id>http://yoursite.com/2019/02/02/线性表-2/</id>
    <published>2019-02-02T01:36:21.000Z</published>
    <updated>2019-02-02T07:51:22.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#160;&#160;&#160;&#160;创建单链表的过程是一个动态生成链表的过程，从“空表”的初始状态起，一次简历各元素结点并逐个插入链表。<br><a id="more"></a><br>思路：  </p><ul><li>声明一个结点p和计数器变量i；</li><li>初始化一空链表L；</li><li>让L的头节点的指针指向NULL，即建立一个带头节点的单链表；</li><li>循环实现后继结点的赋值和插入。  <h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2>始终把新加进的元素放在表头后的第一个位置：  </li><li>新节点的next指向头节点后面；</li><li>表头的next指向新节点。  </li></ul><p>生成的链表中结点的次序和输入的顺序是想法的！ </p><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>始终把新元素放在表尾：</p><ul><li>当前节点指向新节点</li><li>新节点成为当前结点</li><li>三个结点，head,新节点(newNode)，当前结点（cur）  <h1 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h1>从内存中释放<br>思路：</li><li>声明结点p,q</li><li>大奖第一个结点赋值给p,下一结点赋值给q</li><li>循环执行释放p和将q赋值给p的操作<br>JAVA中，GC释放  </li></ul><h1 id="比较单链表，顺序表"><a href="#比较单链表，顺序表" class="headerlink" title="比较单链表，顺序表"></a>比较单链表，顺序表</h1><p><img src="/2019/02/02/线性表-2/compare.PNG" alt="">  </p><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>用数组描述的链表 </p><ul><li>包括数据域和游标</li><li>数组的第一个和最后一个元素做特殊处理，data域不存数据</li><li>未使用的数组元素成为备用链表</li><li>数组的第一个元素，即下标为0的哪个元素的游标存放备用链表的第一个结点的下标</li><li>数组的最后一个元素，即下标为MAXSIZE-1的游标存放第一个由数值的元素的下标，相当于头节点  </li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>静态链表是为了给没有指针的变编程语言设计的一种实现单链表功能的方法。</p><p>嘿嘿嘿，不太懂啊</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>题目：快速找到未知长度单链表的中间结点</p><p><strong>方法一</strong></p><ul><li>遍历单链表确定链表长度</li><li>再次从头节点出发循环L/2次找到单链表的中间结点 </li><li>复杂度O(L+L/2) = O(3L/2)     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode minBase(LNode head) &#123;</span><br><span class="line">int size = 0;</span><br><span class="line">LNode p = head;</span><br><span class="line">while(p.getNext() != null) &#123;</span><br><span class="line">p = p.getNext();</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0; i&lt;size/2; i++) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法二</strong><br>快慢指针  </p><ul><li>设置两个指针 search,mid都指向单链表的头节点，其中search的移动速度是mid的2倍，当search指向末尾结点的时候，min正好就在中间了，即标尺的思想。  </li><li>算法复杂度O(L/2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MidData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode midD(LNode head) &#123;</span><br><span class="line">LNode search = head;</span><br><span class="line">LNode mid = head;</span><br><span class="line">while(search.getNext() != null) &#123;</span><br><span class="line">if(search.getNext().getNext() != null) &#123;</span><br><span class="line">search = search.getNext().getNext();</span><br><span class="line">mid = mid.getNext();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">search = search.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>题目:写一个完整的程序，实现随机生成20个元素的链表，查找重点节点的值并显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestMain &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode();</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line">LNode tmp = new LNode(new Random().nextInt(100)+1);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单链表的整表创建&quot;&gt;&lt;a href=&quot;#单链表的整表创建&quot; class=&quot;headerlink&quot; title=&quot;单链表的整表创建&quot;&gt;&lt;/a&gt;单链表的整表创建&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;创建单链表的过程是一个动态生成链表的过程，从“空表”的初始状态起，一次简历各元素结点并逐个插入链表。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性表（List）之增删改查</title>
    <link href="http://yoursite.com/2019/02/01/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/02/01/线性表/</id>
    <published>2019-02-01T08:31:54.000Z</published>
    <updated>2019-02-02T01:39:41.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;由0或多个数据元素组成的有限个序列，为0时，是空表<br><a id="more"></a></p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>&#160;&#160;&#160;&#160;第一个元素无前驱，最后一个元素无后继，其他元素都<strong><em>有且只有</em></strong>一个前驱和后继。线性关系是不允许有第三者的！！！   </p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>&#160;&#160;&#160;&#160;一组性质相同的值的集合及定义在此集合上的一些操作的总称<br>&#160;&#160;&#160;&#160;JAVA中数据类型分为两种：  </p><ul><li><p>基本数据（原子）类型：不可再分<br><img src="/2019/02/01/线性表/type_base.png" alt="">  </p></li><li><p>引用数据类型<br>&#160;&#160;&#160;&#160;类、接口、数组<br>&#160;&#160;&#160;&#160;很重要！！！，否则无法理解“指针”操作</p></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li>求元素个数</li><li>插入</li><li>删除</li><li>查找</li><li>判断是否为空  </li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>&#160;&#160;&#160;&#160;顺序存储和链表存储  </p><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>&#160;&#160;&#160;&#160;栈内存是顺序结构的<br>&#160;&#160;&#160;&#160;用一段地址连续的存储单元依次存储线性表的数据元素<br>需要封装的属性（3）：</p><ul><li>起始位置</li><li>最大存储容量</li><li>当前长度<br><strong><em><font color="red">注意：线性表的首地址为：1</font></em></strong>    </li></ul><p>时间复杂度</p><ol><li>删除/插入<br>最好情况：不移动元素&#160;O(1)<br>最坏情况:移动n个元素&#160;O(n)<br>平均情况:O((n-1)/2),&#160;即&#160;O(n)   </li></ol><p>&#160;&#160;2.存、取<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;都为&#160;O(1)  </p><p>优点  </p><ol><li>不需要为博爱中元素之间的逻辑关系增加额外的存储空间 </li><li>快速存取表中任意位置的元素……虽让人家是顺序的呢，嘿嘿嘿  </li></ol><p>缺点  </p><ol><li>插入和删除太慢了，除非数据特别少，否则不要用啊！！！</li><li>若线性表的长度变化较大（大量的插入和删除） ，无法确定存储空格键的容量啊</li><li>存储空间碎片化，毕竟人家存储空间的分配是一整块来着的呀，当一大块空间剩下一小块时，而这一小块空间又不够我们用的，那就只能浪费掉，然后再次申请一大块空间，两个大块之间的小块就属于“碎片”啦  </li></ol><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>位置是随意的哦，但是要求存元素本身及其后继指针  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据域<br>存储数据元素信息的域  </li><li>指针域<br>存储后继位置的域  </li><li>指针<br>指针域中存储的信息  </li><li>结点(存储映像)<br>数据域 + 指针域    <h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><img src="/2019/02/01/线性表/LNode.png" alt="">  </li></ul><h4 id="头指针-头节点-首元节点"><a href="#头指针-头节点-首元节点" class="headerlink" title="头指针/头节点/首元节点"></a>头指针/头节点/首元节点</h4><ul><li>头指针<br>指链表指向的第一个结点的指针，若链表有头检点，则是指向头结点的指针。<br>单链表可由一个头指针唯一确定（标识）</li><li>元首结点<br>指链表中存储第一个元素的结点</li><li>头结点<br>在链表的首元结点之前附设的一个节点，数据域内存放的是空表标志和表长等信息<br><img src="/2019/02/01/线性表/node.png" alt="">  </li></ul><p>&#160;&#160;&#160;&#160;<strong> 无论链表是否为空，头指针均不为 </strong>，人家是唯一标识啊😏     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h4><ul><li>获得链表第i个数据<br>&#160;1. 声明一个结点p指向链表第一个结点，初始化&#160;j&#160;从1开始<br>&#160;2. 当j&lt;i时，遍历链表，p指针后移，j++;<br>&#160;3. 若循环到末尾p为空，则不存在第i个元素<br>&#160;4. 否则查找成功，返回结点p的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GetIData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode IData(LNode head,int i) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">while(head != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">head = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否遍历完整个链表</span><br><span class="line">if(head == null || j&lt;i)</span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160;&#160;&#160;&#160;单链表的循环，建议使用while,因为并不知道单链表的长度</p><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><ul><li>在第i个数据插入结点<br>&#160;1. 新节点指向当前结点的后继<br>&#160;2. 当前结点指向新节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsertData &#123;</span><br><span class="line"></span><br><span class="line">public static LNode insert(LNode head, int i, int newData) &#123;</span><br><span class="line">int j = 0;</span><br><span class="line">LNode tmp = head;</span><br><span class="line">while (tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = head.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">//new一个空结点p</span><br><span class="line">LNode p = new LNode(0);</span><br><span class="line">&lt;font color=red&gt;p.setData(newData);&lt;/font&gt;</span><br><span class="line">//p指向head后继:p.next = head.next</span><br><span class="line">p.setNext(tmp.getNext());</span><br><span class="line">//head指向p:head.next = p;</span><br><span class="line">tmp.setNext(p);</span><br><span class="line">return head.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的时head.getNext()是因为，在定义head时，为：</p><blockquote><p>LNode head = new LNode(0);<br>这时head是有头节点的   </p></blockquote><p><img src="/2019/02/01/线性表/head.png" alt="">  </p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>&#160;1. 找到要删除结点的前驱结点（j=1开始）<br>&#160;2. 前驱结点直接指向要删除结点的后继结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DeleteNode &#123;</span><br><span class="line"></span><br><span class="line">public static LNode deleteINode(LNode node, int i) &#123;</span><br><span class="line">int j = 1;</span><br><span class="line">LNode tmp = node;</span><br><span class="line">while(tmp != null &amp;&amp; j&lt;i) &#123;</span><br><span class="line">tmp = tmp.getNext();</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == null || j&lt;i || i&lt;0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">tmp.setNext(tmp.getNext().getNext());</span><br><span class="line">return node.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;由0或多个数据元素组成的有限个序列，为0时，是空表&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <link href="http://yoursite.com/2019/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/02/01/时间复杂度与空间复杂度/</id>
    <published>2019-02-01T02:13:43.000Z</published>
    <updated>2019-02-01T12:23:38.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>分类：时间复杂度&#160;和&#160;空间复杂度<br>指在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和空间资源。<br><a id="more"></a><br>方法：</p><ul><li>事前分析估算法（渐进复杂度)<br>&#160;常用的算法，依据统计方法对算法进行估算</li><li>事后统计法<br>&#160;&#160;&#160;&#160;通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。<br>&#160;&#160;&#160;&#160;但是需要花费大量的时间和经历，若测试发现算法不可取，则损失重大。   </li></ul><p>算法效率的度量因素：  </p><ol><li>算法采用的策略、方案</li><li>编译产生的代码质量</li><li>问题的输入规模（输入量）</li><li>及其执行指令的速度<br>&#160;<strong><em>一个程序的运行时间依赖于算法的好坏和问题的输入规模。</em></strong>   </li></ol><p>函数的渐近增长：<br>判断一个算法的效率时，函数中的尝试和其他次要项可忽略，关注的应该是最高想的阶数。 </p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>官方定义：</strong><br>&#160;&#160;&#160;&#160;在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。<br>&#160;&#160;&#160;&#160;算法的时间复杂度，也就是算法的时间量度，记作：<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T(n) = O(f(n))<br>&#160;&#160;表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>，其中f(n)是问题规模n的某个函数<br>比较：<br><img src="/2019/02/01/时间复杂度与空间复杂度/timeComplexity.png" alt="">   </p><p>时间复杂度所消耗的时间从小到大依次为:<br>O(1) &lt; O(lon(n)) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)    </p><h3 id="最坏情况和平均情况"><a href="#最坏情况和平均情况" class="headerlink" title="最坏情况和平均情况"></a>最坏情况和平均情况</h3><ul><li>最坏运行时间<br>&#160;&#160;&#160;&#160;一个算法有最好的情况和最坏的情况。在应用中，这是一个最中药的需求，除了特别指定，我们所提到的运行时间都是最坏情况的运行时间。  </li><li>平均运行时间<br>&#160;&#160;&#160;&#160;期望的运行时间     <h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2>通过计算算法所需要的存储空间实现的，计算公式为:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S(n) = O(f(n));<br>&#160;&#160;&#160;&#160;其中f(n)是关于问题规模n所占存储空间的函数。<br>是对一个算法在运行过程中临时占用存储空间大小的度量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h1&gt;&lt;p&gt;分类：时间复杂度&amp;#160;和&amp;#160;空间复杂度&lt;br&gt;指在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和空间资源。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/01/30/数据结构与算法之逆序/</id>
    <published>2019-01-30T01:46:38.719Z</published>
    <updated>2019-02-02T07:50:06.525Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 算法之链表逆序<br>date: 2019-01-30 09:46:38<br>tags: </p><ul><li>数据结构</li><li>算法</li></ul><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>有一链表，链表数据为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 </li><li>使其逆序，数据为：7 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1  </li></ul><a id="more"></a><h3 id="解决方法（3种）"><a href="#解决方法（3种）" class="headerlink" title="解决方法（3种）"></a>解决方法（3种）</h3><h5 id="1-就地逆序"><a href="#1-就地逆序" class="headerlink" title="1.就地逆序"></a>1.就地逆序</h5><ul><li>新增一节点的指针域，用于存储当前节点的后继节点 </li><li>需要当前节点，前驱节点</li><li>遍历链表，直到最后一个节点  </li></ul><p><strong>节点类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表节点类</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LNode &#123;</span><br><span class="line">/** 数据域 */</span><br><span class="line">private  int data ;</span><br><span class="line"></span><br><span class="line">/** 节点域 */</span><br><span class="line">private LNode next;</span><br><span class="line"></span><br><span class="line">public int getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void setData(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(LNode next) &#123;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LNode(int data, LNode next) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <strong>测试类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基础的链表反转</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Reverse &#123;</span><br><span class="line">/**</span><br><span class="line"> * 直接反转节点指向</span><br><span class="line"> * @param head 头节点</span><br><span class="line"> * @return 逆序后的链表</span><br><span class="line"> */</span><br><span class="line">public static LNode Reverse_base(LNode head) &#123;</span><br><span class="line">//没有节点或只有一个节点则直接返回</span><br><span class="line">if(head == null || head.getNext() == null)</span><br><span class="line">return head;</span><br><span class="line">//前驱节点</span><br><span class="line">LNode pre = null;</span><br><span class="line">//下一节点</span><br><span class="line">LNode next = null;</span><br><span class="line">//当前节点</span><br><span class="line">LNode cur = head;</span><br><span class="line">//循环链表</span><br><span class="line">while(cur != null) &#123;</span><br><span class="line">//next存储当前节点的后继节点，以免丢失</span><br><span class="line">next = cur.getNext();</span><br><span class="line">//当前节点指向下一节点</span><br><span class="line">cur.setNext(pre);</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">return pre;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LNode head = new LNode(0);</span><br><span class="line">//LNode tail = new LNode(0);</span><br><span class="line">LNode tail = head;</span><br><span class="line">System.out.println(&quot;原始链表&quot;);</span><br><span class="line">for(int i=1; i&lt;8; i++) &#123;</span><br><span class="line">LNode tmp = new LNode(i);</span><br><span class="line">tail.setNext(tmp);</span><br><span class="line">tail = tmp;</span><br><span class="line">System.out.print(tail.getData()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">LNode lNode = Reverse_base(head);</span><br><span class="line">System.out.println(&quot;逆序链表&quot;);</span><br><span class="line">while(lNode.getNext() != null) &#123;</span><br><span class="line">System.out.print(lNode.getData()+&quot; &quot;);</span><br><span class="line">lNode = lNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是所有的代码<br>在逆序前，存值到链表中：<br><img src="/2019/01/30/数据结构与算法之逆序/variables_head.png" alt="">  </p><p>逆序后，链表pre   </p><p><img src="/2019/01/30/数据结构与算法之逆序/variables_pre.png" alt="">   </p><p>由于第一次使用Markdown pad2  之后会不断优化<br>解法有3种，后续会更新</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 算法之链表逆序&lt;br&gt;date: 2019-01-30 09:46:38&lt;br&gt;tags: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有一链表，链表数据为：1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 &lt;/li&gt;
&lt;li&gt;使其逆序，数据为：7 -&amp;gt; 6 -&amp;gt; 5 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/01/24/hello-world/"/>
    <id>http://yoursite.com/2019/01/24/hello-world/</id>
    <published>2019-01-24T05:27:47.829Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
