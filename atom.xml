<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimeJjc&#39;s Blog</title>
  
  <subtitle>新的开始,加油哦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-22T03:27:13.892Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试</title>
    <link href="http://yoursite.com/2019/05/14/%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/05/14/面试/</id>
    <published>2019-05-14T08:04:48.000Z</published>
    <updated>2019-05-22T03:27:13.892Z</updated>
    
    <content type="html"><![CDATA[<p>首先说明，面试真的是一个很玄学的东西<br><a id="more"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#QAX">奇安信</a></li><li><a href="#DYHW">东营汉威</a></li><li><a href="#EB">东信北邮</a></li></ul><h2 id="奇安信"><a href="#奇安信" class="headerlink" title="奇安信"></a><span id="QAX">奇安信</span></h2><ul><li>笔试<br>4月19日，第一批笔试，可以说不难，但是还是没做出来 </li><li>一面<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4月26日中午11：20约的面试，但是因为签到排队面试，等了一会，然后到我的时候面试官又有事走了，于是等到了13：50才开始面试，期间我去旁边的麦当劳吃了顿饭。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;面试之前，真的是无比的紧张，第一次到大公司面试，然而面试的时候，一点紧张感都没有了，但是也就意味着我凉了<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先一道算法题，很简单的一个链表题，先说思想，再写主要的代码，思想对了，代码错了，，，，<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;开始正式面试，上来问我为什么选Java，讲一下Java？？？？套路不一样啊，讲一下就为难我这个嘴笨的人了<br>记录一下提问的问题吧：<br><code>1. 什么是封装（回答的他不满意）</code><br><code>2. 包装类的缓存，好的我答对了</code><br><code>3. url过程需要的协议？emmmm，链路层和物理层的没想起来，也就是ARP和MAC</code><br><code>4. JDK10新特性？回答了</code><br><code>5. Spring生命周期？艾玛，忘掉了</code><br>问了很多，现在想想其实挺基础的，奈何自己不用功    </li></ul><h2 id="东营汉威"><a href="#东营汉威" class="headerlink" title="东营汉威"></a><span id="DYHW">东营汉威</span></h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;招聘信息是导员发的，面试的时候，负责人说在北京的这个，已经是一个子公司了“北京汉威胜业石油技术开发有限公司”<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;面试的时候，很简单，也可能是因为内推的关系吧，问了一下项目就没有别的了，然后就是介绍公司<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;作为一个油田领域上的技术公司，其实发展挺好的，毕竟油田国家垄断嘛，也有自己的研究院（副院长是本校老师，但是没记住是谁），北京的公司主要是负责客户方面（忘了怎么说了），其实就是将东西呈现给客户<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;公司之前在西二旗，现在是在一个居民楼，说是省下钱发奖金？？<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;薪资的话，很低，是真的很低，而且不知道一年涨一次还是两次，还是看着来<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;上班时间很爽，8小时，听说加班有加班费？<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一年多少薪也没说，主要我也忘了问，啊啊啊啊，保险也忘了问<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最最主要的是，让我转语言！！！！！<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我特么坚持了那么久Java，一心想走Java，现在这么可笑的么？？？虽然C#发展也很好<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;但是坚持了那么久的东西，说换就换，不甘心   </p><h2 id="东信北邮"><a href="#东信北邮" class="headerlink" title="东信北邮"></a><span id="EB">东信北邮</span></h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5月6日在boss上进行了沟通（项目经理直接招聘的），职位是Java，上面写的薪资是8k-15k，本来以为没有希望（因为在boss上投了很多，但是没有人回话），然而在5月8日的时候，对方回话了，问了一个equals的问题，我回答上来之后，对方又没信了，然后我就厚着脸皮问对方是否能看一下我的简历（脸皮必须要厚啊，不然抓不住机会），然后9号找我要了简历，惊了，，，，因为只问了一个那么小的问题，感觉只要学过编程语言的人都懂。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不管不管，反正有面试机会就可以了。。啦啦啦啦啦啦啦  (周六还跑去聚会了一下，吃了烤鱼，看了降国旗，原来降国旗是没有国歌的呀)， 来看看我的图：<br><img src="/2019/05/14/面试/a.jpg" alt=""><br><img src="/2019/05/14/面试/b.jpg" alt=""><br><img src="/2019/05/14/面试/c.jpg" alt=""><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5月13，周一早上10点，面试去啦，当时还有一个男生，也是Java的，然后两个人一起做面试题，这里要吐槽一下，那个男孩子好像都不怎么会，然后一直百度百度，当然，人家也有可能是谷歌啦。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;笔试大概花了我一个小时，然后进行了第一轮的面试，总的来说，这个面试还是挺简单的，因为面试官只问了项目（别的问的很少），本来以为会问我框架这些（对这些的原理掌握的不行），反正吧，觉得很容易，面了大概二十来分钟，然后第一轮的面试官就给第二轮的面试管打电话发消息，得知对方在开会，等了很久，，，，面试官让我回去了，说不知道第二轮的面试官什么时候能开完会，，，，啊啊啊，，，本来能一天搞定的事，还想着，这个面试过了，就不投了，然后回家呆两天的。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;当天下午接到了Hr的电话，然后约到了周四的面试（好想周二就面完呢），根据第一轮面试官所说：二面是综合面试，三面是Hr，四面是boss（惊，Boss要跟我谈人生，画个饼饼么）<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;由于只面了一面，所以面完后续的在更吧！（让我过了吧，救救孩子！）<br>记录一下笔试及面试（有些已经忘了）：</p><ul><li>笔试：  </li></ul><ol><li>final,finally,fanalize的区别  </li><li>101-200有多少个素数，全部输出，并输出素数的个数</li><li>多态的代码题，给代码，输出结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FatherClass &#123;</span><br><span class="line">public int n = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChildClass extends FatherClass&#123;</span><br><span class="line">public int n = 40;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">FatherClass fc = new ChildClass();</span><br><span class="line">ChildClass cc = new ChildClass();</span><br><span class="line">System.out.println(fc.n+cc.n);//输出50</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>好难过，写错了，写了80  </p><ol start="4"><li>也是一道代码题，看代码写结果  (忘掉了)  </li><li>编程题，将一个字符串中的小写换成大写，非英文字符删除，将结果返回  </li><li>好像也是一个编程题  </li><li>生产者和消费者的问题：<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;考察的应该是wait()和notify()，写了个大概   </li><li>socket的问题，是一道附加题，没写  </li><li>compare和comparable的区别？  不知道呢</li><li>什么是GC</li></ol><ul><li>一面  </li></ul><ol><li>问了项目前后端使用了什么：用了什么的js，后端用了什么技术    </li><li>项目中的数据库有没有多表关联（我负责的模块是没有滴），是否建立了索引？（我只是简单的说明了什么是索引）   </li><li>班级排名    </li><li>期待薪资    </li><li>OIS和TCP  </li><li>栈和内存  </li><li>是否愿意转C++  </li><li>是否已经拿到OFFER  </li><li>面试过哪些互联网企业（说了360企业安全） </li><li>是否了解Linux  </li><li>说一下常用的Linux命令  </li><li>期望薪资是8k*12么？（我填的期望薪资是8k），然后我回答了13，，关于这个几薪问题，有的朋友说我填高了，有的说我亏了，最少14起  </li><li>还问了啥忘掉了<br>补充：http在那一层，说一下三次握手<br>以下是在等二面时的闲聊：  </li><li>是否愿意在京长期发展  </li><li>玩游戏不    </li><li>其余的忘掉了，总之面试官人很好    </li></ol><p>最后一个引人深思的问题：</p><p>我大Java是已经不行了么，不是让我转C#,就是让我转C++,简直不把我Java放在眼里！  哼！  </p><p>——————— 分割线 ——————————————–  </p><ul><li>二面  称为综合面试<br>二面的电话是在一面当天下午打过来的，因为一面的面试官说过会给我打电话，所以没有很意外<br>二面的时候大概15-20分钟，也就是问问简历和笔试题，才意识到一道笔试题范围考虑的不周到，面试官人很好，也提到了转C++的事，问的不多<br>——————— 分割线 ——————————————–<br>周四面完之后，以为周五会给电话，一直在焦急的等待之中，周一打电话说面试通过，然后周二5月21日进行了面试<br>12：30的面试，有点惊讶竟然是在大中午的，去了前台之后一共有四个，Java开发的还有另外一个姑娘，不过她毕业好几年了，能力肯定比我强   </li><li><p>三面 hr面<br>自我介绍，还介绍了项目，问了一下个人的情况，包括家庭，是否有对象（哭唧唧），然后就开始介绍了一下公司的福利，问我有什么问题之后，我竟然只问了一句我是哪个部门的（手动滑稽）<br>当时可能傻了，进了地铁之后就想到了好多问题，比如：<br>&#160;&#160;&#160;&#160;实习期可以抵试用期么<br>&#160;&#160;&#160;&#160;Boss定的薪是实习期的还是正式的（实习期90%）<br>&#160;&#160;&#160;&#160;关于五险一金或者其他补助的事（她只说了一个补助，估计就那一个）<br>&#160;&#160;&#160;&#160;感觉没有介绍的很详细，因为招聘上的写的一些福利，他没有说  </p></li><li><p>四面boss面<br>千篇一律的自我介绍，问了三年规划（工作与家庭），自我学习能力，自学了什么，业余时间喜欢干什么，家庭，问了有没有参加过C++的项目，比赛什么的，问了学校是几本（看着他写了两个大大的字，尴尬），然后就直接定薪了，，，想到自己从头开始学C++（两年没用了）也就没还价   </p></li></ul><p>以上，是总体过程，历时5月6日~5月21日，整整半个月，悬着的一颗心总算落下了，还有一个月毕业了，也不打算找了，希望在这个公司能学到很多东西，虽然工资比不上那个谁谁谁（学历是硬伤），主要能力也不一样，不管是现有能力，还是学习能力，还是吃苦能力，还差的太远。</p><p>最后的最后其实我想说，没有坚持走Java，还是有点难过</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说明，面试真的是一个很玄学的东西&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>三次握手四次挥手</title>
    <link href="http://yoursite.com/2019/04/02/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2019/04/02/三次握手四次挥手/</id>
    <published>2019-04-02T14:19:27.000Z</published>
    <updated>2019-04-12T11:34:09.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h1><p>本篇文章讲解的是TCP协议三次握手和四次挥手的一个详情。<br><a id="more"></a></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><span id="transport">传输层</span></h2><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;传输层,顾名思义就是数据之间的通信的，那么这个通信是什么样子的呐，分布式的呀！！！他会利用网络层(他的下方)提供的服务，去源主机的应用进程上和目的主机进行一个<code>端到端</code>的连接<br>提问：  </p><blockquote><p>传输层之间传输的报文称之为什么？  </p></blockquote><p>答：</p><blockquote><p>TPDU-传输协议数据单元<br>全称为：Transport Protocol Data Unit<br>代表从一个传输实体发送到另一个传输实体的消息  </p></blockquote><p>其实在传输层，主要复习的是两个协议：</p><ol><li>传输控制协议TCP，全双工哦（双方可以并行发送数据）</li><li>用户数据报协议UDP </li></ol><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><span id="TCP">TCP</span></h3><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于三握四挥<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;TCP协议，是一个<code>面向连接的、可靠、基于字节流</code>的传输协议（所以相对UDP较慢），那么TCP是如何通信的呐（其实就是三次握手），既然可以通信，那么也就是说也可以断开通信咯，emmmm,怎么断！（大家挥挥手就断了）</p><p><strong>三次握手</strong>  </p><p>传输说明：</p><blockquote><p>SYN = 同步位，建立连接的时候必须要带上的，而且，人家虽然没有数据传输，但是还是要消耗一个序号的<br>seq = 序号，无论什么情况，只要是发送数据，都必须带一个序号<br>ACK = 是用来确认报文滴，只有两个值0和1，1代表确认<br>ack = 是对对方数据的确认号 = 对方的序号+1</p></blockquote><p>状态说明：</p><blockquote><p>CLOSED = 代表关闭状态<br>LISTEN = 收听状态<br>SYN_SENTT = 同步发送状态<br>SYN_RCVD = 同步收到状态<br>ESTAB_LISTHED = 已建立连接状态   </p></blockquote><p><img src="/2019/04/02/三次握手四次挥手/README/woshou.png" alt=""></p><p>至此，双方已经连接上了，这里需要注意的是，自己的序号每次都是+1的，那么发送的确认号，是<code>对方</code>的序号+1</p><p><strong>四次挥手</strong>  </p><p>说明：</p><blockquote><p>FIN = 终止控制位，和SYN一样，即使不携带数据，也是需要一个序号位的。  </p></blockquote><blockquote><p>ESTABLISHED = 建立连接<br>FIN_WAIT-1 = 终止等待1<br>FIN_WAIT-2 = 终止等待2<br>CLOSE_WAIT = 关闭等待<br>TIME_WAIT = 时间等待，一般设为2MSL(Maximum Segment Lifetime,建议设为2分钟)</p></blockquote><p><img src="/2019/04/02/三次握手四次挥手/README/huishou.png" alt=""></p><p>了解他的机制之后，那么接下来就是一个问答时间了：<br>题1：  </p><blockquote><p>为什么是三握四挥？  </p></blockquote><p>答：  </p><blockquote><p>因为当服务器端接收到客户端的请求报文后，是可以直接发送SYN_ACK报文的。<br>那么关闭的时候，服务器端在接收到FIN报文后，很可能不能立即关闭SOCKET，所以此时，服务器会发送一个确认报文，告诉客户端，我已经收到你的消息了，注意，此时不是终止报文，只有当服务器端的所有报文都发送完了，那么服务器端才会发送一个FIN报文，然后客户端再告诉服务器端，嗯，我也接收到你的消息了</p></blockquote><p>题2：  </p><blockquote><p>为什么客户端再TIME_WAIT状态下必须等待2MSL的时间呐？ </p></blockquote><p>答：</p><blockquote><p>(1)保证客户端发送的最后一个ACK报文能够到达服务器端。毕竟我们的报文还是存在丢失的可能性的，如果处在LAST_WAIT状态的服务器收不到对方的确认报文，那么服务器会重新发送，那么客户端就有时间再次发送报文，然后将计时器设置为2MSL<br>(2)为了防止“已经失效的连接请求报文段”出现在本连接中。相对在下一次连接的时候，竟然还能收到上次连接时的报文，不会很头疼么？？？这就是替别人擦屁股啊！！所以就要尽可能的让他在网络中消失！</p></blockquote><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP，，用户数据报协议，是和TCP在一层的，他们都在传输层<br>Emmmm，这个东西，不大靠谱，竟然不进行连接，都不知道发送的数据是否安全的、完整的到达目的地，啧，渣男！<br>太渣了，后续再写</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三握四挥&quot;&gt;&lt;a href=&quot;#三握四挥&quot; class=&quot;headerlink&quot; title=&quot;三握四挥&quot;&gt;&lt;/a&gt;三握四挥&lt;/h1&gt;&lt;p&gt;本篇文章讲解的是TCP协议三次握手和四次挥手的一个详情。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>树之4个迭代遍历</title>
    <link href="http://yoursite.com/2019/03/23/%E6%A0%91%E4%B9%8B4%E4%B8%AA%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/03/23/树之4个迭代遍历/</id>
    <published>2019-03-23T03:23:04.000Z</published>
    <updated>2019-04-02T14:22:02.441Z</updated>
    
    <content type="html"><![CDATA[<p>以下的遍历都是迭代遍历   </p><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>层次遍历用到的是广度优先算法，BFS,从根节点开始一层层的搜索，所以在遍历的时候用到了队列<br>遍历的时候用到了两层循环，因为我们需要每一层的结点，用一个list存储，如果用一层循环的话，那么就是每一个结点用一个list存储。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">     List&lt;List&lt;Integer&gt;&gt; rlt = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">     if(root == null) &#123;</span><br><span class="line">     return rlt;</span><br><span class="line">     &#125;</span><br><span class="line">     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">     queue.offer(root);</span><br><span class="line">     while(!queue.isEmpty()) &#123;</span><br><span class="line">     int count = queue.size();</span><br><span class="line">     List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">     while(count&gt;0) &#123;</span><br><span class="line">     TreeNode node = queue.poll();</span><br><span class="line">     list.add(node.val);</span><br><span class="line">     if(node.left != null) &#123;</span><br><span class="line">     queue.offer(node.left);</span><br><span class="line">     &#125;</span><br><span class="line">     if(node.right != null) &#123;</span><br><span class="line">     queue.offer(node.right);</span><br><span class="line">     &#125;</span><br><span class="line">     count--;</span><br><span class="line">     &#125;</span><br><span class="line">     rlt.add(list);</span><br><span class="line">     &#125;</span><br><span class="line">     return rlt;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>跟层次遍历不一样的是，后三种遍历都是用栈的形式，先进后出   </p><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>压栈顺序，先右后左<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">if(root == null)&#123;</span><br><span class="line">    return list;</span><br><span class="line">    &#125;</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">while(!stack.isEmpty())&#123;</span><br><span class="line">TreeNode node = stack.pop();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">if(node.right != null)&#123;</span><br><span class="line">stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">  if(node.left != null)&#123;</span><br><span class="line">stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>左孩子入栈，出栈，再开始右孩子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null||!stack.isEmpty())&#123;</span><br><span class="line">            while(root!=null)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>还没写哈哈哈哈哈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下的遍历都是迭代遍历   &lt;/p&gt;
&lt;h1 id=&quot;层次遍历&quot;&gt;&lt;a href=&quot;#层次遍历&quot; class=&quot;headerlink&quot; title=&quot;层次遍历&quot;&gt;&lt;/a&gt;层次遍历&lt;/h1&gt;&lt;p&gt;层次遍历用到的是广度优先算法，BFS,从根节点开始一层层的搜索，所以在遍历的时候用到了队列&lt;br&gt;遍历的时候用到了两层循环，因为我们需要每一层的结点，用一个list存储，如果用一层循环的话，那么就是每一个结点用一个list存储。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="http://yoursite.com/2019/03/21/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/21/经典排序算法/</id>
    <published>2019-03-21T06:35:25.000Z</published>
    <updated>2019-04-11T01:49:34.155Z</updated>
    
    <content type="html"><![CDATA[<p>嘀嘀嘀！经典排序算法来袭，本文里面，讲解一些什么算法呢，噔噔噔噔噔，看这里：<br>冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快排  （完）<br><a id="more"></a></p><p><img src="/2019/03/21/经典排序算法/total_O.png" alt="">  </p><p>排序之前，理解一下，一下7中排序，可以分为3类<br>（1）交换排序<br>&#160;&#160;&#160;&#160;&#160;冒泡排序<br>&#160;&#160;&#160;&#160;&#160;快速排序<br>（2）插入排序<br>&#160;&#160;&#160;&#160;&#160;直接插入排序<br>&#160;&#160;&#160;&#160;&#160;希尔排序<br>（3）选择排序<br>&#160;&#160;&#160;&#160;&#160;简单选择排序<br>&#160;&#160;&#160;&#160;&#160;堆排序<br>（4）归并排序<br>&#160;&#160;&#160;&#160;&#160;归并排序  </p><p>归并排序是排序算法进行优化后，唯一稳定的（强！）</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序，是<em>相邻</em>的两个数两两对比<br>上图！（emmmmm,盗图嘎嘎嘎嘎嘎嘎）<br><img src="https://media.giphy.com/media/555q4ngZRoxHCtGSrT/giphy.gif" alt="Alt Text">  </p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">bubble(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void bubble(int[] str,int length) &#123;</span><br><span class="line">boolean flag = false;</span><br><span class="line">for(int i=0;i&lt;length-1;i++) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">for(int j=0;j&lt;length-1-i;j++) &#123;</span><br><span class="line">if(str[j]&gt;str[j+1]) &#123;</span><br><span class="line">int tmp = str[j];</span><br><span class="line">str[j] = str[j+1];</span><br><span class="line">str[j+1] = tmp;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            //没有进入到交换里面，说明已经排好序了，直接退出就好了</span><br><span class="line">if(!flag) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><img src="https://media.giphy.com/media/8gLh5k8Kv6rIJzkK4g/giphy.gif" alt="Alt Text"><br>第i趟找出最i小的值，每趟排序都能确定一个位置，注意这里标记的是下标哟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 直接选择排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SelectSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">select(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void select(int[] str, int length) &#123;</span><br><span class="line">int min = 0;</span><br><span class="line">int tmp;</span><br><span class="line">for(int i=0;i&lt;length-1;i++) &#123;</span><br><span class="line">min = i;</span><br><span class="line">for(int j=i+1;j&lt;length;j++) &#123;</span><br><span class="line">if(str[j]&lt;str[min]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(min != i) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">str[i] = str[min];</span><br><span class="line">str[min] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>怎么说，，这是一个我总会遗忘的排序，可能是理解的不够透彻    </p><p>认为第一个元素是已经被排序的，取出下一个元素，和前面的元素进行对比，而且是从后往前对比的，每趟排序，前i个元素都是有序的  </p><p>在简单的排序中，效率算是很高了    </p><p><img src="https://media.giphy.com/media/7zQ0f5CdcDj6D5wV4B/giphy.gif" alt="Alt Text">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 直接插入排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class InsertSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">insert(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void insert(int[] str, int length) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">int j;</span><br><span class="line">for(int i=1;i&lt;length;i++) &#123;</span><br><span class="line">if(str[i]&lt;str[i-1]) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">//从后往前哟,而且要注意j取值j&gt;0</span><br><span class="line">for(j= i;j&gt;0 &amp;&amp; str[j-1]&gt;tmp ;j--) &#123;</span><br><span class="line">//发现大的，依次往后移动一位</span><br><span class="line">str[j] = str[j-1];</span><br><span class="line">&#125;</span><br><span class="line">//那么找不到比他大的后，tmp就在该位置上</span><br><span class="line">str[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p> 希尔排序是需要一个递增序列的，先进行分组，然后再排序，它是基于插入排序的  ，那么这个递增序列，shell是有个建议的（😀）:<br>    d = n/2(向下取整)和 d(i) = d(i+1)/2(向下取整)</p><p><img src="https://media.giphy.com/media/1fWmXxhJ6Qdt1E9MHL/giphy.gif" alt="Alt Text"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ShellSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">shell(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void shell(int[] str, int length) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">int j;</span><br><span class="line">//分组：7,3,1</span><br><span class="line">for(int d= length/2;d&gt;0;d /= 2) &#123;</span><br><span class="line">for(int i=d;i&lt;length;i++) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">for(j = i;j&gt;=d &amp;&amp; str[j-d]&gt;tmp;j -= d) &#123;</span><br><span class="line">str[j] = str[j-d];</span><br><span class="line">&#125;</span><br><span class="line">str[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>大顶堆：每个结点的值都大于或等于其左右孩子结点的值<br>    a[i]&gt;=a[2<em>i+1] &amp;&amp; a[i]&gt;=a[i=2</em>i+2]<br>小顶堆：每个结点的值都小于或等于其左右孩子结点的值    </p><p>大顶堆：<br><img src="https://media.giphy.com/media/dtZVQy94EYzuxleArI/giphy.gif" alt="Alt Text">    </p><p>其实就是一个二叉树    </p><p>说明：</p><ul><li>当结点为i</li><li>那么左孩子为2*i+1;</li><li>右孩子为2*i+2;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">buildHeap(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构建大顶堆</span><br><span class="line"> * @param str</span><br><span class="line"> * @param length</span><br><span class="line"> */</span><br><span class="line">private static void buildHeap(int[] str, int length) &#123;</span><br><span class="line">//从第一个非叶子结点开始调整，从左至右，从上至下</span><br><span class="line">//-1是根据下标从0开始的习惯来的</span><br><span class="line">for(int i = length/2-1;i&gt;=0;i--) &#123;</span><br><span class="line">//构建</span><br><span class="line">heapAdjust(str, i , length);</span><br><span class="line">&#125;</span><br><span class="line">//调整</span><br><span class="line">for(int i = length-1;i&gt;0;i--) &#123;</span><br><span class="line">swap(str,0,i);//&quot;最大的&quot;进行互换</span><br><span class="line">heapAdjust(str, 0, i);//换完之后，进行调整</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] str, int i, int length) &#123;</span><br><span class="line">int tmp = str[i];</span><br><span class="line">str[i] = str[length];</span><br><span class="line">str[length] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void heapAdjust(int[] str, int i, int length) &#123;</span><br><span class="line">int j;</span><br><span class="line">int tmp;</span><br><span class="line">tmp = str[i];</span><br><span class="line">for(j = 2*i+1;j&lt;length;j*=2+1) &#123;</span><br><span class="line">//右孩子&gt;左孩子</span><br><span class="line">if(j != length-1 &amp;&amp; str[j]&lt;str[j+1]) &#123;</span><br><span class="line">j++;//指向最大的孩子</span><br><span class="line">&#125;</span><br><span class="line">if(tmp &gt;= str[j]) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str[i] = str[j];</span><br><span class="line">//注意，这里面的交换，是交换标记的位置</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>合并两个已经排好序的表，所以需要用递归将其分成最小的分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 归并排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">mergebulid(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergebulid(int[] str, int length) &#123;</span><br><span class="line">int[] tmp = new int[length];</span><br><span class="line">merge(str, tmp, 0, length-1);</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] str, int[] tmp, int left , int right) &#123;</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int center = (left+right)/2;</span><br><span class="line">merge(str, tmp, left, center);</span><br><span class="line">merge(str, tmp, center+1, right);</span><br><span class="line"></span><br><span class="line">mergeSort(str, tmp, left, center, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergeSort(int[] str, int[] tmp, int left, int center, int right) &#123;</span><br><span class="line">int i = left;</span><br><span class="line">int j = center+1;</span><br><span class="line">int k = 0;</span><br><span class="line">while(i&lt;=center &amp;&amp; j&lt;=right) &#123;</span><br><span class="line">if(str[i]&lt;str[j]) &#123;</span><br><span class="line">tmp[k++] = str[i++];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tmp[k++] = str[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;=center) &#123;</span><br><span class="line">tmp[k++] = str[i++];</span><br><span class="line">&#125;</span><br><span class="line">while(j&lt;=right) &#123;</span><br><span class="line">tmp[k++] = str[j++];</span><br><span class="line">&#125;</span><br><span class="line">//将排序好的数组拷贝到原数组中</span><br><span class="line">k = 0;</span><br><span class="line">while(left&lt;= right) &#123;</span><br><span class="line">str[left++] = tmp[k++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>快速排序就是要找一个枢纽元，常用的找枢纽元方法为：</p><ul><li>第一个元素代替，有的书上说是比较错误的做法</li><li>随机选取，是比较安全的做法</li><li>三数中值分割法<br>头，尾，中间三个数，找到枢纽元（中值），放在倒数第二个位置上</li></ul><p>快排思想：</p><ul><li>i指向第一个元素，j指向倒数第二个元素，所有的循环，必须i&lt;j</li><li>j左移，直到找到比枢纽元小的元素，或者直到i&lt;j不成立  </li><li>i右移，直到找到比枢纽元大的元素，或者直到i&lt;j不成立</li><li>如果满足i&lt;j，交换</li></ul><p>一直循环第2，3步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 快速排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class QuickSork &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">quick(str,0,str.length-1);</span><br><span class="line">for(int i=0;i&lt;str.length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void quick(int[] str, int left, int right) &#123;</span><br><span class="line">//找到枢纽元</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int pivot = median3(str,left,right);</span><br><span class="line">int i=left,j = right-1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">               //从左到右找大于pivot的值</span><br><span class="line">                //不是i++,因为第一个元素我们之前已经对比过了</span><br><span class="line">while(str[++i]&lt;pivot) &#123;&#125;</span><br><span class="line">//从右到左找到小于pivot的值</span><br><span class="line">while(j&gt;left &amp;&amp; str[--j]&gt;pivot) &#123;&#125;</span><br><span class="line">if(i&lt;j) &#123;</span><br><span class="line">swap(str, i, j);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;right) &#123;</span><br><span class="line">swap(str, i, right-1);</span><br><span class="line">&#125;</span><br><span class="line">quick(str,left,i-1);</span><br><span class="line">quick(str, i+1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int median3(int[] str, int left, int right) &#123;</span><br><span class="line">int center = (left+right)/2;</span><br><span class="line">if(str[left]&gt;str[center]) &#123;</span><br><span class="line">swap(str, left, center);</span><br><span class="line">&#125;</span><br><span class="line">if(str[center]&gt;str[right]) &#123;</span><br><span class="line">swap(str, center, right);</span><br><span class="line">&#125;</span><br><span class="line">if(str[left]&gt;str[right]) &#123;</span><br><span class="line">swap(str, left, right);</span><br><span class="line">&#125;</span><br><span class="line">swap(str, center, right-1);</span><br><span class="line">return str[right-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] str, int left, int right) &#123;</span><br><span class="line">int tmp = str[left];</span><br><span class="line">str[left] = str[right];</span><br><span class="line">str[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘀嘀嘀！经典排序算法来袭，本文里面，讲解一些什么算法呢，噔噔噔噔噔，看这里：&lt;br&gt;冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快排  （完）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>树之平衡二叉树</title>
    <link href="http://yoursite.com/2019/03/20/%E6%A0%91%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/20/树之平衡二叉树/</id>
    <published>2019-03-19T23:11:28.000Z</published>
    <updated>2019-03-20T07:03:37.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>是二叉排序树的一种，在二叉树中，可能会出现比较极端的二叉树，例如斜树，这样在查找的过程中，很影响效率，而平衡二叉排序树就很好的解决了这个问题。<br><a id="more"></a><br>AVL（和AVL算法有区别）,要么是一棵空树，要么左右子树都是平衡二叉树，且左右子树的深度之差的绝对值不超过1，算法复杂度O(lon(n))<br>又名平衡二叉搜索树Self-balancing binary search tree  </p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><ol><li>红黑树<br>一种自平衡二叉查找树，可以用于实现关联数组，又称为“对称二叉B树”</li><li><p>AVL<br>最早的自平衡二叉查找树算法，也是高度平衡树</p></li><li><p>替罪羊树</p></li><li>Treap<br>一棵二叉排序树，记录一个额外的数据（优先级），有堆的性质</li><li>伸展树<br>Splay Tree ,一种二叉排序树，优势为不需要记录用于平衡树的冗余信息</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>将一棵二叉树，变成平衡二叉树，依靠的是旋转，通常会出现四种情况<br>（1）左旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_left.png" alt=""><br>（2）右旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_right.png" alt=""><br>（3）左右旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_leftright.png" alt=""><br>（4）右左旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_rightleft.png" alt=""></p><p>总之，什么时候双旋转呢？那就是bf符号不一致的时候，<br>什么时候会失去平衡呢，简单总结就是4句话  </p><ul><li>在左孩子的左子树上插入元素 - 右旋转</li><li>在左孩子的右子树上插入元素 - 左右旋转</li><li>在右孩子的右子树上插入元素 - 左旋转</li><li>在右孩子的左子树上插入元素 - 右左旋转<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>设一个平衡因子bf<br>IF 平衡因子 &gt;=2<br>&#160;&#160;&#160;&#160;IF 左结点的平衡因子 &lt;0<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;左旋转然后右旋转<br>&#160;&#160;&#160;&#160;&#160;ELSE<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;右旋转<br>ELSE IF 平衡因子 &lt;=-2<br>&#160;&#160;&#160;&#160;&#160;&#160;IF 右结点的平衡因子 &gt;0<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;右旋转<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ELSE<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;左旋转</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.tree;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 平衡二叉树</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AVL &#123;</span><br><span class="line">private static final int ALLOWED_IMBALANCE = 1;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str = &#123;10,5,8,20,16,1,3,7,25&#125;;</span><br><span class="line">Tree tree = new Tree(str[0]);</span><br><span class="line">for(int i=1;i&lt;str.length;i++) &#123;</span><br><span class="line">insertAvl(tree,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">print(tree);</span><br><span class="line">System.out.println();</span><br><span class="line">remove(tree,10);</span><br><span class="line">print(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除某个结点</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param i</span><br><span class="line"> */</span><br><span class="line">private static Tree remove(Tree tree, int key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">if(key&lt;tree.getData()) &#123;</span><br><span class="line">tree.setLchild(remove(tree.getLchild(), key));</span><br><span class="line">&#125; else if(key&gt;tree.getData()) &#123;</span><br><span class="line">tree.setRchild(remove(tree.getRchild(), key));</span><br><span class="line">&#125;else if(tree.getLchild() != null &amp;&amp; tree.getRchild() != null) &#123;</span><br><span class="line">tree.setData(findMin(tree.getRchild()).getData());</span><br><span class="line">tree.setRchild(remove(tree.getRchild(), tree.getData()));</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = (tree.getLchild() != null)?tree.getLchild():tree.getRchild();</span><br><span class="line">&#125;</span><br><span class="line">return balanceAVL(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 找到右子树中最小的左子树（后继结点）</span><br><span class="line"> * @param data</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree findMin(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree;</span><br><span class="line">while(tree.getLchild() != null) &#123;</span><br><span class="line">tree = tree.getLchild();</span><br><span class="line">tmp = tree;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(tmp.getData());</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算平衡因子</span><br><span class="line"> */</span><br><span class="line">private static int hight(Tree tree) &#123;</span><br><span class="line">return tree == null ?-1 :tree.getBf();</span><br><span class="line">&#125;</span><br><span class="line">private static void print(Tree tree) &#123;</span><br><span class="line">if(tree != null) &#123;</span><br><span class="line">print(tree.getLchild());</span><br><span class="line">System.out.print(tree.getData()+&quot; &quot;);</span><br><span class="line">print(tree.getRchild());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**  </span><br><span class="line"> * 插入</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param key  带插入的元素</span><br><span class="line"> */</span><br><span class="line">private static Tree insertAvl(Tree tree, int  key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return new Tree(key, null, null);</span><br><span class="line">&#125; else if(key &lt; tree.getData())&#123;//插入在左子树</span><br><span class="line">tree.setLchild(insertAvl(tree.getLchild(), key));</span><br><span class="line">&#125; else if(key &gt; tree.getData())&#123;</span><br><span class="line">tree.setRchild(insertAvl(tree.getRchild(), key));</span><br><span class="line">&#125;</span><br><span class="line">return balanceAVL(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否平衡</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree balanceAVL(Tree tree) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">if(hight(tree.getLchild())-hight(tree.getRchild())&gt;ALLOWED_IMBALANCE) &#123;//左子树失去了平衡</span><br><span class="line">if(hight(tree.getLchild().getLchild())&gt;=hight(tree.getLchild().getRchild())) &#123;//将值插入到右子树</span><br><span class="line">tree = rotateWithLeftChild(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = doubleWithLeftChild(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(hight(tree.getRchild())-hight(tree.getLchild())&gt;ALLOWED_IMBALANCE) &#123;</span><br><span class="line">if(hight(tree.getRchild().getRchild())&gt;=hight(tree.getRchild().getLchild())) &#123;</span><br><span class="line">tree = rotateWithRightChild(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = doubleWithRightChild(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 先左转再右转</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree doubleWithLeftChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getLchild();</span><br><span class="line">tmp.setLchild(rotateWithRightChild(tmp));</span><br><span class="line">return rotateWithLeftChild(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Tree doubleWithRightChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getRchild();</span><br><span class="line">tmp.setRchild(rotateWithLeftChild(tmp));</span><br><span class="line">return rotateWithRightChild(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 单旋转，将左子树旋转到右子树</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree rotateWithLeftChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getLchild();</span><br><span class="line">tree.setLchild(tree.getRchild());</span><br><span class="line">tmp.setRchild(tree);</span><br><span class="line">tree.setBf(Math.max(hight(tree.getLchild()), hight(tree.getRchild()))+1);</span><br><span class="line">tmp.setBf(Math.max(hight(tmp.getLchild()), tree.getBf())+1);</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Tree rotateWithRightChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getRchild();</span><br><span class="line">tree.setRchild(tree.getLchild());</span><br><span class="line">tmp.setRchild(tree);</span><br><span class="line">tree.setBf(Math.max(hight(tree.getLchild()), hight(tree.getRchild()))+1);</span><br><span class="line">tmp.setBf(Math.max(hight(tmp.getRchild()), tree.getBf())+1);</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;是二叉排序树的一种，在二叉树中，可能会出现比较极端的二叉树，例如斜树，这样在查找的过程中，很影响效率，而平衡二叉排序树就很好的解决了这个问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树之二叉排序树</title>
    <link href="http://yoursite.com/2019/03/19/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/19/树之二叉排序树/</id>
    <published>2019-03-19T04:54:49.000Z</published>
    <updated>2019-03-23T03:26:23.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>树里面的精华哟，因为利用了二进制<br>Binary Sort Tree 又称为二叉查找树ADT，它可以是一棵空树，或者具有一下性质的树：<br><a id="more"></a></p><ul><li>若左子树不为空，那么左子树上所有结点的值均小于根结构的值</li><li>若右子树不为空，那么右子树上所有结点的值均大于跟结构的值</li><li>它的左右子树分别为二叉排序树</li></ul><p>说明了啥呢，，，，，，哈哈哈哈，人家是递归呀  </p><p>对了，就是树的中序遍历</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean SearchBST(Tree t, int key)&#123;</span><br><span class="line">if(t == null)&#123;</span><br><span class="line">return false;</span><br><span class="line">    &#125; else if (t.data == key)&#123;</span><br><span class="line">return true;</span><br><span class="line">    &#125; else if(key&lt;t.data)&#123;</span><br><span class="line">return Search(t.lchild, key);</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">return Search(t.rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除的时候，要注意，该位置用哪个结点进行填充，有一个规则是：<br>要么是当前结点的前驱，要么是当前结点的后继（根据中序遍历的特点来的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static boolean deleteBST(Tree tree, int key) &#123;</span><br><span class="line">if(tree != null) &#123;</span><br><span class="line">if(key == tree.getData()) &#123;</span><br><span class="line">delete(tree);</span><br><span class="line">return true;</span><br><span class="line">&#125;else if(key&lt;tree.getData()) &#123;</span><br><span class="line">return deleteBST(tree.getLchild(), key);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return deleteBST(tree.getRchild(), key);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void delete(Tree tree) &#123;</span><br><span class="line">Tree q,s;//上一个结点</span><br><span class="line">if(tree.getRchild() == null) &#123;//叶子结点</span><br><span class="line">q = tree;</span><br><span class="line">//tree = tree.getLchild();</span><br><span class="line">tree.setData(tree.getLchild().getData());</span><br><span class="line">tree.setLchild(null);</span><br><span class="line">&#125; else if(tree.getLchild() == null) &#123;</span><br><span class="line">q = tree;</span><br><span class="line">//tree = tree.getRchild();</span><br><span class="line">tree.setData(tree.getRchild().getData());</span><br><span class="line">tree.setRchild(null);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">//替换直接前驱或者直接后继</span><br><span class="line">q = tree;</span><br><span class="line">s = tree.getLchild();</span><br><span class="line">while(s.getRchild() != null) &#123;</span><br><span class="line">q = s;</span><br><span class="line">s = s.getRchild();</span><br><span class="line">&#125;</span><br><span class="line">tree.setData(s.getData());</span><br><span class="line">if(q != tree) &#123;//判断有没有右子树</span><br><span class="line">q.setRchild(s.getLchild());</span><br><span class="line">&#125;else &#123;</span><br><span class="line">q.setLchild(s.getLchild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入元素</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param i</span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">private static Tree insertSort(Tree tree, int key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">tree = new Tree(key);</span><br><span class="line">return tree;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if(key&lt;=tree.getData()) &#123;</span><br><span class="line">tree.setLchild(insertSort(tree.getLchild(), key));</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree.setRchild(insertSort(tree.getRchild(), key));</span><br><span class="line">&#125;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str = &#123;111,104,105,46,115,99,70,109,67&#125;;</span><br><span class="line">Tree tree = new Tree(str[0]);</span><br><span class="line">for(int i=1;i&lt;str.length;i++) &#123;</span><br><span class="line">insertSort(tree,str[i]);</span><br><span class="line">//tmp = tree;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;中序遍历：&quot;);</span><br><span class="line">print(tree);</span><br><span class="line">//假设删除的是数据105</span><br><span class="line">if(deleteBST(tree,105)) &#123;</span><br><span class="line">System.out.print(&quot;\n删除后:&quot;);</span><br><span class="line">print(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\n删除结点不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 打印二叉树</span><br><span class="line"> * @param tree</span><br><span class="line"> */</span><br><span class="line">private static void print(Tree tree) &#123;</span><br><span class="line"></span><br><span class="line">if(tree != null)&#123;</span><br><span class="line">print(tree.getLchild());</span><br><span class="line">System.out.print(tree.getData()+&quot; &quot;);</span><br><span class="line">print(tree.getRchild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：46 67 70 99 104 105 109 111 115<br>删除后:46 67 70 99 104 109 111 115 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;树里面的精华哟，因为利用了二进制&lt;br&gt;Binary Sort Tree 又称为二叉查找树ADT，它可以是一棵空树，或者具有一下性质的树：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>图论之关键路径</title>
    <link href="http://yoursite.com/2019/03/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/03/19/图论之关键路径/</id>
    <published>2019-03-19T02:23:23.000Z</published>
    <updated>2019-03-19T03:36:11.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li>源点<br>没有入度的顶点</li><li>汇点<br>没有出度的顶点</li><li>事件<br>顶点</li><li>活动<br>弧<a id="more"></a><h1 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h1>再带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图称为AOE网：Activity Edge Network<h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1>最长路径之和<br>关键路径是建立在拓扑序列上的</li></ol><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><h2 id="ETV"><a href="#ETV" class="headerlink" title="ETV"></a>ETV</h2><p>Earliest Time Of Vertex 时间最早发生时间，就是顶点的最早发生时间</p><h2 id="LTV"><a href="#LTV" class="headerlink" title="LTV"></a>LTV</h2><p>Latest Time Of Vertex:事件最晚发生时间，就是每个顶点对应的事件最晚需要开始的时间，如果超出此事件就会延误整个工期。</p><h2 id="ETE"><a href="#ETE" class="headerlink" title="ETE"></a>ETE</h2><p>Earliesr Time Of Edge:活动的最早开始事件，就是弧的最早发生时间</p><h2 id="LTE"><a href="#LTE" class="headerlink" title="LTE"></a>LTE</h2><p>Latest Time Of Edge:活动的最晚发生时间，就是不推迟工期的最晚开工时间。</p><p><img src="/2019/03/19/图论之关键路径/aoe_1.PNG" alt=""></p><p><img src="/2019/03/19/图论之关键路径/aoe_2.PNG" alt=""> </p><p>由此可发现：<br>ETV，ETE是顺序来的<br>LTV，LTE是逆序来的<br>ETV可以推断出ETE<br>LTV可以推断出LTE<br>关键路径：最早发生时间ETV和最晚发生时间LTV相等的时候 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;源点&lt;br&gt;没有入度的顶点&lt;/li&gt;
&lt;li&gt;汇点&lt;br&gt;没有出度的顶点&lt;/li&gt;
&lt;li&gt;事件&lt;br&gt;顶点&lt;/li&gt;
&lt;li&gt;活动&lt;br&gt;弧&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图论之拓扑结构</title>
    <link href="http://yoursite.com/2019/03/18/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/18/图论之拓扑结构/</id>
    <published>2019-03-18T07:40:55.000Z</published>
    <updated>2019-03-19T03:35:59.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无环图"><a href="#无环图" class="headerlink" title="无环图"></a>无环图</h1><p>DAG：Directed Acyclic Graph<br>五环的有向图</p><h1 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h1><p>Active On Vertex Network,有向图为顶点表示活动的网<br><a id="more"></a></p><h1 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><p>&#160;&#160;&#160;&#160;&#160;&#160;设G = (V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,…,Vn满足：若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则这样的一个顶点序列称为 拓扑序列</p><h1 id="拓扑序列-1"><a href="#拓扑序列-1" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><p>将一个有向图构造成一个拓扑序列的过程   </p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从AOV网中选择一个没有前驱的顶点（入度为0），并且输出它  </li><li>从网中删除该顶点并且删除从该顶点出发的全部有向边  </li><li>重复以上两个步骤，直到剩余网中不再存在没有前驱的顶点为止   </li></ol><p>可以用邻接表实现哟，因为要删除顶点，所以会比邻接矩阵方便一些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean topologicalSort() &#123;</span><br><span class="line">    //统计输出顶点数</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    //建栈存储入度为0的顶点</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    //统计入度数（录入也可以，但是示例图的v9的度应为2，示例图中误写为1，导致查了半天bug，自动统计入度数看来也是有必要的）</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        vexList.get(i).setIn(0);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        </span><br><span class="line">        EdgeNode edge = vexList.get(i).getFirstEdge();</span><br><span class="line">        while (edge != null) &#123;</span><br><span class="line">            VertexNode vex = vexList.get(edge.getAdjvex());</span><br><span class="line">            vex.setIn(vex.getIn() + 1);</span><br><span class="line">            </span><br><span class="line">            edge = edge.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将入度为0 的顶点入栈</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        if (vexList.get(i).getIn() == 0) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        //栈顶 顶点出栈</span><br><span class="line">        int vexIndex = stack.pop();</span><br><span class="line">        System.out.print(vexIndex + &quot;  &quot;);</span><br><span class="line">        </span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        //从顶点表结点中取出第一个边表结点</span><br><span class="line">        EdgeNode edge = vexList.get(vexIndex).getFirstEdge();</span><br><span class="line">        </span><br><span class="line">        while (edge != null) &#123;</span><br><span class="line">            int adjvex = edge.getAdjvex();</span><br><span class="line">            </span><br><span class="line">            VertexNode vex = vexList.get(adjvex);</span><br><span class="line">            </span><br><span class="line">            //将此 顶点的入度减一</span><br><span class="line">            vex.setIn(vex.getIn() - 1);</span><br><span class="line">            //此顶点的入度为零则入栈，以便于下次循环输出</span><br><span class="line">            if (vex.getIn() == 0) &#123;</span><br><span class="line">                stack.push(adjvex);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            edge = edge.getNext();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (count != vexList.size())</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 边表结点</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class EdgeNode &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 邻接点域，存储该顶点对应的下标</span><br><span class="line">     */</span><br><span class="line">    private int adjvex;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 用于存储权值，对于非网图可以不需要</span><br><span class="line">     */</span><br><span class="line">    private int weight;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 链域，指向下一个邻接点</span><br><span class="line">     */</span><br><span class="line">    private EdgeNode next;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    public EdgeNode(int adjvex, int weight, EdgeNode next) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.adjvex = adjvex;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getAdjvex() &#123;</span><br><span class="line">        return adjvex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setAdjvex(int adjvex) &#123;</span><br><span class="line">        this.adjvex = adjvex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getWeight() &#123;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setWeight(int weight) &#123;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public EdgeNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setNext(EdgeNode next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顶点表结点</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class VertexNode &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 顶点入度</span><br><span class="line">     */</span><br><span class="line">    private int in;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 顶点域，存储顶点信息（下标）</span><br><span class="line">     */</span><br><span class="line">    private int data;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 边表头指针</span><br><span class="line">     */</span><br><span class="line">    private EdgeNode firstEdge;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    public VertexNode(int in, int data, EdgeNode firstEdge) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.in = in;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.firstEdge = firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getIn() &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setIn(int in) &#123;</span><br><span class="line">        this.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setData(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public EdgeNode getFirstEdge() &#123;</span><br><span class="line">        return firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setFirstEdge(EdgeNode firstEdge) &#123;</span><br><span class="line">        this.firstEdge = firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用于判断一个图是否存在环，存在的话，返回false，否则返回true</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;无环图&quot;&gt;&lt;a href=&quot;#无环图&quot; class=&quot;headerlink&quot; title=&quot;无环图&quot;&gt;&lt;/a&gt;无环图&lt;/h1&gt;&lt;p&gt;DAG：Directed Acyclic Graph&lt;br&gt;五环的有向图&lt;/p&gt;
&lt;h1 id=&quot;AOV网&quot;&gt;&lt;a href=&quot;#AOV网&quot; class=&quot;headerlink&quot; title=&quot;AOV网&quot;&gt;&lt;/a&gt;AOV网&lt;/h1&gt;&lt;p&gt;Active On Vertex Network,有向图为顶点表示活动的网&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>关联分析之Apriori</title>
    <link href="http://yoursite.com/2019/03/15/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B9%8BApriori/"/>
    <id>http://yoursite.com/2019/03/15/关联分析之Apriori/</id>
    <published>2019-03-15T14:47:55.000Z</published>
    <updated>2019-03-15T14:50:42.549Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/15/关联分析之Apriori/apriori.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/03/15/关联分析之Apriori/apriori.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>来京第一次搬家</title>
    <link href="http://yoursite.com/2019/03/09/%E6%9D%A5%E4%BA%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AC%E5%AE%B6/"/>
    <id>http://yoursite.com/2019/03/09/来京第一次搬家/</id>
    <published>2019-03-09T13:50:23.000Z</published>
    <updated>2019-03-09T14:09:10.092Z</updated>
    
    <content type="html"><![CDATA[<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;2019年3月9日，从去年九月23号来京，将近半年了，这半年怎么说，感觉很浪费了，一是在于自己当初真的是太着急了，二是这半年来的得过且过。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;收拾东西的时候，很烦，真的很烦，东西太多了，两个行李箱，一个行李袋，外加好几个箱子，还有一些杂七杂八的东西，然后,emmmmm，懒癌犯了，想着，自己当初为什么要来北京，天津也不错啊，然后给自己的理由是，嗯，有小哥哥啊（甩锅给小哥哥，其实没他我也会在北京呆着，哎，（我的）才华配不上我的理想啊），难受的哭唧唧<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;不过搬家前有朋友一直再说帮我搬，很开心，然后今天搬家的时候，朋友特地开车过来帮忙，美滋滋呀，有朋友帮忙的感觉是真的好呀。  </p><p>今天就当作是新的开始好了</p><p>一切都要加油哟！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;2019年3月9日，从去年九月23号来京，将近半年了，这半年怎么说，感觉很浪费了，一是在于自己当初真的是太着急了，二是这半年来的得过且过。&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#16
      
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理</title>
    <link href="http://yoursite.com/2019/03/05/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/05/正向代理和反向代理/</id>
    <published>2019-03-05T10:00:58.000Z</published>
    <updated>2019-03-07T03:21:28.998Z</updated>
    
    <content type="html"><![CDATA[<p>对于代理一直比较懵，现在把理解出来的代理记下来~~~因为我觉得我会忘掉了，如果长时间不看  </p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>对于一个无法访问的网站，例如Google，我们就需要一个代理<br>我们向代理发送一个请求，代理转发请求去网站拿数据，再把请求发送回来<br><a id="more"></a></p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ul><li>可以做缓存</li><li>加快访问速度</li><li>代理可以记录用户访问记录，对外隐藏用户信息</li><li>对客户端（用户）访问授权，上网进行认证</li></ul><p>所以我们需要去租一个服务器，然后在主机上进行配置，就可以<em>科学上网</em>啦  </p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>Reverse Proxy   </p><p>这里比较神奇，客户端竟然都不知道代理的存在！！！<br>反向代理对外都是透明的<br>因此啊，访问者根本不知道自己访问的是一个网站，还是一个代理！！！   哼，流氓   </p><p>Nginx就是一个反向代理<br>客户端访问一个网站（代理）时：</p><p>客户端发送请求给代理，此时的代理有内网和外网，外网是公共访问地址，这时候反响代理服务器拿着请求，找到内网地址，去到了对应的服务器  </p><h2 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h2><ul><li>一般大型的网站，使用的都是反向代理，将反向代理作为公网的访问地址，WEB服务器是内网。   </li><li>负载均衡，通过反向代理服务器来优化网站的负载  </li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>盗个图<br><img src="/2019/03/05/正向代理和反向代理/proxy.PNG" alt="">  </p><p>正向代理中，proxy和client属于同一个LAN，对server透明<br>反向代理中，proxy和server属于同一个LAN，对client透明   </p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>一款轻量级的Web服务器/反向代理服务器，工作在七层的http协议的负载均衡系统  </p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>模块化设计<br>扩展性好</li><li>高可靠性<br>主控进程heworker是同步实现的，一个worker出现问题，会立刻启动另一个worker  </li><li>低内存<br>一万个长连接(keep-alive)，仅消耗2.5MB内存  </li><li>支持热部署<br>不用停止服务器，实现更新配置文件，更新日志文件，跟新服务器程序版本。</li><li>高并发<br>官方数据，每秒支持5万并发。</li><li>功能丰富<br>优秀的反向代理功能和灵活的负载均衡策略   </li></ul><p>还有很多，这里只是一个大概的了解  </p><p>吼吼吼</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于代理一直比较懵，现在把理解出来的代理记下来~~~因为我觉得我会忘掉了，如果长时间不看  &lt;/p&gt;
&lt;h1 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h1&gt;&lt;p&gt;对于一个无法访问的网站，例如Google，我们就需要一个代理&lt;br&gt;我们向代理发送一个请求，代理转发请求去网站拿数据，再把请求发送回来&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>树之最小生成树</title>
    <link href="http://yoursite.com/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/01/图论之最小生成树/</id>
    <published>2019-03-01T02:30:47.000Z</published>
    <updated>2019-03-18T07:41:52.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树 MST"></a>最小生成树 MST</h1><p>最小，指的是权值的和最小</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Minimum Spanning Tree.一个有n个结点的<em>连通图</em>的生成树 是  原图的极小连通子图，且包含原图中的所有n个结点，并且保持图连通的最少的边<br>本身是一棵树<br><a id="more"></a><br>所以一定是无环的哟<br>两个典型的算法，为啥是两个呢，因为啊，哎，两个人提出来的，然后就根据名字来命名了！</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法(Prim)"></a>普里姆算法(Prim)</h2><p>体现了回溯法和贪心算法</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>（1）输入：一个加权的连通图，其中呢，顶点集合为V，边集合为E(呀哈，邻接矩阵，邻接链表也可以哟)<br>（2）初始化：全都初始化为0<br>（3）首先随意的选取一个顶点，再选取权值最小的边，标记这两个顶点<br>（4）若有一个顶点，连接一个以上被标记的顶点，舍去权值最大的那条边<br>（5）一直执行第三步，知道遍历完所有的边</p><p><strong><em>要注意</em></strong><br>千万不能形成一个环呀</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>（1）选取一个顶点（0）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_1.PNG" alt=""><br>（2）找到与之相连的，权值最小的边和顶点<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_2.PNG" alt=""><br>（3）即第四步，舍弃权值最大的那条边（舍弃权值为：6和7）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_3.PNG" alt=""><br>（4）重复第三步，找到当前顶点，权值最小的边和顶点（顶点5）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_4.PNG" alt=""><br>（5）重复第四步，舍去边（5和6）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_5.PNG" alt=""><br>（6）重复第三步，选出最小边，相等时，随便选<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_6.PNG" alt=""><br>（7）重复第四步，社区最大边<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_7.PNG" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * prim算法实现最小生成树</span><br><span class="line"> * @param g 图</span><br><span class="line"> */</span><br><span class="line">public static void MiniSpanTree_Prim(Graph g) &#123;</span><br><span class="line">int min, j, k;</span><br><span class="line">int maxvex  = 0;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共几个顶点&quot;);</span><br><span class="line">maxvex= scan.nextInt();</span><br><span class="line">int[] adjvex = new int[maxvex];//保存相关顶点下标</span><br><span class="line">int[] lowcoat = new int[maxvex];//保存相关顶点间边的权值</span><br><span class="line">lowcoat[0] = 0;</span><br><span class="line">adjvex[0] = 0;</span><br><span class="line">//初始化</span><br><span class="line">for(int i=1;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">lowcoat[i] =g.edges[0][i];</span><br><span class="line">adjvex[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">//构建</span><br><span class="line">for(int i=1;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">min = Integer.MAX_VALUE;//初始化已给不可能数值</span><br><span class="line">j = 1;</span><br><span class="line">k = 0;</span><br><span class="line">//遍历所有的顶点</span><br><span class="line">while(j&lt;g.numVertex) &#123;</span><br><span class="line">//找到lowcoat数组中存储的最小权值</span><br><span class="line">// == 0 是自己连线</span><br><span class="line">if(lowcoat[j] != 0 &amp;&amp; lowcoat[j]&lt;min) &#123;</span><br><span class="line">min = lowcoat[j];</span><br><span class="line">k = j;//将发现的最小权值的下标存入k,以待使用</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">//打印当前顶点边中权值最小的边</span><br><span class="line">System.out.println(adjvex[k]+&quot;-&quot;+k);</span><br><span class="line">lowcoat[k] = 0;//设置当前顶点的权值为0，表示此顶点已经完成任务</span><br><span class="line">//这里重要一点，逐个遍历邻接矩阵k行所有顶点</span><br><span class="line">for(j=1;j&lt;g.numVertex;j++) &#123;</span><br><span class="line">if(lowcoat[j] != 0 &amp;&amp; g.edges[k][j] &lt;lowcoat[j]) &#123;</span><br><span class="line">lowcoat[j] = g.edges[k][j];</span><br><span class="line">adjvex[j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="克鲁斯卡尔-Kruskal"><a href="#克鲁斯卡尔-Kruskal" class="headerlink" title="克鲁斯卡尔(Kruskal)"></a>克鲁斯卡尔(Kruskal)</h2><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>先构造一个只含n个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根节点，然后，从E中取出一条权值最小的边，如果这条边的两个顶点属于不同的树，那么将其加入子图(两棵树合成一棵树)；否则的话，不可以取哟，应该取下一条权值最小的边再试试。结束条件：森林中只有一棵树，也就是说，图里面有n-1条边为止。<br>原理是   只含顶点不含边的森林<br>本身是一个森林  </p><h2 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h2><p>用的是边界数组<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal.PNG" alt=""><br>边集数组是按照权值从小到达排序的<br>（1）找到边集数组中的边，直到所有的顶点都遍历完<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal_1.PNG" alt=""><br>（2）若边的两个顶点在同一棵树上，舍去，下一条边，若权值相等，随便选取一条<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal_2.PNG" alt=""></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAGEDGE = 5;</span><br><span class="line">class Edge&#123;</span><br><span class="line">int begin;</span><br><span class="line">int end;</span><br><span class="line">int weight;//权值</span><br><span class="line">&#125;</span><br><span class="line">public int find(int[] parent, int f) &#123;</span><br><span class="line">while(parent[f]&gt;0) &#123;</span><br><span class="line">f = parent[f];</span><br><span class="line">&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * kruskal算法实现最小生成树</span><br><span class="line"> */</span><br><span class="line">public void MiniSpanTree_Kruskal(Graph g) &#123;</span><br><span class="line">int i, n, m;</span><br><span class="line">Edge[] edges  = new Edge[MAGEDGE];//边集数组</span><br><span class="line">    int[] parent = new int[MAGEDGE];//用于判断是否形成回路</span><br><span class="line">    //初始化</span><br><span class="line">    for(i = 0;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">    parent[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">    n = find(parent,edges[i].begin);</span><br><span class="line">    m = find(parent,edges[i].end);</span><br><span class="line">    if(n != m) &#123;//否则的话，就形成了一个环路</span><br><span class="line">    parent[n] = m;//将此边的结尾顶点放入下标为起点的parent数组中，表示此顶点已经再生成树集合中</span><br><span class="line">    System.out.println(&quot;连接情况：&quot;+edges[i].begin+&quot;-&gt;&quot;+edges[i].end+&quot;权重为：&quot;+edges[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难理解的是parent数组，注意，parent数组的值是可以重复的！！！</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>克鲁斯卡尔适合边数少的图，普里姆适合边数多的图</p><p>以上算法都是<strong><em>贪心算法</em></strong>的应用</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最小生成树-MST&quot;&gt;&lt;a href=&quot;#最小生成树-MST&quot; class=&quot;headerlink&quot; title=&quot;最小生成树 MST&quot;&gt;&lt;/a&gt;最小生成树 MST&lt;/h1&gt;&lt;p&gt;最小，指的是权值的和最小&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;Minimum Spanning Tree.一个有n个结点的&lt;em&gt;连通图&lt;/em&gt;的生成树 是  原图的极小连通子图，且包含原图中的所有n个结点，并且保持图连通的最少的边&lt;br&gt;本身是一棵树&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图论之最短路径</title>
    <link href="http://yoursite.com/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/03/01/图论之最短路径/</id>
    <published>2019-03-01T02:27:28.000Z</published>
    <updated>2019-03-18T07:41:47.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>一个顶点到另一个顶点的最短路径，与最小生成树不同的是，这里最短路径不一定包含所有的顶点，但是最小生成树一定要包含所有的顶点。<br><a id="more"></a></p><h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>Dijkstra.算法复杂度O(n^2) 使用了贪心算法，求出所有的顶点路径。算法和prim相似，先赋值，再修正<br><img src="/2019/03/01/图论之最短路径/dijkstra.jpg" alt=""></p><p>啦啦啦啦啦，这个算法，其实，效率很低哈哈哈哈   </p><p>下图中的算法中，使用的是邻接矩阵</p><h2 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h2><p>Floyd.算法复杂度O(n^3),是动态规划的应用<br><img src="/2019/03/01/图论之最短路径/凸轮之最短路径/floyd.jpg" alt=""></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li>路径<br>迪杰斯特拉算法求的是一个顶点到所有顶点的最短路径<br>弗洛伊德算法求得是所有顶点到所有顶点得最短路径</li><li>弗洛伊德算法得代码更加简洁  </li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;最短路径&lt;/h1&gt;&lt;p&gt;一个顶点到另一个顶点的最短路径，与最小生成树不同的是，这里最短路径不一定包含所有的顶点，但是最小生成树一定要包含所有的顶点。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历</title>
    <link href="http://yoursite.com/2019/02/26/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/02/26/图的遍历/</id>
    <published>2019-02-25T16:17:34.000Z</published>
    <updated>2019-03-18T07:41:42.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>Depth First Search.  与树的先序遍历类似。从某个顶点出发，依次向下访问<br>分析：</p><ol><li>访问初始顶点v，并标记顶点v已经被访问<a id="more"></a></li><li>找到顶点v的第一个邻接顶点w</li><li>若顶点w存在，则执行第4步，否则结束算法</li><li>若顶点w未被访问，进行深度优先遍历（重复123步骤）</li><li>找到W的下一个邻接顶点，执行第3步</li></ol><h2 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><p>用的递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.synth.SynthSpinnerUI;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;String&gt; vertexList;//用来存储顶点信息</span><br><span class="line">private int[][] edges;//邻接矩阵，存储顶点之间的边信息</span><br><span class="line">private int numEdges;//边的数目</span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> * @param n</span><br><span class="line"> */</span><br><span class="line">public GraphVertex(int n) &#123;</span><br><span class="line">vertexList = new ArrayList&lt;&gt;(n);</span><br><span class="line">edges = new int[n][n];</span><br><span class="line">numEdges = 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到结点个数</span><br><span class="line"> */</span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return vertexList.size();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到边数</span><br><span class="line"> */</span><br><span class="line">public int getNumEdges() &#123;</span><br><span class="line">return numEdges;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param i</span><br><span class="line"> * @return 返回第i个结点的信息</span><br><span class="line"> */</span><br><span class="line">public String getValueByIndex(int i) &#123;</span><br><span class="line">return vertexList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param v1  第一个顶点</span><br><span class="line"> * @param v2  第二个顶点</span><br><span class="line"> * @return 返回两个顶点之间的权值</span><br><span class="line"> */</span><br><span class="line">public int getWeight(int v1, int v2) &#123;</span><br><span class="line">return edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 插入结点到集合中</span><br><span class="line"> * @param vertex</span><br><span class="line"> */</span><br><span class="line">public void insertVertex(String vertex) &#123;</span><br><span class="line">if(vertexList.contains(vertex)) &#123;</span><br><span class="line">System.out.println(&quot;该顶点已存在！！！&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">vertexList.add(vertexList.size(), vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 邻接矩阵存储</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @param weight 权值</span><br><span class="line"> */</span><br><span class="line">public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">if(edges[v1][v2] != 0) &#123;//修改权值而不是新增的</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">numEdges++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 删除边</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> */</span><br><span class="line">public void deleteEdge(int v1, int v2) &#123;</span><br><span class="line">if(edges[v1][v2] == 0) &#123;</span><br><span class="line">System.out.println(&quot;该边不存在！！！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = 0;</span><br><span class="line">numEdges--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param index</span><br><span class="line"> * @return 当前结点第一个邻接顶点下标</span><br><span class="line"> */</span><br><span class="line">public int getFirshNeighbor(int index) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[index][i]&gt;0) &#123;//行是相同的哟</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param v1 开始顶点的下标</span><br><span class="line"> * @param v2 结束顶点的下标</span><br><span class="line"> * @return 下一个邻接顶点</span><br><span class="line"> */</span><br><span class="line">public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">for(int i= v2+1; i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[v1][i]&gt;0) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印邻接矩阵</span><br><span class="line"> */</span><br><span class="line">private void print() &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">System.out.print(&quot;\t&quot;+vertexList.get(i)+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;edges[0].length;i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot;\t&quot;);</span><br><span class="line">for(int j=0;j&lt;edges[0].length;j++) &#123;</span><br><span class="line">System.out.print(edges[i][j]+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void depthFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">//初始化</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">DFS(i,visited);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 深度优先遍历</span><br><span class="line"> * @param v</span><br><span class="line"> * @param visited</span><br><span class="line"> */</span><br><span class="line">private void DFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">//打印出遍历的结点</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">        //整个循环不仅可以用getNumVertex()进行判断，也可以用权值判断，权值为-1表示是没有边的</span><br><span class="line">for(int j=0;j&lt;getNumVertex();j++) &#123;</span><br><span class="line">            //if(有边，未被访问，权值不超过最大值)</span><br><span class="line">            </span><br><span class="line">if(edges[i][j] != 0 &amp;&amp; !visited[j] &amp;&amp; edges[i][j] != 65535) &#123;</span><br><span class="line">DFS(j,visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int n=8,e=9;//分别代表结点个数和边的数目</span><br><span class="line">        String labels[]=&#123;&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;,&quot;v5&quot;,&quot;v6&quot;,&quot;v7&quot;,&quot;v8&quot;&#125;;//结点的标识</span><br><span class="line">        GraphVertex graph=new GraphVertex(n);</span><br><span class="line">        for(String label:labels) &#123;</span><br><span class="line">            graph.insertVertex(label);//插入结点</span><br><span class="line">        &#125;</span><br><span class="line">        //插入九条边</span><br><span class="line">        graph.insertEdge(0, 1, 1);</span><br><span class="line">        graph.insertEdge(0, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 3, 1);</span><br><span class="line">        graph.insertEdge(1, 4, 1);</span><br><span class="line">        graph.insertEdge(3, 7, 1);</span><br><span class="line">        graph.insertEdge(4, 7, 1);</span><br><span class="line">        graph.insertEdge(2, 5, 1);</span><br><span class="line">        graph.insertEdge(2, 6, 1);</span><br><span class="line">        graph.insertEdge(5, 6, 1);</span><br><span class="line">        graph.insertEdge(1, 0, 1);</span><br><span class="line">        graph.insertEdge(2, 0, 1);</span><br><span class="line">        graph.insertEdge(3, 1, 1);</span><br><span class="line">        graph.insertEdge(4, 1, 1);</span><br><span class="line">        graph.insertEdge(7, 3, 1);</span><br><span class="line">        graph.insertEdge(7, 4, 1);</span><br><span class="line">        graph.insertEdge(6, 2, 1);</span><br><span class="line">        graph.insertEdge(5, 2, 1);</span><br><span class="line">        graph.insertEdge(6, 5, 1);</span><br><span class="line">        graph.print();</span><br><span class="line">System.out.println(&quot;深度优先,从结点v1开始&quot;);</span><br><span class="line">graph.depthFirstSearch(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>结果<br><img src="/2019/02/26/图的遍历/vertexDFS.PNG" alt=""></p></blockquote><h2 id="马踏棋盘问题"><a href="#马踏棋盘问题" class="headerlink" title="马踏棋盘问题"></a>马踏棋盘问题</h2><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>Breadth First Search. 又称为“宽度优先搜索”或“横向优先搜索”<br>从某一顶点出发，依次访问邻接的所有顶点<br>因为BFS并不使用经验法则算法，所以展开结点而得到的子节点都会被加进一个先进先出的队列中。</p><p>分析：</p><ol><li>访问初始顶点v，并标记顶点v已经被访问</li><li>结点v入队列</li><li>当队列非空时，继续向下执行，否则结束算法</li><li>出队列，获得队头结点u</li><li>找到结点u的第一个邻接顶点w</li><li>若w不存在，执行第3步，否则向下执行</li><li>若w未被访问，标记顶点w已经被访问</li><li>顶点w入队列</li><li>找到顶点的第二个邻接顶点，执行第6步</li></ol><p>其实就是按照邻接矩阵的行进行寻找的<br>第一行的0-n列<br>第二行的0-n列<br>……</p><h2 id="邻接矩阵实现-1"><a href="#邻接矩阵实现-1" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><p>用的是迭代</p><p>根据出队下标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void broadFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">BFS(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">private void BFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">//第一次访问的顶点</span><br><span class="line">System.out.print(getValueByIndex(i)+&quot; &quot;);</span><br><span class="line">//标记该顶点已被遍历过</span><br><span class="line">visited[i] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(i);</span><br><span class="line">while(!queue.isEmpty()) &#123;</span><br><span class="line">//出队列</span><br><span class="line">int vertex = queue.poll();</span><br><span class="line">for(int j=vertex;j&lt;getNumVertex();j++) &#123;</span><br><span class="line">if(!visited[j] &amp;&amp; getWeight(vertex, j) != 0) &#123;</span><br><span class="line">visited[j] = true;</span><br><span class="line">System.out.print(getValueByIndex(j)+&quot; &quot;);</span><br><span class="line">queue.offer(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据权值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void broadFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">BFS(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">private void BFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">//第一次访问的顶点</span><br><span class="line">System.out.print(getValueByIndex(i)+&quot; &quot;);</span><br><span class="line">//标记该顶点已被遍历过</span><br><span class="line">visited[i] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(i);</span><br><span class="line">while(!queue.isEmpty()) &#123;</span><br><span class="line">//出队列</span><br><span class="line">int vertex = queue.poll();</span><br><span class="line">//第一个邻接顶点</span><br><span class="line">int next = getFirshNeighbor(vertex);</span><br><span class="line">while(next != -1) &#123;//还有邻接顶点的时候</span><br><span class="line">if(!visited[next]) &#123;</span><br><span class="line">System.out.print(getValueByIndex(next)+&quot; &quot;);</span><br><span class="line">visited[next] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">//下一个邻接顶点</span><br><span class="line">next = getNextNeighbor(vertex, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>感觉根据权值来进行比较的话，比较次数会相对少一些，尤其稀疏的时候<br><img src="/2019/02/26/图的遍历/BFSVertexs.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索&quot;&gt;&lt;/a&gt;深度优先搜索&lt;/h1&gt;&lt;p&gt;Depth First Search.  与树的先序遍历类似。从某个顶点出发，依次向下访问&lt;br&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问初始顶点v，并标记顶点v已经被访问&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>代码习题</title>
    <link href="http://yoursite.com/2019/02/21/%E4%BB%A3%E7%A0%81%E4%B9%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/21/代码习题/</id>
    <published>2019-02-21T01:37:51.000Z</published>
    <updated>2019-03-04T11:08:45.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对链表进行重新排序"><a href="#1-对链表进行重新排序" class="headerlink" title="1.对链表进行重新排序"></a>1.对链表进行重新排序</h1><p>题目：给定链表 L0-L1-L2-…-Ln-1-Ln,把链表重新排序为L0-Ln-L1-Ln-1-L2-Ln-2-…<br>要求：  </p><ul><li>再原来链表的基础上进行排序，即不能申请新的结点</li><li>只能修改结点的next域，不能修改数据域。<a id="more"></a>思路：</li><li>找到链表的中间结点(暴力法或者快慢指针法)</li><li>将链表分成两个来链表</li><li>逆序后面的链表</li><li>依次循环，每次各去除两个链表的一个结点，直至next为空</li></ul><h1 id="2-求两个字符串的最长公共子串"><a href="#2-求两个字符串的最长公共子串" class="headerlink" title="2.求两个字符串的最长公共子串"></a>2.求两个字符串的最长公共子串</h1><ol><li>暴力求解<br>利用动态规划法，双重for循环。</li></ol><ul><li>初始化二维数组max[][]，赋值为0</li><li>双重循环两个字符串，如果字符串在某一位置相等,赋值max+1，</li><li>两个变量，max记录最长公共子串的长度，maxI记录最长公共子串最后一个字符的位置</li><li>最长公共子串的位置是从下标maxI-max开始，下标增加max位的字符</li><li>需要注意的是，比较的时候对max数组的赋值，因为循环是从1开始的</li></ul><p><img src="/2019/02/21/代码习题/maxSubStr.PNG" alt="">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str1 = &quot;GCCCTAGCG&quot;;</span><br><span class="line">String str2 = &quot;GCGCAATG&quot;;</span><br><span class="line">getMaxSubStr(str1, str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getMaxSubStr(String str1, String str2) &#123;</span><br><span class="line">if(str1 == null || str2 == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int[][] m = new int[str1.length()+1][str2.length()+1];</span><br><span class="line">int max = 0;//最长公共子序列的长度</span><br><span class="line">int maxI = 0;//最长公共子序列的最后一个字符的位置</span><br><span class="line">for(int i=0;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">m[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=1;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">if(str1.charAt(i-1) == str2.charAt(j-1)) &#123;</span><br><span class="line">m[i][j] = m[i-1][j-1]+1;</span><br><span class="line">if(max&lt;m[i][j]) &#123;</span><br><span class="line">max = m[i][j];</span><br><span class="line">maxI = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str1.substring(maxI-max, maxI));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>滑动比较法</li></ol><ul><li>保持str1的位置不变，移动str2,比较重叠字符的公共子串</li><li>移动时，如果当前重叠子串的长度大于maxI,更新maxI<h1 id="3-求字符串的所有排序（未去重）"><a href="#3-求字符串的所有排序（未去重）" class="headerlink" title="3.求字符串的所有排序（未去重）"></a>3.求字符串的所有排序（未去重）</h1></li><li>第一步，第一个字符和后面所有字符，依次交换</li><li>第二步，固定第一个字符，对剩余的字符进行全排列（交换）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void swap(char[] str, int start, int i) &#123;</span><br><span class="line">char tmp = str[start];</span><br><span class="line">str[start] = str[i];</span><br><span class="line">str[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">public static void Permutation(char[] str, int start) &#123;</span><br><span class="line">if(str.length == 0 || start&lt;0) &#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(start == str.length-1) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for(int i = start;i&lt;str.length;i++) &#123;</span><br><span class="line">swap(str,start,i);</span><br><span class="line">Permutation(str, start+1);</span><br><span class="line">swap(str,i,start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String string = &quot;abc&quot;;</span><br><span class="line">char[] str = string.toCharArray();</span><br><span class="line">Permutation(str, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-将多个有序的list集合组合成一个有序的集合"><a href="#4-将多个有序的list集合组合成一个有序的集合" class="headerlink" title="4. 将多个有序的list集合组合成一个有序的集合"></a>4. 将多个有序的list集合组合成一个有序的集合</h1><p>数美时代技术有限公司的一道面试题，25分，本人直接用了：<br>Collections.sort() emmmmmm直接扣掉了15分，当时太紧张了，脑子都是懵的，不过也是基础不扎实的缘故。 </p><p>思路：</p><ul><li>俩俩比较，但是总觉得会有更优的算法，要不然为何强调是有序的集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉是不是需要递归啊</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-对链表进行重新排序&quot;&gt;&lt;a href=&quot;#1-对链表进行重新排序&quot; class=&quot;headerlink&quot; title=&quot;1.对链表进行重新排序&quot;&gt;&lt;/a&gt;1.对链表进行重新排序&lt;/h1&gt;&lt;p&gt;题目：给定链表 L0-L1-L2-…-Ln-1-Ln,把链表重新排序为L0-Ln-L1-Ln-1-L2-Ln-2-…&lt;br&gt;要求：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;再原来链表的基础上进行排序，即不能申请新的结点&lt;/li&gt;
&lt;li&gt;只能修改结点的next域，不能修改数据域。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2019/02/19/%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/02/19/图/</id>
    <published>2019-02-19T10:40:15.000Z</published>
    <updated>2019-03-18T07:41:33.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>图(Graph)是由顶点的<em>有穷非空</em>集合和顶点之间边的集合组成。通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br><a id="more"></a><br>注意：</p><ul><li>数据元素，在线性表中叫元素，树中叫结点，图中称为顶点(Vertex)</li></ul><ol><li>无向边（Edge）<br>顶点Vi到Vj之间的边没有方向,用无序偶(Vi,Vj)来表示。</li><li>有向边<br>也称为弧(Arc),用有序偶&lt;Vi,Vj&gt;表示，Vi是弧尾，Vj是弧头</li><li>简单图<br>不存在顶点到其自身的边，且同一条边不重复出现。</li><li>无向完全图<br>在无向图中，任意两个顶点之间都存在边。含有n个项点的无向完全图有n*(n-1)/2条边。</li><li>有向完全图<br>在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。含有n个顶点的有向完全图有n*(n-1)条边。</li><li>稀疏图和稠密图<br>通常认为边或弧数小于n*logn的图为稀疏图。</li><li>权(Weight)<br>与图的边或弧相关的数</li><li>网(Network)<br>带权的图</li><li>度(Degree)<br>顶点和相关联的边的数目.TD(V) = ID(V)+OD(V)</li><li>入度(InDegree)<br>以顶点V为头的弧的数目称为V的入度，记为ID(V)</li><li>初读(OutDegree)<br>以V为尾的弧的数目称为V的出度，记为OD(V)  </li><li>回路或环(Cycle)<br>第一个顶点到最后一个顶点相同的路径<br>顶点不重复出现的是简单环</li><li>连通图<br>无向图中，每个顶点都相连，如果是有向图，称为强连通图</li><li>无向图中的极大连通子图称为连通分量</li></ol><ul><li>首先是子图，且子图是连通的</li><li>连通子图含有极大顶点数</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>是多对多的关系，树是一对多，链表是一对一  </p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>分为有向图邻接矩阵和无向图邻接矩阵</p><ol><li>无向图<br>用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息：0表示不存在，1表示存在。</li><li>有向图<br>与无向图一样，但无向图更浪费空间，因为无向图是对称矩阵</li><li>网<br>没有连线的两个顶点，用无穷∞表示</li></ol><ul><li>入度<br>该顶点所在列的和</li><li>出度<br>该顶点所在行的和</li></ul><ol start="4"><li>实现邻接矩阵<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Graph &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;Object&gt; point;//顶点信息</span><br><span class="line">private int[][] edge;//边信息，</span><br><span class="line">private int numEdge;//边的数目</span><br><span class="line">private int numVertex ;//顶点的数目</span><br><span class="line"></span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumVertex(int numVertex) &#123;</span><br><span class="line">this.numVertex = numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public ArrayList&lt;Object&gt; getPoint() &#123;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">public void setPoint(ArrayList&lt;Object&gt; point) &#123;</span><br><span class="line">this.point = point;</span><br><span class="line">&#125;</span><br><span class="line">public int[][] getEdge() &#123;</span><br><span class="line">return edge;</span><br><span class="line">&#125;</span><br><span class="line">public void setEdge(int[][] edge) &#123;</span><br><span class="line">this.edge = edge;</span><br><span class="line">&#125;</span><br><span class="line">public int getNumEdge() &#123;</span><br><span class="line">return numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumEdge(int numEdge) &#123;</span><br><span class="line">this.numEdge = numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public Graph(int n) &#123;</span><br><span class="line">this.point = new ArrayList&lt;&gt;(n);</span><br><span class="line">this.edge = new int[n][n];</span><br><span class="line">this.numEdge = 0;</span><br><span class="line">&#125;</span><br><span class="line">public Graph() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 建立无向图</span><br><span class="line"> */</span><br><span class="line">public static Graph buildGraph() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共多少个顶点&quot;);</span><br><span class="line">int numVertex  = scan.nextInt();</span><br><span class="line">System.out.println(&quot;一共多少条边&quot;);</span><br><span class="line">int numEdge = scan.nextInt();</span><br><span class="line">Graph g = new Graph();</span><br><span class="line">g.setNumEdge(numEdge);</span><br><span class="line">g.setNumVertex(numVertex);</span><br><span class="line">//读入顶点信息</span><br><span class="line">int vertex = numVertex;</span><br><span class="line">ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">scan.nextLine();</span><br><span class="line">while(vertex&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;请输入顶点&quot;);</span><br><span class="line">String s = scan.nextLine();</span><br><span class="line">list.add(s);</span><br><span class="line">vertex--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">g.setPoint(list);</span><br><span class="line">//初始化</span><br><span class="line">int[][] edge = new int[numVertex][numVertex];</span><br><span class="line">for(int i=0;i&lt;g.getNumVertex();i++) &#123;</span><br><span class="line">for(int j=0;j&lt;g.getNumVertex();j++) &#123;</span><br><span class="line">edge[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//加入到邻接矩阵中，1表示有边</span><br><span class="line">while(numEdge&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;输入连接的两个顶点，用“#”隔开&quot;);</span><br><span class="line">String num = scan.nextLine();</span><br><span class="line">String[] nums = num.split(&quot;#&quot;);</span><br><span class="line">int indexOf0 = list.indexOf(nums[0]);</span><br><span class="line">int indexOf1 = list.indexOf(nums[1]);</span><br><span class="line">if(indexOf0&lt;0 || indexOf1&lt;0) &#123;</span><br><span class="line">System.out.println(&quot;顶点不存在，请重新输入！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edge[list.indexOf(nums[0])][list.indexOf(nums[1])] = 1;</span><br><span class="line">//因为是对称的</span><br><span class="line">edge[list.indexOf(nums[1])][list.indexOf(nums[0])] = 1;</span><br><span class="line">numEdge--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//打印出来</span><br><span class="line">System.out.print(&quot; &quot;);</span><br><span class="line">for(Object li : list) &#123;</span><br><span class="line">System.out.print(li+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;numVertex;i++) &#123;</span><br><span class="line">System.out.print(list.get(i)+&quot; &quot;);</span><br><span class="line">for(int j=0;j&lt;numVertex;j++) &#123;</span><br><span class="line">System.out.print(edge[i][j]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">buildGraph();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果 </p><blockquote><p>一共多少个顶点<br>5<br>一共多少条边<br>5<br>请输入顶点<br>a<br>请输入顶点<br>b<br>请输入顶点<br>c<br>请输入顶点<br>d<br>请输入顶点<br>e<br>[a, b, c, d, e]<br>输入连接的两个顶点，用“#”隔开<br>a#b<br>输入连接的两个顶点，用“#”隔开<br>d#e<br>输入连接的两个顶点，用“#”隔开<br>c#b<br>输入连接的两个顶点，用“#”隔开<br>b#d<br>输入连接的两个顶点，用“#”隔开<br>d#a<br> a b c d e<br>a 0 1 0 1 0<br>b 1 0 1 1 0<br>c 0 1 0 0 0<br>d 1 1 0 0 1<br>e 0 0 0 1 0 </p></blockquote><hr><p>版本二：添加了权值，添加了增加和删除  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.synth.SynthSpinnerUI;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;String&gt; vertexList;//用来存储顶点信息</span><br><span class="line">private int[][] edges;//邻接矩阵，存储顶点之间的边信息</span><br><span class="line">private int numEdges;//边的数目</span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> * @param n</span><br><span class="line"> */</span><br><span class="line">public GraphVertex(int n) &#123;</span><br><span class="line">vertexList = new ArrayList&lt;&gt;(n);</span><br><span class="line">edges = new int[n][n];</span><br><span class="line">numEdges = 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到结点个数</span><br><span class="line"> */</span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return vertexList.size();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到边数</span><br><span class="line"> */</span><br><span class="line">public int getNumEdges() &#123;</span><br><span class="line">return numEdges;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param i</span><br><span class="line"> * @return 返回第i个结点的信息</span><br><span class="line"> */</span><br><span class="line">public String getValueByIndex(int i) &#123;</span><br><span class="line">return vertexList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param v1  第一个顶点</span><br><span class="line"> * @param v2  第二个顶点</span><br><span class="line"> * @return 返回两个顶点之间的权值</span><br><span class="line"> */</span><br><span class="line">public int getWeight(int v1, int v2) &#123;</span><br><span class="line">return edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 插入结点到集合中</span><br><span class="line"> * @param vertex</span><br><span class="line"> */</span><br><span class="line">public void insertVertex(String vertex) &#123;</span><br><span class="line">if(vertexList.contains(vertex)) &#123;</span><br><span class="line">System.out.println(&quot;该顶点已存在！！！&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">vertexList.add(vertexList.size(), vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 邻接矩阵存储</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @param weight 权值</span><br><span class="line"> */</span><br><span class="line">public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">if(edges[v1][v2] != 0) &#123;//修改权值而不是新增的</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">numEdges++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 删除边</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> */</span><br><span class="line">public void deleteEdge(int v1, int v2) &#123;</span><br><span class="line">if(edges[v1][v2] == 0) &#123;</span><br><span class="line">System.out.println(&quot;该边不存在！！！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = 0;</span><br><span class="line">numEdges--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param index</span><br><span class="line"> * @return 当前结点第一个邻接顶点下标</span><br><span class="line"> */</span><br><span class="line">public int getFirshNeighbor(int index) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[index][i]&gt;0) &#123;//行是相同的哟</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @return 下一个邻接顶点</span><br><span class="line"> */</span><br><span class="line">public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">for(int i= v2+1; i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[v1][i]&gt;0) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印邻接矩阵</span><br><span class="line"> */</span><br><span class="line">private void print() &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;edges[0].length;i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">for(int j=0;j&lt;edges[0].length;j++) &#123;</span><br><span class="line">System.out.print(edges[i][j]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int vertex = 4;</span><br><span class="line">int edge = 4;</span><br><span class="line">String[] v = &#123;&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;&#125;;</span><br><span class="line">GraphVertex G = new GraphVertex(vertex);</span><br><span class="line">//插入顶点</span><br><span class="line">for (String string : v) &#123;</span><br><span class="line">G.insertVertex(string);</span><br><span class="line">&#125;</span><br><span class="line">//插入边</span><br><span class="line">G.insertEdge(0, 1, 2);</span><br><span class="line">G.insertEdge(0, 2, 5);</span><br><span class="line">G.insertEdge(2, 3, 8);</span><br><span class="line">G.insertEdge(3, 0, 7);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;结点个数&quot;+G.getNumVertex());</span><br><span class="line">System.out.println(&quot;边个数&quot;+G.getNumEdges());</span><br><span class="line">System.out.println(&quot;邻接矩阵&quot;);</span><br><span class="line">G.print();</span><br><span class="line">G.deleteEdge(0, 1);</span><br><span class="line">System.out.println(&quot;删除v1,v2之间的边&quot;);</span><br><span class="line">System.out.println(&quot;删除后顶点个数：&quot;+G.getNumEdges());</span><br><span class="line">System.out.println(&quot;删除后边个数：&quot;+G.getNumEdges());</span><br><span class="line">G.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>AdjacencyList<br>是链表和数组的结合(树也是链表和数组的结合哟)  </p><ol><li>处理方法  </li></ol><ul><li>图中顶点用一个一维数组存储（或者单链表），用一维数组是为了更快的读取顶点信息，更加方便。  </li><li>图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以用单链表存储。  </li></ul><p><em>邻接表关心出度，不关心入度</em><br>类似于树的孩子表示法</p><p><img src="/2019/02/19/图/list.PNG" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.GenericArrayType;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接表结构</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphNode &#123;</span><br><span class="line">   //表对应链表的顶点</span><br><span class="line">private class ENode&#123;</span><br><span class="line">int index;//顶点位置</span><br><span class="line">ENode nextEdge;//下一条弧</span><br><span class="line">&#125;</span><br><span class="line">//表中顶点</span><br><span class="line">private class VNode&#123;</span><br><span class="line">String data;//顶点信息,就是说他叫什么名字</span><br><span class="line">ENode firstEdge;//指向该顶点的第一条弧</span><br><span class="line">&#125;</span><br><span class="line">private VNode[] vertexs;//顶点数组</span><br><span class="line">public void createGraph() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入顶点个数&quot;);</span><br><span class="line">int numVertexs = scan.nextInt();</span><br><span class="line">System.out.println(&quot;请输入边数&quot;);</span><br><span class="line">int numEdges = scan.nextInt();</span><br><span class="line">scan.nextLine();</span><br><span class="line">//初始化顶点</span><br><span class="line">vertexs = new VNode[numVertexs];</span><br><span class="line">for(int i=0; i &lt; numVertexs; i++) &#123;</span><br><span class="line">System.out.println(&quot;请输入顶点&quot;);</span><br><span class="line">vertexs[i] = new VNode();</span><br><span class="line">vertexs[i].data = scan.nextLine();</span><br><span class="line">vertexs[i].firstEdge = null;//很重要的一步</span><br><span class="line">&#125;</span><br><span class="line">//初始化边</span><br><span class="line">for(int i=0; i &lt; numEdges; i++) &#123;</span><br><span class="line">System.out.println(&quot;请输入边的起始顶点和结束顶点&quot;);</span><br><span class="line">ENode e1 = new ENode();</span><br><span class="line">String start = scan.nextLine();</span><br><span class="line">String end = scan.nextLine();</span><br><span class="line">int startIndex = getPosition(start);</span><br><span class="line">int endIndex = getPosition(end);</span><br><span class="line">e1.index = endIndex;</span><br><span class="line">//将e1连接到endIndedx所在链表的末尾</span><br><span class="line">if(vertexs[startIndex].firstEdge == null) &#123;</span><br><span class="line">vertexs[startIndex].firstEdge = e1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//将e1结点连接到vertexs[startIndex].firstEdge的末尾</span><br><span class="line">VertexsLast(vertexs[startIndex].firstEdge, e1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line">private void VertexsLast(ENode firstEdge, ENode e1) &#123;</span><br><span class="line">ENode p = firstEdge;</span><br><span class="line">while(p.nextEdge != null) &#123;</span><br><span class="line">p = p.nextEdge;</span><br><span class="line">&#125;</span><br><span class="line">p.nextEdge = e1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 连接顶点的位置信息</span><br><span class="line"> * @param start</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int getPosition(String data) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexs.length;i++) &#123;</span><br><span class="line">if(vertexs[i].data.equals(data)) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印矩阵的队列图,出队元素</span><br><span class="line"> */</span><br><span class="line">public void print() &#123;</span><br><span class="line">for(int i=0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">ENode node = vertexs[i].firstEdge;</span><br><span class="line">while(node != null) &#123;</span><br><span class="line">System.out.println(node.index+&quot;\t&quot;+vertexs[node.index].data);</span><br><span class="line">node = node.nextEdge;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">GraphNode g = new GraphNode();</span><br><span class="line">g.createGraph();</span><br><span class="line">g.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>邻接矩阵适用于顶点少，边数多的图，邻接表相反</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>把邻接表和逆邻接表结合起来。<br>结构为：tailVex   headVex    headLink   tailLink<br>Vex表示顶点，Link表示结点<br>常用！！！！！！！！</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>是对边的操作</p><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>由两个一维数组组成，一个存储顶点，一个存储边信息，这个边数组每个数据元素由一条边的起点下标，重点下标和全组成。<br><img src="/2019/02/19/图/1.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;图(Graph)是由顶点的&lt;em&gt;有穷非空&lt;/em&gt;集合和顶点之间边的集合组成。通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="http://yoursite.com/2019/02/17/%E6%A0%91%E4%B9%8B%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/17/树之哈夫曼树/</id>
    <published>2019-02-17T10:12:32.000Z</published>
    <updated>2019-02-17T14:41:50.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>也称赫夫曼树、最优二叉树，Huffman,是首个实用的压缩编码方案。<br>&#160;&#160;&#160;&#160;给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉为最优二叉树，也称为哈夫曼树。<br><a id="more"></a><br>&#160;&#160;&#160;&#160;哈夫曼树是带权路径最短的树，权值较大的结点离根较近。</p><ul><li>路径长度<br>从根节点到该节点的路径上的连接数</li><li>树的路径长度<br>树中每个叶子结点的路径长度之和</li><li>结点带权路径长度<br>结点的路径长度与结点权值的乘积</li><li>树的带权路径长度<br>WPL(Weighted Path Length)是树中所有叶子结点的带权路径长度之和，WPL越小，树的结构越优。<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1></li><li>定长编码<br>约定8位表示一个字符</li><li>变长编码<br>单个编码的长度不一致，可以根据整体出现频率来调节<br>-前缀码<br>没有任何码字是其他码字的前缀</li></ul><p>约定，左子树用0表示，右子树用1表示<br><strong><em>很很很重要</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;也称赫夫曼树、最优二叉树，Huffman,是首个实用的压缩编码方案。&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉为最优二叉树，也称为哈夫曼树。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树(Binary Tree)</title>
    <link href="http://yoursite.com/2019/02/17/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/17/树之二叉树/</id>
    <published>2019-02-17T04:28:33.000Z</published>
    <updated>2019-03-23T03:26:35.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;也叫 二分树、二元树、对分树等。是n(n&gt;=0)个结点的有限元素的集合,该集合或为空，或为由一个根元素以及两个互不相交的、被分别称为左子树和右子树的二叉树组成。当集合为空时，称该二叉树为空二叉树。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>子树不能大于2哟</li><li>左右子树是有顺序的哟</li><li>如果没有左子树，是允许有右子树的<a id="more"></a><h1 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h1></li></ul><ol><li>斜树<br><img src="/2019/02/17/树之二叉树/二叉树/1.PNG" alt=""></li><li>满二叉树<br>如果在一棵二叉树中，所有的分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上面。<br><img src="/2019/02/17/树之二叉树/二叉树/2.PNG" alt=""><br>结点数为2^n-1    ,n表示深度</li><li>完全二叉树<br>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下，从左至右的顺序进行编号。如果说编号为i(1&lt;=i &lt;=n )的结点与满二叉树中编号为i的结点在二叉树中的位置相同的话，则称为是完全二叉树<br><strong><em>满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树</em></strong><br><strong>特点：</strong><br>&#160;&#160;&#160;&#160;叶子结点只能出现在最后一层或者倒数第二层上<br>&#160;&#160;&#160;&#160;最下层叶子结点集中在树的左部（根据满二叉树的定义来的）<br>&#160;&#160;&#160;&#160;同样结点数的二叉树，完全二叉树的深度是最小的  </li><li>线索二叉树<br>n个结点的二叉链表中含有n+1个空指针域。利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针（附加的指针称为线索）   <h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2>一维数组存储结点，从上至下，从左至右，不存在的结点可以用-1表示<br>但是如果空结点过多（如斜树）h会造成大量的空间浪费，适用性不强，一般使用链式存储<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2>二叉链表</li></ol><ul><li>数据</li><li>左子树结点，右子树结点  </li></ul><p>结构为：左子树   数据  右子树<br><img src="/2019/02/17/树之二叉树/二叉树/3.PNG" alt=""> </p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><em>注意：</em><br>树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点棉面临着不同的选择。  </p><ul><li>前序遍历<br>根-左-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历<br>左-根-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历<br>左-右-根</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层次遍历  </li></ul><p>节点类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tree &#123;</span><br><span class="line">private Object data;</span><br><span class="line">private Tree lchild;</span><br><span class="line">private Tree rchild;</span><br><span class="line">public Object getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">public void setData(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getLchild() &#123;</span><br><span class="line">return lchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setLchild(Tree lchild) &#123;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getRchild() &#123;</span><br><span class="line">return rchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setRchild(Tree rchild) &#123;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data, Tree lchild, Tree rchild) &#123;</span><br><span class="line">super();</span><br><span class="line">this.data = data;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.tree;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 二叉树</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BinaryTree &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Tree root = new Tree(0);</span><br><span class="line">Tree createTree = createTree(root);</span><br><span class="line">System.out.println(&quot;结点\t层次&quot;);</span><br><span class="line">traverse(createTree,1);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 遍历</span><br><span class="line"> * @param root</span><br><span class="line"> */</span><br><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private static void print(Tree root,int level) &#123;</span><br><span class="line">System.out.println(root.getData()+&quot;\t&quot;+level);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 建立二叉树</span><br><span class="line"> * @param root 树结点</span><br><span class="line"> * @param level  层次</span><br><span class="line"> */</span><br><span class="line">private static Tree createTree(Tree root) &#123;</span><br><span class="line"></span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String n = scan.nextLine();</span><br><span class="line">if(&quot;#&quot;.equals(n)) &#123;//叶子结点</span><br><span class="line">return null;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">root.setData(n);</span><br><span class="line">root.setLchild(createTree(new Tree(0)));</span><br><span class="line">root.setRchild(createTree(new Tree(0)));</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入 ：ABD##F##CE###<br>输出：<br>结点    层次<br>A       1<br>B       2<br>D       3<br>F       3<br>C       2<br>E       3</p><p>“#”表示他的双亲是叶子结点</p><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p><img src="/2019/02/17/树之二叉树/二叉树/4.PNG" alt=""><br>嘿嘿，不懂<br>😭</p><h1 id="树-森林、二叉树转换"><a href="#树-森林、二叉树转换" class="headerlink" title="树/森林、二叉树转换"></a>树/森林、二叉树转换</h1><p><img src="/2019/02/17/树之二叉树/二叉树/5.PNG" alt=""></p><h2 id="树到二叉树的转换"><a href="#树到二叉树的转换" class="headerlink" title="树到二叉树的转换"></a>树到二叉树的转换</h2><ul><li>每个兄弟结点连线</li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/6.PNG" alt=""></p><ul><li>去掉与孩子的连线（第一个长子除外）</li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/7.PNG" alt=""></p><ul><li>调整位置  </li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/8.PNG" alt=""></p><h2 id="森林到二叉树的转换"><a href="#森林到二叉树的转换" class="headerlink" title="森林到二叉树的转换"></a>森林到二叉树的转换</h2><ul><li>将森林中的每棵树转为二叉树</li><li>将根一次连在一起</li><li>调整位置</li></ul><h2 id="二叉树到树、森林的转换"><a href="#二叉树到树、森林的转换" class="headerlink" title="二叉树到树、森林的转换"></a>二叉树到树、森林的转换</h2><ul><li>若结点x是其双亲y的左孩子，则把x的右孩子，有孩子的有孩子，，，，，，都与y用连线连起来</li><li>去除双亲所有右孩子的连线</li></ul><p><em>二叉树的根节点有右孩子就是森林，没有就是树</em></p><h1 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h1><h2 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h2><p>先访问树的根节点，然后再一次访问根的每棵子树</p><h2 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h2><p>先遍历树的每棵子树，再遍历根</p><p><img src="/2019/02/17/树之二叉树/二叉树/9.PNG" alt=""></p><p>嗒嗒嗒，森林的遍历，名词叫做前序遍历和后序遍历，其实就是按照树的先根遍历和后根遍历一次来访问森林的每一棵树。</p><p>树、森林的前根遍历和（转变后的）二叉树的前序遍历相同<br>后根遍历和（转变后的）二叉树的中序遍历相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;也叫 二分树、二元树、对分树等。是n(n&amp;gt;=0)个结点的有限元素的集合,该集合或为空，或为由一个根元素以及两个互不相交的、被分别称为左子树和右子树的二叉树组成。当集合为空时，称该二叉树为空二叉树。&lt;/p&gt;
&lt;h1 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;子树不能大于2哟&lt;/li&gt;
&lt;li&gt;左右子树是有顺序的哟&lt;/li&gt;
&lt;li&gt;如果没有左子树，是允许有右子树的&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>五个常见算法</title>
    <link href="http://yoursite.com/2019/02/15/%E4%BA%94%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/15/五个常见算法/</id>
    <published>2019-02-15T10:19:46.000Z</published>
    <updated>2019-02-25T01:22:27.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><ol><li>递归<br>&#160;&#160;&#160;&#160;直接或间接地调用自身的算法    </li><li>分治<br>&#160;&#160;&#160;&#160;将一个规模为n的，难以解决的问题分解为k个规模较小的子问题，<em>子问题相互独立</em>  </li></ol><p>将子问题递归解决，得到源问题的解  </p><ol start="3"><li>典型案例<br>Fibonacci数列，阶乘，Hanoi塔，二分法搜索，高速排序，合并排序<a id="more"></a><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Dynamis programming,是运筹学的一个分支，是求解决策过程最优化的数学方法。 </li><li>基本思想<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;类似分治法，将待求解问题分解成若干个子问题，先求解子问题，但是<em>子问题不是相互独立的</em>，避免大量的重复计算，每一次要用到前一问题的解   </li><li><p>分类<br>线性动态规划： 拦截导弹， 合唱队形， 挖地雷， 建学校， 剑客决斗<br>区域动态规划： 石子合并， 加分二叉树， 统计单词个数， 炮兵布阵<br>树形动态规划： 贪吃的九头龙， 二分查找树， 聚会的欢乐， 数字三角形。<br>背包动态规划： 01背包问题， 完全背包问题， 分组背包问题， 二维背包， 装箱问题， 挤牛奶， </p></li><li><p>实例<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最短路径问题， 项目管理， 网络流优化， 最长公共子序列，最大连续子序列和， 矩阵连乘， 凸多边形最优三角剖分， 电路布线。</p></li></ol><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><ol><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;对问题求解时，总是做出再当前看来最好的选择，也就是说，不从整体最优上加以考虑。<br>某个状态以前的过程不会影响以后的状态，只与当前状态有关。  </li><li>与动态规划的区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;贪心算法是自顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为规模更小的子问题，最后得到一个整体最优解。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不能回退，动态规划可以</li><li>思路<br>建立数学模型来描述问题<br>把求解的问题分成若干个子问题<br>对每一子问题求解，得到子问题的局部最优解<br>八字问题的解局部最优解合成原问题的一个解  </li><li>案例<br>01背包问题， 马踏棋盘，最小生成树的Prim算法和Kruskal算法<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;能进则进，不进则退  。类似枚举的搜索尝试过程，主要再搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就返回，尝试别的路径，<em>是一种选优搜索法</em><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;需要深度优先的方式搜索解空间 </li><li>案例<br>八皇后问题<h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1></li><li><p>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生所有儿子结点，在儿子结点中，导致不可行解或者非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。再从活结点中取下一结点成为当前扩展结点。重复……<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;常以广度优先或以最小消耗优先的方式搜索问题的解空间树。</p></li><li><p>方法  </p></li></ol><ul><li>队列式(FIFO)分支限界法<br>按照队列原则选区下一个结点为扩展结点</li><li>优先队列式分支限界法<br>按优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。</li></ul><ol start="3"><li>与回溯法区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是求条件下的所有解，分支限界是一个解<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是深度优先，分支限界是广度优先   </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;递归和分治&quot;&gt;&lt;a href=&quot;#递归和分治&quot; class=&quot;headerlink&quot; title=&quot;递归和分治&quot;&gt;&lt;/a&gt;递归和分治&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;递归&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;直接或间接地调用自身的算法    &lt;/li&gt;
&lt;li&gt;分治&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;将一个规模为n的，难以解决的问题分解为k个规模较小的子问题，&lt;em&gt;子问题相互独立&lt;/em&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将子问题递归解决，得到源问题的解  &lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;典型案例&lt;br&gt;Fibonacci数列，阶乘，Hanoi塔，二分法搜索，高速排序，合并排序&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>新年第一周</title>
    <link href="http://yoursite.com/2019/02/15/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>http://yoursite.com/2019/02/15/新年第一周/</id>
    <published>2019-02-15T01:59:53.000Z</published>
    <updated>2019-03-17T08:28:25.638Z</updated>
    
    <content type="html"><![CDATA[<p>作为新年的第一周，真的是，微笑中透露着疲惫</p><ul><li>周二给同学发了简历，然后挂了</li><li>数据结构真的不好复习</li><li>刷题真的伤时间</li><li>第一周13号线停了一周，我单程时间就变成了2小时</li><li>7：40出发，9：40到公司，心态已崩</li><li>新年愿望：<blockquote><p>换工作<br>顺利毕业<br>皮肤变好<br>瘦<br>如果可以，还有小哥哥</p></blockquote></li></ul><ul><li>最后一定要说：尹腾召是个大傻子，大猪蹄子，糟老头子</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为新年的第一周，真的是，微笑中透露着疲惫&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;周二给同学发了简历，然后挂了&lt;/li&gt;
&lt;li&gt;数据结构真的不好复习&lt;/li&gt;
&lt;li&gt;刷题真的伤时间&lt;/li&gt;
&lt;li&gt;第一周13号线停了一周，我单程时间就变成了2小时&lt;/li&gt;
&lt;li&gt;7：40出发，
      
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
