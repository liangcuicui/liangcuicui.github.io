<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimeJjc&#39;s Blog</title>
  
  <subtitle>新的开始,加油哦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-02T14:21:59.522Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三次握手四次挥手</title>
    <link href="http://yoursite.com/2019/04/02/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2019/04/02/三次握手四次挥手/</id>
    <published>2019-04-02T14:19:27.000Z</published>
    <updated>2019-04-02T14:21:59.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h1><p>本篇文章讲解的是TCP协议三次握手和四次挥手的一个详情。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三握四挥&quot;&gt;&lt;a href=&quot;#三握四挥&quot; class=&quot;headerlink&quot; title=&quot;三握四挥&quot;&gt;&lt;/a&gt;三握四挥&lt;/h1&gt;&lt;p&gt;本篇文章讲解的是TCP协议三次握手和四次挥手的一个详情。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>树之4个迭代遍历</title>
    <link href="http://yoursite.com/2019/03/23/%E6%A0%91%E4%B9%8B4%E4%B8%AA%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/03/23/树之4个迭代遍历/</id>
    <published>2019-03-23T03:23:04.000Z</published>
    <updated>2019-04-02T14:22:02.441Z</updated>
    
    <content type="html"><![CDATA[<p>以下的遍历都是迭代遍历   </p><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>层次遍历用到的是广度优先算法，BFS,从根节点开始一层层的搜索，所以在遍历的时候用到了队列<br>遍历的时候用到了两层循环，因为我们需要每一层的结点，用一个list存储，如果用一层循环的话，那么就是每一个结点用一个list存储。<br><a id="more"></a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">     List&lt;List&lt;Integer&gt;&gt; rlt = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">     if(root == null) &#123;</span><br><span class="line">     return rlt;</span><br><span class="line">     &#125;</span><br><span class="line">     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">     queue.offer(root);</span><br><span class="line">     while(!queue.isEmpty()) &#123;</span><br><span class="line">     int count = queue.size();</span><br><span class="line">     List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">     while(count&gt;0) &#123;</span><br><span class="line">     TreeNode node = queue.poll();</span><br><span class="line">     list.add(node.val);</span><br><span class="line">     if(node.left != null) &#123;</span><br><span class="line">     queue.offer(node.left);</span><br><span class="line">     &#125;</span><br><span class="line">     if(node.right != null) &#123;</span><br><span class="line">     queue.offer(node.right);</span><br><span class="line">     &#125;</span><br><span class="line">     count--;</span><br><span class="line">     &#125;</span><br><span class="line">     rlt.add(list);</span><br><span class="line">     &#125;</span><br><span class="line">     return rlt;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>跟层次遍历不一样的是，后三种遍历都是用栈的形式，先进后出   </p><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>压栈顺序，先右后左<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">if(root == null)&#123;</span><br><span class="line">    return list;</span><br><span class="line">    &#125;</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">while(!stack.isEmpty())&#123;</span><br><span class="line">TreeNode node = stack.pop();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">if(node.right != null)&#123;</span><br><span class="line">stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">  if(node.left != null)&#123;</span><br><span class="line">stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>左孩子入栈，出栈，再开始右孩子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123;</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null||!stack.isEmpty())&#123;</span><br><span class="line">            while(root!=null)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>还没写哈哈哈哈哈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下的遍历都是迭代遍历   &lt;/p&gt;
&lt;h1 id=&quot;层次遍历&quot;&gt;&lt;a href=&quot;#层次遍历&quot; class=&quot;headerlink&quot; title=&quot;层次遍历&quot;&gt;&lt;/a&gt;层次遍历&lt;/h1&gt;&lt;p&gt;层次遍历用到的是广度优先算法，BFS,从根节点开始一层层的搜索，所以在遍历的时候用到了队列&lt;br&gt;遍历的时候用到了两层循环，因为我们需要每一层的结点，用一个list存储，如果用一层循环的话，那么就是每一个结点用一个list存储。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="http://yoursite.com/2019/03/21/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/21/经典排序算法/</id>
    <published>2019-03-21T06:35:25.000Z</published>
    <updated>2019-03-21T12:24:08.769Z</updated>
    
    <content type="html"><![CDATA[<p>嘀嘀嘀！经典排序算法来袭，本文里面，讲解一些什么算法呢，噔噔噔噔噔，看这里：<br>冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快排  （完）<br><a id="more"></a><br><img src="/2019/03/21/经典排序算法/total_O.png" alt="">  </p><p>排序之前，理解一下，一下7中排序，可以分为3类<br>（1）交换排序<br>&#160;&#160;&#160;&#160;&#160;冒泡排序<br>&#160;&#160;&#160;&#160;&#160;快速排序<br>（2）插入排序<br>&#160;&#160;&#160;&#160;&#160;直接插入排序<br>&#160;&#160;&#160;&#160;&#160;希尔排序<br>（3）选择排序<br>&#160;&#160;&#160;&#160;&#160;简单选择排序<br>&#160;&#160;&#160;&#160;&#160;堆排序<br>（4）归并排序<br>&#160;&#160;&#160;&#160;&#160;归并排序  </p><p>归并排序是排序算法进行优化后，唯一稳定的（强！）</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序，是<em>相邻</em>的两个数两两对比<br>上图！（emmmmm,盗图嘎嘎嘎嘎嘎嘎）<br><img src="https://media.giphy.com/media/555q4ngZRoxHCtGSrT/giphy.gif" alt="Alt Text">  </p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">bubble(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void bubble(int[] str,int length) &#123;</span><br><span class="line">boolean flag = false;</span><br><span class="line">for(int i=0;i&lt;length-1;i++) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">for(int j=0;j&lt;length-1-i;j++) &#123;</span><br><span class="line">if(str[j]&gt;str[j+1]) &#123;</span><br><span class="line">int tmp = str[j];</span><br><span class="line">str[j] = str[j+1];</span><br><span class="line">str[j+1] = tmp;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            //没有进入到交换里面，说明已经排好序了，直接退出就好了</span><br><span class="line">if(!flag) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><img src="https://media.giphy.com/media/8gLh5k8Kv6rIJzkK4g/giphy.gif" alt="Alt Text"><br>第i趟找出最i小的值，每趟排序都能确定一个位置，注意这里标记的是下标哟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 直接选择排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SelectSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">select(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void select(int[] str, int length) &#123;</span><br><span class="line">int min = 0;</span><br><span class="line">int tmp;</span><br><span class="line">for(int i=0;i&lt;length-1;i++) &#123;</span><br><span class="line">min = i;</span><br><span class="line">for(int j=i+1;j&lt;length;j++) &#123;</span><br><span class="line">if(str[j]&lt;str[min]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(min != i) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">str[i] = str[min];</span><br><span class="line">str[min] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>怎么说，，这是一个我总会遗忘的排序，可能是理解的不够透彻    </p><p>认为第一个元素是已经被排序的，取出下一个元素，和前面的元素进行对比，而且是从后往前对比的，每趟排序，前i个元素都是有序的  </p><p>在简单的排序中，效率算是很高了    </p><p><img src="https://media.giphy.com/media/7zQ0f5CdcDj6D5wV4B/giphy.gif" alt="Alt Text">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 直接插入排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class InsertSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">insert(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void insert(int[] str, int length) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">int j;</span><br><span class="line">for(int i=1;i&lt;length;i++) &#123;</span><br><span class="line">if(str[i]&lt;str[i-1]) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">//从后往前哟,而且要注意j取值j&gt;0</span><br><span class="line">for(j= i;j&gt;0 &amp;&amp; str[j-1]&gt;tmp ;j--) &#123;</span><br><span class="line">//发现大的，依次往后移动一位</span><br><span class="line">str[j] = str[j-1];</span><br><span class="line">&#125;</span><br><span class="line">//那么找不到比他大的后，tmp就在该位置上</span><br><span class="line">str[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p> 希尔排序是需要一个递增序列的，先进行分组，然后再排序，它是基于插入排序的  ，那么这个递增序列，shell是有个建议的（😀）:<br>    d = n/2(向下取整)和 d(i) = d(i+1)/2(向下取整)</p><p><img src="https://media.giphy.com/media/1fWmXxhJ6Qdt1E9MHL/giphy.gif" alt="Alt Text"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ShellSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">shell(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void shell(int[] str, int length) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">int j;</span><br><span class="line">//分组：7,3,1</span><br><span class="line">for(int d= length/2;d&gt;0;d /= 2) &#123;</span><br><span class="line">for(int i=d;i&lt;length;i++) &#123;</span><br><span class="line">tmp = str[i];</span><br><span class="line">for(j = i;j&gt;=d &amp;&amp; str[j-d]&gt;tmp;j -= d) &#123;</span><br><span class="line">str[j] = str[j-d];</span><br><span class="line">&#125;</span><br><span class="line">str[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>大顶堆：每个结点的值都大于或等于其左右孩子结点的值<br>    a[i]&gt;=a[2<em>i+1] &amp;&amp; a[i]&gt;=a[i=2</em>i+2]<br>小顶堆：每个结点的值都小于或等于其左右孩子结点的值    </p><p>大顶堆：<br><img src="https://media.giphy.com/media/dtZVQy94EYzuxleArI/giphy.gif" alt="Alt Text">    </p><p>其实就是一个二叉树    </p><p>说明：</p><ul><li>当结点为i</li><li>那么左孩子为2*i+1;</li><li>右孩子为2*i+2;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">buildHeap(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构建大顶堆</span><br><span class="line"> * @param str</span><br><span class="line"> * @param length</span><br><span class="line"> */</span><br><span class="line">private static void buildHeap(int[] str, int length) &#123;</span><br><span class="line">//从第一个非叶子结点开始调整，从左至右，从上至下</span><br><span class="line">//-1是根据下标从0开始的习惯来的</span><br><span class="line">for(int i = length/2-1;i&gt;=0;i--) &#123;</span><br><span class="line">//构建</span><br><span class="line">heapAdjust(str, i , length);</span><br><span class="line">&#125;</span><br><span class="line">//调整</span><br><span class="line">for(int i = length-1;i&gt;0;i--) &#123;</span><br><span class="line">swap(str,0,i);//&quot;最大的&quot;进行互换</span><br><span class="line">heapAdjust(str, 0, i);//换完之后，进行调整</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] str, int i, int length) &#123;</span><br><span class="line">int tmp = str[i];</span><br><span class="line">str[i] = str[length];</span><br><span class="line">str[length] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void heapAdjust(int[] str, int i, int length) &#123;</span><br><span class="line">int j;</span><br><span class="line">int tmp;</span><br><span class="line">tmp = str[i];</span><br><span class="line">for(j = 2*i+1;j&lt;length;j*=2+1) &#123;</span><br><span class="line">//右孩子&gt;左孩子</span><br><span class="line">if(j != length-1 &amp;&amp; str[j]&lt;str[j+1]) &#123;</span><br><span class="line">j++;//指向最大的孩子</span><br><span class="line">&#125;</span><br><span class="line">if(tmp &gt;= str[j]) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str[i] = str[j];</span><br><span class="line">//注意，这里面的交换，是交换标记的位置</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>合并两个已经排好序的表，所以需要用递归将其分成最小的分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 归并排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">mergebulid(str,str.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergebulid(int[] str, int length) &#123;</span><br><span class="line">int[] tmp = new int[length];</span><br><span class="line">merge(str, tmp, 0, length-1);</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] str, int[] tmp, int left , int right) &#123;</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int center = (left+right)/2;</span><br><span class="line">merge(str, tmp, left, center);</span><br><span class="line">merge(str, tmp, center+1, right);</span><br><span class="line"></span><br><span class="line">mergeSort(str, tmp, left, center, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergeSort(int[] str, int[] tmp, int left, int center, int right) &#123;</span><br><span class="line">int i = left;</span><br><span class="line">int j = center+1;</span><br><span class="line">int k = 0;</span><br><span class="line">while(i&lt;=center &amp;&amp; j&lt;=right) &#123;</span><br><span class="line">if(str[i]&lt;str[j]) &#123;</span><br><span class="line">tmp[k++] = str[i++];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tmp[k++] = str[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;=center) &#123;</span><br><span class="line">tmp[k++] = str[i++];</span><br><span class="line">&#125;</span><br><span class="line">while(j&lt;=right) &#123;</span><br><span class="line">tmp[k++] = str[j++];</span><br><span class="line">&#125;</span><br><span class="line">//将排序好的数组拷贝到原数组中</span><br><span class="line">k = 0;</span><br><span class="line">while(left&lt;= right) &#123;</span><br><span class="line">str[left++] = tmp[k++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>快速排序就是要找一个枢纽元，常用的找枢纽元方法为：</p><ul><li>第一个元素代替，有的书上说是比较错误的做法</li><li>随机选取，是比较安全的做法</li><li>三数中值分割法<br>头，尾，中间三个数，找到枢纽元（中值），放在倒数第二个位置上</li></ul><p>快排思想：</p><ul><li>i指向第一个元素，j指向倒数第二个元素，所有的循环，必须i&lt;j</li><li>j左移，直到找到比枢纽元小的元素，或者直到i&lt;j不成立  </li><li>i右移，直到找到比枢纽元大的元素，或者直到i&lt;j不成立</li><li>如果满足i&lt;j，交换</li></ul><p>一直循环第2，3步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.sort;</span><br><span class="line">/**</span><br><span class="line"> * 快速排序</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class QuickSork &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str  = &#123;3,34,38,5,47,15,36,26,27,2,46,4,19,50,48&#125;;</span><br><span class="line">quick(str,0,str.length-1);</span><br><span class="line">for(int i=0;i&lt;str.length;i++) &#123;</span><br><span class="line">System.out.print(str[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void quick(int[] str, int left, int right) &#123;</span><br><span class="line">//找到枢纽元</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int pivot = median3(str,left,right);</span><br><span class="line">int i=left,j = right-1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">               //从左到右找大于pivot的值</span><br><span class="line">                //不是i++,因为第一个元素我们之前已经对比过了</span><br><span class="line">while(str[++i]&lt;pivot) &#123;&#125;</span><br><span class="line">//从右到左找到小于pivot的值</span><br><span class="line">while(j&gt;left &amp;&amp; str[--j]&gt;pivot) &#123;&#125;</span><br><span class="line">if(i&lt;j) &#123;</span><br><span class="line">swap(str, i, j);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;right) &#123;</span><br><span class="line">swap(str, i, right-1);</span><br><span class="line">&#125;</span><br><span class="line">quick(str,left,i-1);</span><br><span class="line">quick(str, i+1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int median3(int[] str, int left, int right) &#123;</span><br><span class="line">int center = (left+right)/2;</span><br><span class="line">if(str[left]&gt;str[center]) &#123;</span><br><span class="line">swap(str, left, center);</span><br><span class="line">&#125;</span><br><span class="line">if(str[center]&gt;str[right]) &#123;</span><br><span class="line">swap(str, center, right);</span><br><span class="line">&#125;</span><br><span class="line">if(str[left]&gt;str[right]) &#123;</span><br><span class="line">swap(str, left, right);</span><br><span class="line">&#125;</span><br><span class="line">swap(str, center, right-1);</span><br><span class="line">return str[right-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] str, int left, int right) &#123;</span><br><span class="line">int tmp = str[left];</span><br><span class="line">str[left] = str[right];</span><br><span class="line">str[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘀嘀嘀！经典排序算法来袭，本文里面，讲解一些什么算法呢，噔噔噔噔噔，看这里：&lt;br&gt;冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快排  （完）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>树之平衡二叉树</title>
    <link href="http://yoursite.com/2019/03/20/%E6%A0%91%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/20/树之平衡二叉树/</id>
    <published>2019-03-19T23:11:28.000Z</published>
    <updated>2019-03-20T07:03:37.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>是二叉排序树的一种，在二叉树中，可能会出现比较极端的二叉树，例如斜树，这样在查找的过程中，很影响效率，而平衡二叉排序树就很好的解决了这个问题。<br><a id="more"></a><br>AVL（和AVL算法有区别）,要么是一棵空树，要么左右子树都是平衡二叉树，且左右子树的深度之差的绝对值不超过1，算法复杂度O(lon(n))<br>又名平衡二叉搜索树Self-balancing binary search tree  </p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><ol><li>红黑树<br>一种自平衡二叉查找树，可以用于实现关联数组，又称为“对称二叉B树”</li><li><p>AVL<br>最早的自平衡二叉查找树算法，也是高度平衡树</p></li><li><p>替罪羊树</p></li><li>Treap<br>一棵二叉排序树，记录一个额外的数据（优先级），有堆的性质</li><li>伸展树<br>Splay Tree ,一种二叉排序树，优势为不需要记录用于平衡树的冗余信息</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>将一棵二叉树，变成平衡二叉树，依靠的是旋转，通常会出现四种情况<br>（1）左旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_left.png" alt=""><br>（2）右旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_right.png" alt=""><br>（3）左右旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_leftright.png" alt=""><br>（4）右左旋转<br><img src="/2019/03/20/树之平衡二叉树/avl_rightleft.png" alt=""></p><p>总之，什么时候双旋转呢？那就是bf符号不一致的时候，<br>什么时候会失去平衡呢，简单总结就是4句话  </p><ul><li>在左孩子的左子树上插入元素 - 右旋转</li><li>在左孩子的右子树上插入元素 - 左右旋转</li><li>在右孩子的右子树上插入元素 - 左旋转</li><li>在右孩子的左子树上插入元素 - 右左旋转<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>设一个平衡因子bf<br>IF 平衡因子 &gt;=2<br>&#160;&#160;&#160;&#160;IF 左结点的平衡因子 &lt;0<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;左旋转然后右旋转<br>&#160;&#160;&#160;&#160;&#160;ELSE<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;右旋转<br>ELSE IF 平衡因子 &lt;=-2<br>&#160;&#160;&#160;&#160;&#160;&#160;IF 右结点的平衡因子 &gt;0<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;右旋转<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;ELSE<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;左旋转</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.tree;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 平衡二叉树</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AVL &#123;</span><br><span class="line">private static final int ALLOWED_IMBALANCE = 1;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str = &#123;10,5,8,20,16,1,3,7,25&#125;;</span><br><span class="line">Tree tree = new Tree(str[0]);</span><br><span class="line">for(int i=1;i&lt;str.length;i++) &#123;</span><br><span class="line">insertAvl(tree,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">print(tree);</span><br><span class="line">System.out.println();</span><br><span class="line">remove(tree,10);</span><br><span class="line">print(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除某个结点</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param i</span><br><span class="line"> */</span><br><span class="line">private static Tree remove(Tree tree, int key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">if(key&lt;tree.getData()) &#123;</span><br><span class="line">tree.setLchild(remove(tree.getLchild(), key));</span><br><span class="line">&#125; else if(key&gt;tree.getData()) &#123;</span><br><span class="line">tree.setRchild(remove(tree.getRchild(), key));</span><br><span class="line">&#125;else if(tree.getLchild() != null &amp;&amp; tree.getRchild() != null) &#123;</span><br><span class="line">tree.setData(findMin(tree.getRchild()).getData());</span><br><span class="line">tree.setRchild(remove(tree.getRchild(), tree.getData()));</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = (tree.getLchild() != null)?tree.getLchild():tree.getRchild();</span><br><span class="line">&#125;</span><br><span class="line">return balanceAVL(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 找到右子树中最小的左子树（后继结点）</span><br><span class="line"> * @param data</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree findMin(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree;</span><br><span class="line">while(tree.getLchild() != null) &#123;</span><br><span class="line">tree = tree.getLchild();</span><br><span class="line">tmp = tree;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(tmp.getData());</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算平衡因子</span><br><span class="line"> */</span><br><span class="line">private static int hight(Tree tree) &#123;</span><br><span class="line">return tree == null ?-1 :tree.getBf();</span><br><span class="line">&#125;</span><br><span class="line">private static void print(Tree tree) &#123;</span><br><span class="line">if(tree != null) &#123;</span><br><span class="line">print(tree.getLchild());</span><br><span class="line">System.out.print(tree.getData()+&quot; &quot;);</span><br><span class="line">print(tree.getRchild());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**  </span><br><span class="line"> * 插入</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param key  带插入的元素</span><br><span class="line"> */</span><br><span class="line">private static Tree insertAvl(Tree tree, int  key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return new Tree(key, null, null);</span><br><span class="line">&#125; else if(key &lt; tree.getData())&#123;//插入在左子树</span><br><span class="line">tree.setLchild(insertAvl(tree.getLchild(), key));</span><br><span class="line">&#125; else if(key &gt; tree.getData())&#123;</span><br><span class="line">tree.setRchild(insertAvl(tree.getRchild(), key));</span><br><span class="line">&#125;</span><br><span class="line">return balanceAVL(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否平衡</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree balanceAVL(Tree tree) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">if(hight(tree.getLchild())-hight(tree.getRchild())&gt;ALLOWED_IMBALANCE) &#123;//左子树失去了平衡</span><br><span class="line">if(hight(tree.getLchild().getLchild())&gt;=hight(tree.getLchild().getRchild())) &#123;//将值插入到右子树</span><br><span class="line">tree = rotateWithLeftChild(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = doubleWithLeftChild(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(hight(tree.getRchild())-hight(tree.getLchild())&gt;ALLOWED_IMBALANCE) &#123;</span><br><span class="line">if(hight(tree.getRchild().getRchild())&gt;=hight(tree.getRchild().getLchild())) &#123;</span><br><span class="line">tree = rotateWithRightChild(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree = doubleWithRightChild(tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 先左转再右转</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree doubleWithLeftChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getLchild();</span><br><span class="line">tmp.setLchild(rotateWithRightChild(tmp));</span><br><span class="line">return rotateWithLeftChild(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Tree doubleWithRightChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getRchild();</span><br><span class="line">tmp.setRchild(rotateWithLeftChild(tmp));</span><br><span class="line">return rotateWithRightChild(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 单旋转，将左子树旋转到右子树</span><br><span class="line"> * @param tree</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static Tree rotateWithLeftChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getLchild();</span><br><span class="line">tree.setLchild(tree.getRchild());</span><br><span class="line">tmp.setRchild(tree);</span><br><span class="line">tree.setBf(Math.max(hight(tree.getLchild()), hight(tree.getRchild()))+1);</span><br><span class="line">tmp.setBf(Math.max(hight(tmp.getLchild()), tree.getBf())+1);</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Tree rotateWithRightChild(Tree tree) &#123;</span><br><span class="line">Tree tmp = tree.getRchild();</span><br><span class="line">tree.setRchild(tree.getLchild());</span><br><span class="line">tmp.setRchild(tree);</span><br><span class="line">tree.setBf(Math.max(hight(tree.getLchild()), hight(tree.getRchild()))+1);</span><br><span class="line">tmp.setBf(Math.max(hight(tmp.getRchild()), tree.getBf())+1);</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;是二叉排序树的一种，在二叉树中，可能会出现比较极端的二叉树，例如斜树，这样在查找的过程中，很影响效率，而平衡二叉排序树就很好的解决了这个问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树之二叉排序树</title>
    <link href="http://yoursite.com/2019/03/19/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/19/树之二叉排序树/</id>
    <published>2019-03-19T04:54:49.000Z</published>
    <updated>2019-03-23T03:26:23.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>树里面的精华哟，因为利用了二进制<br>Binary Sort Tree 又称为二叉查找树ADT，它可以是一棵空树，或者具有一下性质的树：<br><a id="more"></a></p><ul><li>若左子树不为空，那么左子树上所有结点的值均小于根结构的值</li><li>若右子树不为空，那么右子树上所有结点的值均大于跟结构的值</li><li>它的左右子树分别为二叉排序树</li></ul><p>说明了啥呢，，，，，，哈哈哈哈，人家是递归呀  </p><p>对了，就是树的中序遍历</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean SearchBST(Tree t, int key)&#123;</span><br><span class="line">if(t == null)&#123;</span><br><span class="line">return false;</span><br><span class="line">    &#125; else if (t.data == key)&#123;</span><br><span class="line">return true;</span><br><span class="line">    &#125; else if(key&lt;t.data)&#123;</span><br><span class="line">return Search(t.lchild, key);</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">return Search(t.rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除的时候，要注意，该位置用哪个结点进行填充，有一个规则是：<br>要么是当前结点的前驱，要么是当前结点的后继（根据中序遍历的特点来的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static boolean deleteBST(Tree tree, int key) &#123;</span><br><span class="line">if(tree != null) &#123;</span><br><span class="line">if(key == tree.getData()) &#123;</span><br><span class="line">delete(tree);</span><br><span class="line">return true;</span><br><span class="line">&#125;else if(key&lt;tree.getData()) &#123;</span><br><span class="line">return deleteBST(tree.getLchild(), key);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return deleteBST(tree.getRchild(), key);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void delete(Tree tree) &#123;</span><br><span class="line">Tree q,s;//上一个结点</span><br><span class="line">if(tree.getRchild() == null) &#123;//叶子结点</span><br><span class="line">q = tree;</span><br><span class="line">//tree = tree.getLchild();</span><br><span class="line">tree.setData(tree.getLchild().getData());</span><br><span class="line">tree.setLchild(null);</span><br><span class="line">&#125; else if(tree.getLchild() == null) &#123;</span><br><span class="line">q = tree;</span><br><span class="line">//tree = tree.getRchild();</span><br><span class="line">tree.setData(tree.getRchild().getData());</span><br><span class="line">tree.setRchild(null);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">//替换直接前驱或者直接后继</span><br><span class="line">q = tree;</span><br><span class="line">s = tree.getLchild();</span><br><span class="line">while(s.getRchild() != null) &#123;</span><br><span class="line">q = s;</span><br><span class="line">s = s.getRchild();</span><br><span class="line">&#125;</span><br><span class="line">tree.setData(s.getData());</span><br><span class="line">if(q != tree) &#123;//判断有没有右子树</span><br><span class="line">q.setRchild(s.getLchild());</span><br><span class="line">&#125;else &#123;</span><br><span class="line">q.setLchild(s.getLchild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入元素</span><br><span class="line"> * @param tree</span><br><span class="line"> * @param i</span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">private static Tree insertSort(Tree tree, int key) &#123;</span><br><span class="line">if(tree == null) &#123;</span><br><span class="line">tree = new Tree(key);</span><br><span class="line">return tree;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if(key&lt;=tree.getData()) &#123;</span><br><span class="line">tree.setLchild(insertSort(tree.getLchild(), key));</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tree.setRchild(insertSort(tree.getRchild(), key));</span><br><span class="line">&#125;</span><br><span class="line">return tree;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] str = &#123;111,104,105,46,115,99,70,109,67&#125;;</span><br><span class="line">Tree tree = new Tree(str[0]);</span><br><span class="line">for(int i=1;i&lt;str.length;i++) &#123;</span><br><span class="line">insertSort(tree,str[i]);</span><br><span class="line">//tmp = tree;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;中序遍历：&quot;);</span><br><span class="line">print(tree);</span><br><span class="line">//假设删除的是数据105</span><br><span class="line">if(deleteBST(tree,105)) &#123;</span><br><span class="line">System.out.print(&quot;\n删除后:&quot;);</span><br><span class="line">print(tree);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\n删除结点不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 打印二叉树</span><br><span class="line"> * @param tree</span><br><span class="line"> */</span><br><span class="line">private static void print(Tree tree) &#123;</span><br><span class="line"></span><br><span class="line">if(tree != null)&#123;</span><br><span class="line">print(tree.getLchild());</span><br><span class="line">System.out.print(tree.getData()+&quot; &quot;);</span><br><span class="line">print(tree.getRchild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：46 67 70 99 104 105 109 111 115<br>删除后:46 67 70 99 104 109 111 115 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;树里面的精华哟，因为利用了二进制&lt;br&gt;Binary Sort Tree 又称为二叉查找树ADT，它可以是一棵空树，或者具有一下性质的树：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>图论之关键路径</title>
    <link href="http://yoursite.com/2019/03/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/03/19/图论之关键路径/</id>
    <published>2019-03-19T02:23:23.000Z</published>
    <updated>2019-03-19T03:36:11.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li>源点<br>没有入度的顶点</li><li>汇点<br>没有出度的顶点</li><li>事件<br>顶点</li><li>活动<br>弧<a id="more"></a><h1 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h1>再带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图称为AOE网：Activity Edge Network<h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1>最长路径之和<br>关键路径是建立在拓扑序列上的</li></ol><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><h2 id="ETV"><a href="#ETV" class="headerlink" title="ETV"></a>ETV</h2><p>Earliest Time Of Vertex 时间最早发生时间，就是顶点的最早发生时间</p><h2 id="LTV"><a href="#LTV" class="headerlink" title="LTV"></a>LTV</h2><p>Latest Time Of Vertex:事件最晚发生时间，就是每个顶点对应的事件最晚需要开始的时间，如果超出此事件就会延误整个工期。</p><h2 id="ETE"><a href="#ETE" class="headerlink" title="ETE"></a>ETE</h2><p>Earliesr Time Of Edge:活动的最早开始事件，就是弧的最早发生时间</p><h2 id="LTE"><a href="#LTE" class="headerlink" title="LTE"></a>LTE</h2><p>Latest Time Of Edge:活动的最晚发生时间，就是不推迟工期的最晚开工时间。</p><p><img src="/2019/03/19/图论之关键路径/aoe_1.PNG" alt=""></p><p><img src="/2019/03/19/图论之关键路径/aoe_2.PNG" alt=""> </p><p>由此可发现：<br>ETV，ETE是顺序来的<br>LTV，LTE是逆序来的<br>ETV可以推断出ETE<br>LTV可以推断出LTE<br>关键路径：最早发生时间ETV和最晚发生时间LTV相等的时候 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;源点&lt;br&gt;没有入度的顶点&lt;/li&gt;
&lt;li&gt;汇点&lt;br&gt;没有出度的顶点&lt;/li&gt;
&lt;li&gt;事件&lt;br&gt;顶点&lt;/li&gt;
&lt;li&gt;活动&lt;br&gt;弧&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图论之拓扑结构</title>
    <link href="http://yoursite.com/2019/03/18/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/18/图论之拓扑结构/</id>
    <published>2019-03-18T07:40:55.000Z</published>
    <updated>2019-03-19T03:35:59.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无环图"><a href="#无环图" class="headerlink" title="无环图"></a>无环图</h1><p>DAG：Directed Acyclic Graph<br>五环的有向图</p><h1 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h1><p>Active On Vertex Network,有向图为顶点表示活动的网<br><a id="more"></a></p><h1 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><p>&#160;&#160;&#160;&#160;&#160;&#160;设G = (V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,…,Vn满足：若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则这样的一个顶点序列称为 拓扑序列</p><h1 id="拓扑序列-1"><a href="#拓扑序列-1" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><p>将一个有向图构造成一个拓扑序列的过程   </p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从AOV网中选择一个没有前驱的顶点（入度为0），并且输出它  </li><li>从网中删除该顶点并且删除从该顶点出发的全部有向边  </li><li>重复以上两个步骤，直到剩余网中不再存在没有前驱的顶点为止   </li></ol><p>可以用邻接表实现哟，因为要删除顶点，所以会比邻接矩阵方便一些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean topologicalSort() &#123;</span><br><span class="line">    //统计输出顶点数</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    //建栈存储入度为0的顶点</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    //统计入度数（录入也可以，但是示例图的v9的度应为2，示例图中误写为1，导致查了半天bug，自动统计入度数看来也是有必要的）</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        vexList.get(i).setIn(0);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        </span><br><span class="line">        EdgeNode edge = vexList.get(i).getFirstEdge();</span><br><span class="line">        while (edge != null) &#123;</span><br><span class="line">            VertexNode vex = vexList.get(edge.getAdjvex());</span><br><span class="line">            vex.setIn(vex.getIn() + 1);</span><br><span class="line">            </span><br><span class="line">            edge = edge.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将入度为0 的顶点入栈</span><br><span class="line">    for (int i = 0;i &lt; vexList.size(); i++) &#123;</span><br><span class="line">        if (vexList.get(i).getIn() == 0) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        //栈顶 顶点出栈</span><br><span class="line">        int vexIndex = stack.pop();</span><br><span class="line">        System.out.print(vexIndex + &quot;  &quot;);</span><br><span class="line">        </span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        //从顶点表结点中取出第一个边表结点</span><br><span class="line">        EdgeNode edge = vexList.get(vexIndex).getFirstEdge();</span><br><span class="line">        </span><br><span class="line">        while (edge != null) &#123;</span><br><span class="line">            int adjvex = edge.getAdjvex();</span><br><span class="line">            </span><br><span class="line">            VertexNode vex = vexList.get(adjvex);</span><br><span class="line">            </span><br><span class="line">            //将此 顶点的入度减一</span><br><span class="line">            vex.setIn(vex.getIn() - 1);</span><br><span class="line">            //此顶点的入度为零则入栈，以便于下次循环输出</span><br><span class="line">            if (vex.getIn() == 0) &#123;</span><br><span class="line">                stack.push(adjvex);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            edge = edge.getNext();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (count != vexList.size())</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 边表结点</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class EdgeNode &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 邻接点域，存储该顶点对应的下标</span><br><span class="line">     */</span><br><span class="line">    private int adjvex;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 用于存储权值，对于非网图可以不需要</span><br><span class="line">     */</span><br><span class="line">    private int weight;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 链域，指向下一个邻接点</span><br><span class="line">     */</span><br><span class="line">    private EdgeNode next;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    public EdgeNode(int adjvex, int weight, EdgeNode next) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.adjvex = adjvex;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getAdjvex() &#123;</span><br><span class="line">        return adjvex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setAdjvex(int adjvex) &#123;</span><br><span class="line">        this.adjvex = adjvex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getWeight() &#123;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setWeight(int weight) &#123;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public EdgeNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setNext(EdgeNode next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 顶点表结点</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class VertexNode &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 顶点入度</span><br><span class="line">     */</span><br><span class="line">    private int in;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 顶点域，存储顶点信息（下标）</span><br><span class="line">     */</span><br><span class="line">    private int data;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 边表头指针</span><br><span class="line">     */</span><br><span class="line">    private EdgeNode firstEdge;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    public VertexNode(int in, int data, EdgeNode firstEdge) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.in = in;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.firstEdge = firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getIn() &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setIn(int in) &#123;</span><br><span class="line">        this.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setData(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public EdgeNode getFirstEdge() &#123;</span><br><span class="line">        return firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setFirstEdge(EdgeNode firstEdge) &#123;</span><br><span class="line">        this.firstEdge = firstEdge;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用于判断一个图是否存在环，存在的话，返回false，否则返回true</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;无环图&quot;&gt;&lt;a href=&quot;#无环图&quot; class=&quot;headerlink&quot; title=&quot;无环图&quot;&gt;&lt;/a&gt;无环图&lt;/h1&gt;&lt;p&gt;DAG：Directed Acyclic Graph&lt;br&gt;五环的有向图&lt;/p&gt;
&lt;h1 id=&quot;AOV网&quot;&gt;&lt;a href=&quot;#AOV网&quot; class=&quot;headerlink&quot; title=&quot;AOV网&quot;&gt;&lt;/a&gt;AOV网&lt;/h1&gt;&lt;p&gt;Active On Vertex Network,有向图为顶点表示活动的网&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>关联分析之Apriori</title>
    <link href="http://yoursite.com/2019/03/15/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B9%8BApriori/"/>
    <id>http://yoursite.com/2019/03/15/关联分析之Apriori/</id>
    <published>2019-03-15T14:47:55.000Z</published>
    <updated>2019-03-15T14:50:42.549Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/15/关联分析之Apriori/apriori.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/03/15/关联分析之Apriori/apriori.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>来京第一次搬家</title>
    <link href="http://yoursite.com/2019/03/09/%E6%9D%A5%E4%BA%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AC%E5%AE%B6/"/>
    <id>http://yoursite.com/2019/03/09/来京第一次搬家/</id>
    <published>2019-03-09T13:50:23.000Z</published>
    <updated>2019-03-09T14:09:10.092Z</updated>
    
    <content type="html"><![CDATA[<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;2019年3月9日，从去年九月23号来京，将近半年了，这半年怎么说，感觉很浪费了，一是在于自己当初真的是太着急了，二是这半年来的得过且过。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;收拾东西的时候，很烦，真的很烦，东西太多了，两个行李箱，一个行李袋，外加好几个箱子，还有一些杂七杂八的东西，然后,emmmmm，懒癌犯了，想着，自己当初为什么要来北京，天津也不错啊，然后给自己的理由是，嗯，有小哥哥啊（甩锅给小哥哥，其实没他我也会在北京呆着，哎，（我的）才华配不上我的理想啊），难受的哭唧唧<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;不过搬家前有朋友一直再说帮我搬，很开心，然后今天搬家的时候，朋友特地开车过来帮忙，美滋滋呀，有朋友帮忙的感觉是真的好呀。  </p><p>今天就当作是新的开始好了</p><p>一切都要加油哟！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;2019年3月9日，从去年九月23号来京，将近半年了，这半年怎么说，感觉很浪费了，一是在于自己当初真的是太着急了，二是这半年来的得过且过。&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#16
      
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理</title>
    <link href="http://yoursite.com/2019/03/05/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/05/正向代理和反向代理/</id>
    <published>2019-03-05T10:00:58.000Z</published>
    <updated>2019-03-07T03:21:28.998Z</updated>
    
    <content type="html"><![CDATA[<p>对于代理一直比较懵，现在把理解出来的代理记下来~~~因为我觉得我会忘掉了，如果长时间不看  </p><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>对于一个无法访问的网站，例如Google，我们就需要一个代理<br>我们向代理发送一个请求，代理转发请求去网站拿数据，再把请求发送回来<br><a id="more"></a></p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ul><li>可以做缓存</li><li>加快访问速度</li><li>代理可以记录用户访问记录，对外隐藏用户信息</li><li>对客户端（用户）访问授权，上网进行认证</li></ul><p>所以我们需要去租一个服务器，然后在主机上进行配置，就可以<em>科学上网</em>啦  </p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>Reverse Proxy   </p><p>这里比较神奇，客户端竟然都不知道代理的存在！！！<br>反向代理对外都是透明的<br>因此啊，访问者根本不知道自己访问的是一个网站，还是一个代理！！！   哼，流氓   </p><p>Nginx就是一个反向代理<br>客户端访问一个网站（代理）时：</p><p>客户端发送请求给代理，此时的代理有内网和外网，外网是公共访问地址，这时候反响代理服务器拿着请求，找到内网地址，去到了对应的服务器  </p><h2 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h2><ul><li>一般大型的网站，使用的都是反向代理，将反向代理作为公网的访问地址，WEB服务器是内网。   </li><li>负载均衡，通过反向代理服务器来优化网站的负载  </li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>盗个图<br><img src="/2019/03/05/正向代理和反向代理/proxy.PNG" alt="">  </p><p>正向代理中，proxy和client属于同一个LAN，对server透明<br>反向代理中，proxy和server属于同一个LAN，对client透明   </p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>一款轻量级的Web服务器/反向代理服务器，工作在七层的http协议的负载均衡系统  </p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>模块化设计<br>扩展性好</li><li>高可靠性<br>主控进程heworker是同步实现的，一个worker出现问题，会立刻启动另一个worker  </li><li>低内存<br>一万个长连接(keep-alive)，仅消耗2.5MB内存  </li><li>支持热部署<br>不用停止服务器，实现更新配置文件，更新日志文件，跟新服务器程序版本。</li><li>高并发<br>官方数据，每秒支持5万并发。</li><li>功能丰富<br>优秀的反向代理功能和灵活的负载均衡策略   </li></ul><p>还有很多，这里只是一个大概的了解  </p><p>吼吼吼</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于代理一直比较懵，现在把理解出来的代理记下来~~~因为我觉得我会忘掉了，如果长时间不看  &lt;/p&gt;
&lt;h1 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h1&gt;&lt;p&gt;对于一个无法访问的网站，例如Google，我们就需要一个代理&lt;br&gt;我们向代理发送一个请求，代理转发请求去网站拿数据，再把请求发送回来&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>树之最小生成树</title>
    <link href="http://yoursite.com/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/01/图论之最小生成树/</id>
    <published>2019-03-01T02:30:47.000Z</published>
    <updated>2019-03-18T07:41:52.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树 MST"></a>最小生成树 MST</h1><p>最小，指的是权值的和最小</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Minimum Spanning Tree.一个有n个结点的<em>连通图</em>的生成树 是  原图的极小连通子图，且包含原图中的所有n个结点，并且保持图连通的最少的边<br>本身是一棵树<br><a id="more"></a><br>所以一定是无环的哟<br>两个典型的算法，为啥是两个呢，因为啊，哎，两个人提出来的，然后就根据名字来命名了！</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法(Prim)"></a>普里姆算法(Prim)</h2><p>体现了回溯法和贪心算法</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>（1）输入：一个加权的连通图，其中呢，顶点集合为V，边集合为E(呀哈，邻接矩阵，邻接链表也可以哟)<br>（2）初始化：全都初始化为0<br>（3）首先随意的选取一个顶点，再选取权值最小的边，标记这两个顶点<br>（4）若有一个顶点，连接一个以上被标记的顶点，舍去权值最大的那条边<br>（5）一直执行第三步，知道遍历完所有的边</p><p><strong><em>要注意</em></strong><br>千万不能形成一个环呀</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>（1）选取一个顶点（0）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_1.PNG" alt=""><br>（2）找到与之相连的，权值最小的边和顶点<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_2.PNG" alt=""><br>（3）即第四步，舍弃权值最大的那条边（舍弃权值为：6和7）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_3.PNG" alt=""><br>（4）重复第三步，找到当前顶点，权值最小的边和顶点（顶点5）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_4.PNG" alt=""><br>（5）重复第四步，舍去边（5和6）<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_5.PNG" alt=""><br>（6）重复第三步，选出最小边，相等时，随便选<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_6.PNG" alt=""><br>（7）重复第四步，社区最大边<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/prime_7.PNG" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * prim算法实现最小生成树</span><br><span class="line"> * @param g 图</span><br><span class="line"> */</span><br><span class="line">public static void MiniSpanTree_Prim(Graph g) &#123;</span><br><span class="line">int min, j, k;</span><br><span class="line">int maxvex  = 0;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共几个顶点&quot;);</span><br><span class="line">maxvex= scan.nextInt();</span><br><span class="line">int[] adjvex = new int[maxvex];//保存相关顶点下标</span><br><span class="line">int[] lowcoat = new int[maxvex];//保存相关顶点间边的权值</span><br><span class="line">lowcoat[0] = 0;</span><br><span class="line">adjvex[0] = 0;</span><br><span class="line">//初始化</span><br><span class="line">for(int i=1;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">lowcoat[i] =g.edges[0][i];</span><br><span class="line">adjvex[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">//构建</span><br><span class="line">for(int i=1;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">min = Integer.MAX_VALUE;//初始化已给不可能数值</span><br><span class="line">j = 1;</span><br><span class="line">k = 0;</span><br><span class="line">//遍历所有的顶点</span><br><span class="line">while(j&lt;g.numVertex) &#123;</span><br><span class="line">//找到lowcoat数组中存储的最小权值</span><br><span class="line">// == 0 是自己连线</span><br><span class="line">if(lowcoat[j] != 0 &amp;&amp; lowcoat[j]&lt;min) &#123;</span><br><span class="line">min = lowcoat[j];</span><br><span class="line">k = j;//将发现的最小权值的下标存入k,以待使用</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">//打印当前顶点边中权值最小的边</span><br><span class="line">System.out.println(adjvex[k]+&quot;-&quot;+k);</span><br><span class="line">lowcoat[k] = 0;//设置当前顶点的权值为0，表示此顶点已经完成任务</span><br><span class="line">//这里重要一点，逐个遍历邻接矩阵k行所有顶点</span><br><span class="line">for(j=1;j&lt;g.numVertex;j++) &#123;</span><br><span class="line">if(lowcoat[j] != 0 &amp;&amp; g.edges[k][j] &lt;lowcoat[j]) &#123;</span><br><span class="line">lowcoat[j] = g.edges[k][j];</span><br><span class="line">adjvex[j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="克鲁斯卡尔-Kruskal"><a href="#克鲁斯卡尔-Kruskal" class="headerlink" title="克鲁斯卡尔(Kruskal)"></a>克鲁斯卡尔(Kruskal)</h2><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>先构造一个只含n个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根节点，然后，从E中取出一条权值最小的边，如果这条边的两个顶点属于不同的树，那么将其加入子图(两棵树合成一棵树)；否则的话，不可以取哟，应该取下一条权值最小的边再试试。结束条件：森林中只有一棵树，也就是说，图里面有n-1条边为止。<br>原理是   只含顶点不含边的森林<br>本身是一个森林  </p><h2 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h2><p>用的是边界数组<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal.PNG" alt=""><br>边集数组是按照权值从小到达排序的<br>（1）找到边集数组中的边，直到所有的顶点都遍历完<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal_1.PNG" alt=""><br>（2）若边的两个顶点在同一棵树上，舍去，下一条边，若权值相等，随便选取一条<br><img src="/2019/03/01/图论之最小生成树/树之最小生成树/kruskal_2.PNG" alt=""></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAGEDGE = 5;</span><br><span class="line">class Edge&#123;</span><br><span class="line">int begin;</span><br><span class="line">int end;</span><br><span class="line">int weight;//权值</span><br><span class="line">&#125;</span><br><span class="line">public int find(int[] parent, int f) &#123;</span><br><span class="line">while(parent[f]&gt;0) &#123;</span><br><span class="line">f = parent[f];</span><br><span class="line">&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * kruskal算法实现最小生成树</span><br><span class="line"> */</span><br><span class="line">public void MiniSpanTree_Kruskal(Graph g) &#123;</span><br><span class="line">int i, n, m;</span><br><span class="line">Edge[] edges  = new Edge[MAGEDGE];//边集数组</span><br><span class="line">    int[] parent = new int[MAGEDGE];//用于判断是否形成回路</span><br><span class="line">    //初始化</span><br><span class="line">    for(i = 0;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">    parent[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;g.numVertex;i++) &#123;</span><br><span class="line">    n = find(parent,edges[i].begin);</span><br><span class="line">    m = find(parent,edges[i].end);</span><br><span class="line">    if(n != m) &#123;//否则的话，就形成了一个环路</span><br><span class="line">    parent[n] = m;//将此边的结尾顶点放入下标为起点的parent数组中，表示此顶点已经再生成树集合中</span><br><span class="line">    System.out.println(&quot;连接情况：&quot;+edges[i].begin+&quot;-&gt;&quot;+edges[i].end+&quot;权重为：&quot;+edges[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难理解的是parent数组，注意，parent数组的值是可以重复的！！！</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>克鲁斯卡尔适合边数少的图，普里姆适合边数多的图</p><p>以上算法都是<strong><em>贪心算法</em></strong>的应用</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最小生成树-MST&quot;&gt;&lt;a href=&quot;#最小生成树-MST&quot; class=&quot;headerlink&quot; title=&quot;最小生成树 MST&quot;&gt;&lt;/a&gt;最小生成树 MST&lt;/h1&gt;&lt;p&gt;最小，指的是权值的和最小&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;Minimum Spanning Tree.一个有n个结点的&lt;em&gt;连通图&lt;/em&gt;的生成树 是  原图的极小连通子图，且包含原图中的所有n个结点，并且保持图连通的最少的边&lt;br&gt;本身是一棵树&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图论之最短路径</title>
    <link href="http://yoursite.com/2019/03/01/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/03/01/图论之最短路径/</id>
    <published>2019-03-01T02:27:28.000Z</published>
    <updated>2019-03-18T07:41:47.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>一个顶点到另一个顶点的最短路径，与最小生成树不同的是，这里最短路径不一定包含所有的顶点，但是最小生成树一定要包含所有的顶点。<br><a id="more"></a></p><h2 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h2><p>Dijkstra.算法复杂度O(n^2) 使用了贪心算法，求出所有的顶点路径。算法和prim相似，先赋值，再修正<br><img src="/2019/03/01/图论之最短路径/dijkstra.jpg" alt=""></p><p>啦啦啦啦啦，这个算法，其实，效率很低哈哈哈哈   </p><p>下图中的算法中，使用的是邻接矩阵</p><h2 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h2><p>Floyd.算法复杂度O(n^3),是动态规划的应用<br><img src="/2019/03/01/图论之最短路径/凸轮之最短路径/floyd.jpg" alt=""></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li>路径<br>迪杰斯特拉算法求的是一个顶点到所有顶点的最短路径<br>弗洛伊德算法求得是所有顶点到所有顶点得最短路径</li><li>弗洛伊德算法得代码更加简洁  </li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;最短路径&lt;/h1&gt;&lt;p&gt;一个顶点到另一个顶点的最短路径，与最小生成树不同的是，这里最短路径不一定包含所有的顶点，但是最小生成树一定要包含所有的顶点。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历</title>
    <link href="http://yoursite.com/2019/02/26/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/02/26/图的遍历/</id>
    <published>2019-02-25T16:17:34.000Z</published>
    <updated>2019-03-18T07:41:42.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>Depth First Search.  与树的先序遍历类似。从某个顶点出发，依次向下访问<br>分析：</p><ol><li>访问初始顶点v，并标记顶点v已经被访问<a id="more"></a></li><li>找到顶点v的第一个邻接顶点w</li><li>若顶点w存在，则执行第4步，否则结束算法</li><li>若顶点w未被访问，进行深度优先遍历（重复123步骤）</li><li>找到W的下一个邻接顶点，执行第3步</li></ol><h2 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><p>用的递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.synth.SynthSpinnerUI;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;String&gt; vertexList;//用来存储顶点信息</span><br><span class="line">private int[][] edges;//邻接矩阵，存储顶点之间的边信息</span><br><span class="line">private int numEdges;//边的数目</span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> * @param n</span><br><span class="line"> */</span><br><span class="line">public GraphVertex(int n) &#123;</span><br><span class="line">vertexList = new ArrayList&lt;&gt;(n);</span><br><span class="line">edges = new int[n][n];</span><br><span class="line">numEdges = 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到结点个数</span><br><span class="line"> */</span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return vertexList.size();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到边数</span><br><span class="line"> */</span><br><span class="line">public int getNumEdges() &#123;</span><br><span class="line">return numEdges;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param i</span><br><span class="line"> * @return 返回第i个结点的信息</span><br><span class="line"> */</span><br><span class="line">public String getValueByIndex(int i) &#123;</span><br><span class="line">return vertexList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param v1  第一个顶点</span><br><span class="line"> * @param v2  第二个顶点</span><br><span class="line"> * @return 返回两个顶点之间的权值</span><br><span class="line"> */</span><br><span class="line">public int getWeight(int v1, int v2) &#123;</span><br><span class="line">return edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 插入结点到集合中</span><br><span class="line"> * @param vertex</span><br><span class="line"> */</span><br><span class="line">public void insertVertex(String vertex) &#123;</span><br><span class="line">if(vertexList.contains(vertex)) &#123;</span><br><span class="line">System.out.println(&quot;该顶点已存在！！！&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">vertexList.add(vertexList.size(), vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 邻接矩阵存储</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @param weight 权值</span><br><span class="line"> */</span><br><span class="line">public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">if(edges[v1][v2] != 0) &#123;//修改权值而不是新增的</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">numEdges++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 删除边</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> */</span><br><span class="line">public void deleteEdge(int v1, int v2) &#123;</span><br><span class="line">if(edges[v1][v2] == 0) &#123;</span><br><span class="line">System.out.println(&quot;该边不存在！！！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = 0;</span><br><span class="line">numEdges--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param index</span><br><span class="line"> * @return 当前结点第一个邻接顶点下标</span><br><span class="line"> */</span><br><span class="line">public int getFirshNeighbor(int index) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[index][i]&gt;0) &#123;//行是相同的哟</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param v1 开始顶点的下标</span><br><span class="line"> * @param v2 结束顶点的下标</span><br><span class="line"> * @return 下一个邻接顶点</span><br><span class="line"> */</span><br><span class="line">public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">for(int i= v2+1; i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[v1][i]&gt;0) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印邻接矩阵</span><br><span class="line"> */</span><br><span class="line">private void print() &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">System.out.print(&quot;\t&quot;+vertexList.get(i)+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;edges[0].length;i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot;\t&quot;);</span><br><span class="line">for(int j=0;j&lt;edges[0].length;j++) &#123;</span><br><span class="line">System.out.print(edges[i][j]+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void depthFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">//初始化</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">DFS(i,visited);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 深度优先遍历</span><br><span class="line"> * @param v</span><br><span class="line"> * @param visited</span><br><span class="line"> */</span><br><span class="line">private void DFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">//打印出遍历的结点</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">        //整个循环不仅可以用getNumVertex()进行判断，也可以用权值判断，权值为-1表示是没有边的</span><br><span class="line">for(int j=0;j&lt;getNumVertex();j++) &#123;</span><br><span class="line">            //if(有边，未被访问，权值不超过最大值)</span><br><span class="line">            </span><br><span class="line">if(edges[i][j] != 0 &amp;&amp; !visited[j] &amp;&amp; edges[i][j] != 65535) &#123;</span><br><span class="line">DFS(j,visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int n=8,e=9;//分别代表结点个数和边的数目</span><br><span class="line">        String labels[]=&#123;&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;,&quot;v5&quot;,&quot;v6&quot;,&quot;v7&quot;,&quot;v8&quot;&#125;;//结点的标识</span><br><span class="line">        GraphVertex graph=new GraphVertex(n);</span><br><span class="line">        for(String label:labels) &#123;</span><br><span class="line">            graph.insertVertex(label);//插入结点</span><br><span class="line">        &#125;</span><br><span class="line">        //插入九条边</span><br><span class="line">        graph.insertEdge(0, 1, 1);</span><br><span class="line">        graph.insertEdge(0, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 3, 1);</span><br><span class="line">        graph.insertEdge(1, 4, 1);</span><br><span class="line">        graph.insertEdge(3, 7, 1);</span><br><span class="line">        graph.insertEdge(4, 7, 1);</span><br><span class="line">        graph.insertEdge(2, 5, 1);</span><br><span class="line">        graph.insertEdge(2, 6, 1);</span><br><span class="line">        graph.insertEdge(5, 6, 1);</span><br><span class="line">        graph.insertEdge(1, 0, 1);</span><br><span class="line">        graph.insertEdge(2, 0, 1);</span><br><span class="line">        graph.insertEdge(3, 1, 1);</span><br><span class="line">        graph.insertEdge(4, 1, 1);</span><br><span class="line">        graph.insertEdge(7, 3, 1);</span><br><span class="line">        graph.insertEdge(7, 4, 1);</span><br><span class="line">        graph.insertEdge(6, 2, 1);</span><br><span class="line">        graph.insertEdge(5, 2, 1);</span><br><span class="line">        graph.insertEdge(6, 5, 1);</span><br><span class="line">        graph.print();</span><br><span class="line">System.out.println(&quot;深度优先,从结点v1开始&quot;);</span><br><span class="line">graph.depthFirstSearch(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>结果<br><img src="/2019/02/26/图的遍历/vertexDFS.PNG" alt=""></p></blockquote><h2 id="马踏棋盘问题"><a href="#马踏棋盘问题" class="headerlink" title="马踏棋盘问题"></a>马踏棋盘问题</h2><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>Breadth First Search. 又称为“宽度优先搜索”或“横向优先搜索”<br>从某一顶点出发，依次访问邻接的所有顶点<br>因为BFS并不使用经验法则算法，所以展开结点而得到的子节点都会被加进一个先进先出的队列中。</p><p>分析：</p><ol><li>访问初始顶点v，并标记顶点v已经被访问</li><li>结点v入队列</li><li>当队列非空时，继续向下执行，否则结束算法</li><li>出队列，获得队头结点u</li><li>找到结点u的第一个邻接顶点w</li><li>若w不存在，执行第3步，否则向下执行</li><li>若w未被访问，标记顶点w已经被访问</li><li>顶点w入队列</li><li>找到顶点的第二个邻接顶点，执行第6步</li></ol><p>其实就是按照邻接矩阵的行进行寻找的<br>第一行的0-n列<br>第二行的0-n列<br>……</p><h2 id="邻接矩阵实现-1"><a href="#邻接矩阵实现-1" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><p>用的是迭代</p><p>根据出队下标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void broadFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">BFS(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">private void BFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">//第一次访问的顶点</span><br><span class="line">System.out.print(getValueByIndex(i)+&quot; &quot;);</span><br><span class="line">//标记该顶点已被遍历过</span><br><span class="line">visited[i] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(i);</span><br><span class="line">while(!queue.isEmpty()) &#123;</span><br><span class="line">//出队列</span><br><span class="line">int vertex = queue.poll();</span><br><span class="line">for(int j=vertex;j&lt;getNumVertex();j++) &#123;</span><br><span class="line">if(!visited[j] &amp;&amp; getWeight(vertex, j) != 0) &#123;</span><br><span class="line">visited[j] = true;</span><br><span class="line">System.out.print(getValueByIndex(j)+&quot; &quot;);</span><br><span class="line">queue.offer(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据权值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void broadFirstSearch(int i) &#123;</span><br><span class="line">boolean[] visited = new boolean[getNumVertex()];</span><br><span class="line">for(int j=0;j&lt;visited.length;j++) &#123;</span><br><span class="line">visited[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">BFS(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">private void BFS(int i, boolean[] visited) &#123;</span><br><span class="line">visited[i] = true;</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">//第一次访问的顶点</span><br><span class="line">System.out.print(getValueByIndex(i)+&quot; &quot;);</span><br><span class="line">//标记该顶点已被遍历过</span><br><span class="line">visited[i] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(i);</span><br><span class="line">while(!queue.isEmpty()) &#123;</span><br><span class="line">//出队列</span><br><span class="line">int vertex = queue.poll();</span><br><span class="line">//第一个邻接顶点</span><br><span class="line">int next = getFirshNeighbor(vertex);</span><br><span class="line">while(next != -1) &#123;//还有邻接顶点的时候</span><br><span class="line">if(!visited[next]) &#123;</span><br><span class="line">System.out.print(getValueByIndex(next)+&quot; &quot;);</span><br><span class="line">visited[next] = true;</span><br><span class="line">//入队列</span><br><span class="line">queue.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">//下一个邻接顶点</span><br><span class="line">next = getNextNeighbor(vertex, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>感觉根据权值来进行比较的话，比较次数会相对少一些，尤其稀疏的时候<br><img src="/2019/02/26/图的遍历/BFSVertexs.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索&quot;&gt;&lt;/a&gt;深度优先搜索&lt;/h1&gt;&lt;p&gt;Depth First Search.  与树的先序遍历类似。从某个顶点出发，依次向下访问&lt;br&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问初始顶点v，并标记顶点v已经被访问&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>代码习题</title>
    <link href="http://yoursite.com/2019/02/21/%E4%BB%A3%E7%A0%81%E4%B9%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/21/代码习题/</id>
    <published>2019-02-21T01:37:51.000Z</published>
    <updated>2019-03-04T11:08:45.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对链表进行重新排序"><a href="#1-对链表进行重新排序" class="headerlink" title="1.对链表进行重新排序"></a>1.对链表进行重新排序</h1><p>题目：给定链表 L0-L1-L2-…-Ln-1-Ln,把链表重新排序为L0-Ln-L1-Ln-1-L2-Ln-2-…<br>要求：  </p><ul><li>再原来链表的基础上进行排序，即不能申请新的结点</li><li>只能修改结点的next域，不能修改数据域。<a id="more"></a>思路：</li><li>找到链表的中间结点(暴力法或者快慢指针法)</li><li>将链表分成两个来链表</li><li>逆序后面的链表</li><li>依次循环，每次各去除两个链表的一个结点，直至next为空</li></ul><h1 id="2-求两个字符串的最长公共子串"><a href="#2-求两个字符串的最长公共子串" class="headerlink" title="2.求两个字符串的最长公共子串"></a>2.求两个字符串的最长公共子串</h1><ol><li>暴力求解<br>利用动态规划法，双重for循环。</li></ol><ul><li>初始化二维数组max[][]，赋值为0</li><li>双重循环两个字符串，如果字符串在某一位置相等,赋值max+1，</li><li>两个变量，max记录最长公共子串的长度，maxI记录最长公共子串最后一个字符的位置</li><li>最长公共子串的位置是从下标maxI-max开始，下标增加max位的字符</li><li>需要注意的是，比较的时候对max数组的赋值，因为循环是从1开始的</li></ul><p><img src="/2019/02/21/代码习题/maxSubStr.PNG" alt="">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str1 = &quot;GCCCTAGCG&quot;;</span><br><span class="line">String str2 = &quot;GCGCAATG&quot;;</span><br><span class="line">getMaxSubStr(str1, str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void getMaxSubStr(String str1, String str2) &#123;</span><br><span class="line">if(str1 == null || str2 == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int[][] m = new int[str1.length()+1][str2.length()+1];</span><br><span class="line">int max = 0;//最长公共子序列的长度</span><br><span class="line">int maxI = 0;//最长公共子序列的最后一个字符的位置</span><br><span class="line">for(int i=0;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">m[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;str1.length()+1;i++) &#123;</span><br><span class="line">for(int j=1;j&lt;str2.length()+1;j++) &#123;</span><br><span class="line">if(str1.charAt(i-1) == str2.charAt(j-1)) &#123;</span><br><span class="line">m[i][j] = m[i-1][j-1]+1;</span><br><span class="line">if(max&lt;m[i][j]) &#123;</span><br><span class="line">max = m[i][j];</span><br><span class="line">maxI = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str1.substring(maxI-max, maxI));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>滑动比较法</li></ol><ul><li>保持str1的位置不变，移动str2,比较重叠字符的公共子串</li><li>移动时，如果当前重叠子串的长度大于maxI,更新maxI<h1 id="3-求字符串的所有排序（未去重）"><a href="#3-求字符串的所有排序（未去重）" class="headerlink" title="3.求字符串的所有排序（未去重）"></a>3.求字符串的所有排序（未去重）</h1></li><li>第一步，第一个字符和后面所有字符，依次交换</li><li>第二步，固定第一个字符，对剩余的字符进行全排列（交换）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;</span><br><span class="line"></span><br><span class="line">public static void swap(char[] str, int start, int i) &#123;</span><br><span class="line">char tmp = str[start];</span><br><span class="line">str[start] = str[i];</span><br><span class="line">str[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">public static void Permutation(char[] str, int start) &#123;</span><br><span class="line">if(str.length == 0 || start&lt;0) &#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(start == str.length-1) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for(int i = start;i&lt;str.length;i++) &#123;</span><br><span class="line">swap(str,start,i);</span><br><span class="line">Permutation(str, start+1);</span><br><span class="line">swap(str,i,start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String string = &quot;abc&quot;;</span><br><span class="line">char[] str = string.toCharArray();</span><br><span class="line">Permutation(str, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-将多个有序的list集合组合成一个有序的集合"><a href="#4-将多个有序的list集合组合成一个有序的集合" class="headerlink" title="4. 将多个有序的list集合组合成一个有序的集合"></a>4. 将多个有序的list集合组合成一个有序的集合</h1><p>数美时代技术有限公司的一道面试题，25分，本人直接用了：<br>Collections.sort() emmmmmm直接扣掉了15分，当时太紧张了，脑子都是懵的，不过也是基础不扎实的缘故。 </p><p>思路：</p><ul><li>俩俩比较，但是总觉得会有更优的算法，要不然为何强调是有序的集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉是不是需要递归啊</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-对链表进行重新排序&quot;&gt;&lt;a href=&quot;#1-对链表进行重新排序&quot; class=&quot;headerlink&quot; title=&quot;1.对链表进行重新排序&quot;&gt;&lt;/a&gt;1.对链表进行重新排序&lt;/h1&gt;&lt;p&gt;题目：给定链表 L0-L1-L2-…-Ln-1-Ln,把链表重新排序为L0-Ln-L1-Ln-1-L2-Ln-2-…&lt;br&gt;要求：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;再原来链表的基础上进行排序，即不能申请新的结点&lt;/li&gt;
&lt;li&gt;只能修改结点的next域，不能修改数据域。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2019/02/19/%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/02/19/图/</id>
    <published>2019-02-19T10:40:15.000Z</published>
    <updated>2019-03-18T07:41:33.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>图(Graph)是由顶点的<em>有穷非空</em>集合和顶点之间边的集合组成。通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br><a id="more"></a><br>注意：</p><ul><li>数据元素，在线性表中叫元素，树中叫结点，图中称为顶点(Vertex)</li></ul><ol><li>无向边（Edge）<br>顶点Vi到Vj之间的边没有方向,用无序偶(Vi,Vj)来表示。</li><li>有向边<br>也称为弧(Arc),用有序偶&lt;Vi,Vj&gt;表示，Vi是弧尾，Vj是弧头</li><li>简单图<br>不存在顶点到其自身的边，且同一条边不重复出现。</li><li>无向完全图<br>在无向图中，任意两个顶点之间都存在边。含有n个项点的无向完全图有n*(n-1)/2条边。</li><li>有向完全图<br>在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。含有n个顶点的有向完全图有n*(n-1)条边。</li><li>稀疏图和稠密图<br>通常认为边或弧数小于n*logn的图为稀疏图。</li><li>权(Weight)<br>与图的边或弧相关的数</li><li>网(Network)<br>带权的图</li><li>度(Degree)<br>顶点和相关联的边的数目.TD(V) = ID(V)+OD(V)</li><li>入度(InDegree)<br>以顶点V为头的弧的数目称为V的入度，记为ID(V)</li><li>初读(OutDegree)<br>以V为尾的弧的数目称为V的出度，记为OD(V)  </li><li>回路或环(Cycle)<br>第一个顶点到最后一个顶点相同的路径<br>顶点不重复出现的是简单环</li><li>连通图<br>无向图中，每个顶点都相连，如果是有向图，称为强连通图</li><li>无向图中的极大连通子图称为连通分量</li></ol><ul><li>首先是子图，且子图是连通的</li><li>连通子图含有极大顶点数</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>是多对多的关系，树是一对多，链表是一对一  </p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>分为有向图邻接矩阵和无向图邻接矩阵</p><ol><li>无向图<br>用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息：0表示不存在，1表示存在。</li><li>有向图<br>与无向图一样，但无向图更浪费空间，因为无向图是对称矩阵</li><li>网<br>没有连线的两个顶点，用无穷∞表示</li></ol><ul><li>入度<br>该顶点所在列的和</li><li>出度<br>该顶点所在行的和</li></ul><ol start="4"><li>实现邻接矩阵<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Graph &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;Object&gt; point;//顶点信息</span><br><span class="line">private int[][] edge;//边信息，</span><br><span class="line">private int numEdge;//边的数目</span><br><span class="line">private int numVertex ;//顶点的数目</span><br><span class="line"></span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumVertex(int numVertex) &#123;</span><br><span class="line">this.numVertex = numVertex;</span><br><span class="line">&#125;</span><br><span class="line">public ArrayList&lt;Object&gt; getPoint() &#123;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">public void setPoint(ArrayList&lt;Object&gt; point) &#123;</span><br><span class="line">this.point = point;</span><br><span class="line">&#125;</span><br><span class="line">public int[][] getEdge() &#123;</span><br><span class="line">return edge;</span><br><span class="line">&#125;</span><br><span class="line">public void setEdge(int[][] edge) &#123;</span><br><span class="line">this.edge = edge;</span><br><span class="line">&#125;</span><br><span class="line">public int getNumEdge() &#123;</span><br><span class="line">return numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public void setNumEdge(int numEdge) &#123;</span><br><span class="line">this.numEdge = numEdge;</span><br><span class="line">&#125;</span><br><span class="line">public Graph(int n) &#123;</span><br><span class="line">this.point = new ArrayList&lt;&gt;(n);</span><br><span class="line">this.edge = new int[n][n];</span><br><span class="line">this.numEdge = 0;</span><br><span class="line">&#125;</span><br><span class="line">public Graph() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 建立无向图</span><br><span class="line"> */</span><br><span class="line">public static Graph buildGraph() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;一共多少个顶点&quot;);</span><br><span class="line">int numVertex  = scan.nextInt();</span><br><span class="line">System.out.println(&quot;一共多少条边&quot;);</span><br><span class="line">int numEdge = scan.nextInt();</span><br><span class="line">Graph g = new Graph();</span><br><span class="line">g.setNumEdge(numEdge);</span><br><span class="line">g.setNumVertex(numVertex);</span><br><span class="line">//读入顶点信息</span><br><span class="line">int vertex = numVertex;</span><br><span class="line">ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">scan.nextLine();</span><br><span class="line">while(vertex&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;请输入顶点&quot;);</span><br><span class="line">String s = scan.nextLine();</span><br><span class="line">list.add(s);</span><br><span class="line">vertex--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list.toString());</span><br><span class="line">g.setPoint(list);</span><br><span class="line">//初始化</span><br><span class="line">int[][] edge = new int[numVertex][numVertex];</span><br><span class="line">for(int i=0;i&lt;g.getNumVertex();i++) &#123;</span><br><span class="line">for(int j=0;j&lt;g.getNumVertex();j++) &#123;</span><br><span class="line">edge[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//加入到邻接矩阵中，1表示有边</span><br><span class="line">while(numEdge&gt;0) &#123;</span><br><span class="line">System.out.println(&quot;输入连接的两个顶点，用“#”隔开&quot;);</span><br><span class="line">String num = scan.nextLine();</span><br><span class="line">String[] nums = num.split(&quot;#&quot;);</span><br><span class="line">int indexOf0 = list.indexOf(nums[0]);</span><br><span class="line">int indexOf1 = list.indexOf(nums[1]);</span><br><span class="line">if(indexOf0&lt;0 || indexOf1&lt;0) &#123;</span><br><span class="line">System.out.println(&quot;顶点不存在，请重新输入！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edge[list.indexOf(nums[0])][list.indexOf(nums[1])] = 1;</span><br><span class="line">//因为是对称的</span><br><span class="line">edge[list.indexOf(nums[1])][list.indexOf(nums[0])] = 1;</span><br><span class="line">numEdge--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">g.setEdge(edge);</span><br><span class="line">//打印出来</span><br><span class="line">System.out.print(&quot; &quot;);</span><br><span class="line">for(Object li : list) &#123;</span><br><span class="line">System.out.print(li+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;numVertex;i++) &#123;</span><br><span class="line">System.out.print(list.get(i)+&quot; &quot;);</span><br><span class="line">for(int j=0;j&lt;numVertex;j++) &#123;</span><br><span class="line">System.out.print(edge[i][j]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">buildGraph();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果 </p><blockquote><p>一共多少个顶点<br>5<br>一共多少条边<br>5<br>请输入顶点<br>a<br>请输入顶点<br>b<br>请输入顶点<br>c<br>请输入顶点<br>d<br>请输入顶点<br>e<br>[a, b, c, d, e]<br>输入连接的两个顶点，用“#”隔开<br>a#b<br>输入连接的两个顶点，用“#”隔开<br>d#e<br>输入连接的两个顶点，用“#”隔开<br>c#b<br>输入连接的两个顶点，用“#”隔开<br>b#d<br>输入连接的两个顶点，用“#”隔开<br>d#a<br> a b c d e<br>a 0 1 0 1 0<br>b 1 0 1 1 0<br>c 0 1 0 0 0<br>d 1 1 0 0 1<br>e 0 0 0 1 0 </p></blockquote><hr><p>版本二：添加了权值，添加了增加和删除  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.synth.SynthSpinnerUI;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Graph;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接矩阵表示图</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphVertex &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;String&gt; vertexList;//用来存储顶点信息</span><br><span class="line">private int[][] edges;//邻接矩阵，存储顶点之间的边信息</span><br><span class="line">private int numEdges;//边的数目</span><br><span class="line">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> * @param n</span><br><span class="line"> */</span><br><span class="line">public GraphVertex(int n) &#123;</span><br><span class="line">vertexList = new ArrayList&lt;&gt;(n);</span><br><span class="line">edges = new int[n][n];</span><br><span class="line">numEdges = 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到结点个数</span><br><span class="line"> */</span><br><span class="line">public int getNumVertex() &#123;</span><br><span class="line">return vertexList.size();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @return 得到边数</span><br><span class="line"> */</span><br><span class="line">public int getNumEdges() &#123;</span><br><span class="line">return numEdges;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param i</span><br><span class="line"> * @return 返回第i个结点的信息</span><br><span class="line"> */</span><br><span class="line">public String getValueByIndex(int i) &#123;</span><br><span class="line">return vertexList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param v1  第一个顶点</span><br><span class="line"> * @param v2  第二个顶点</span><br><span class="line"> * @return 返回两个顶点之间的权值</span><br><span class="line"> */</span><br><span class="line">public int getWeight(int v1, int v2) &#123;</span><br><span class="line">return edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 插入结点到集合中</span><br><span class="line"> * @param vertex</span><br><span class="line"> */</span><br><span class="line">public void insertVertex(String vertex) &#123;</span><br><span class="line">if(vertexList.contains(vertex)) &#123;</span><br><span class="line">System.out.println(&quot;该顶点已存在！！！&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">vertexList.add(vertexList.size(), vertex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 邻接矩阵存储</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @param weight 权值</span><br><span class="line"> */</span><br><span class="line">public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">if(edges[v1][v2] != 0) &#123;//修改权值而不是新增的</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">numEdges++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 删除边</span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> */</span><br><span class="line">public void deleteEdge(int v1, int v2) &#123;</span><br><span class="line">if(edges[v1][v2] == 0) &#123;</span><br><span class="line">System.out.println(&quot;该边不存在！！！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">edges[v1][v2] = 0;</span><br><span class="line">numEdges--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param index</span><br><span class="line"> * @return 当前结点第一个邻接顶点下标</span><br><span class="line"> */</span><br><span class="line">public int getFirshNeighbor(int index) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[index][i]&gt;0) &#123;//行是相同的哟</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param v1</span><br><span class="line"> * @param v2</span><br><span class="line"> * @return 下一个邻接顶点</span><br><span class="line"> */</span><br><span class="line">public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">for(int i= v2+1; i&lt;vertexList.size();i++) &#123;</span><br><span class="line">if(edges[v1][i]&gt;0) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印邻接矩阵</span><br><span class="line"> */</span><br><span class="line">private void print() &#123;</span><br><span class="line">for(int i=0;i&lt;vertexList.size();i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">for(int i=0;i&lt;edges[0].length;i++) &#123;</span><br><span class="line">System.out.print(vertexList.get(i)+&quot; &quot;);</span><br><span class="line">for(int j=0;j&lt;edges[0].length;j++) &#123;</span><br><span class="line">System.out.print(edges[i][j]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int vertex = 4;</span><br><span class="line">int edge = 4;</span><br><span class="line">String[] v = &#123;&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v4&quot;&#125;;</span><br><span class="line">GraphVertex G = new GraphVertex(vertex);</span><br><span class="line">//插入顶点</span><br><span class="line">for (String string : v) &#123;</span><br><span class="line">G.insertVertex(string);</span><br><span class="line">&#125;</span><br><span class="line">//插入边</span><br><span class="line">G.insertEdge(0, 1, 2);</span><br><span class="line">G.insertEdge(0, 2, 5);</span><br><span class="line">G.insertEdge(2, 3, 8);</span><br><span class="line">G.insertEdge(3, 0, 7);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;结点个数&quot;+G.getNumVertex());</span><br><span class="line">System.out.println(&quot;边个数&quot;+G.getNumEdges());</span><br><span class="line">System.out.println(&quot;邻接矩阵&quot;);</span><br><span class="line">G.print();</span><br><span class="line">G.deleteEdge(0, 1);</span><br><span class="line">System.out.println(&quot;删除v1,v2之间的边&quot;);</span><br><span class="line">System.out.println(&quot;删除后顶点个数：&quot;+G.getNumEdges());</span><br><span class="line">System.out.println(&quot;删除后边个数：&quot;+G.getNumEdges());</span><br><span class="line">G.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>AdjacencyList<br>是链表和数组的结合(树也是链表和数组的结合哟)  </p><ol><li>处理方法  </li></ol><ul><li>图中顶点用一个一维数组存储（或者单链表），用一维数组是为了更快的读取顶点信息，更加方便。  </li><li>图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以用单链表存储。  </li></ul><p><em>邻接表关心出度，不关心入度</em><br>类似于树的孩子表示法</p><p><img src="/2019/02/19/图/list.PNG" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.graph;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.GenericArrayType;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的邻接表结构</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class GraphNode &#123;</span><br><span class="line">   //表对应链表的顶点</span><br><span class="line">private class ENode&#123;</span><br><span class="line">int index;//顶点位置</span><br><span class="line">ENode nextEdge;//下一条弧</span><br><span class="line">&#125;</span><br><span class="line">//表中顶点</span><br><span class="line">private class VNode&#123;</span><br><span class="line">String data;//顶点信息,就是说他叫什么名字</span><br><span class="line">ENode firstEdge;//指向该顶点的第一条弧</span><br><span class="line">&#125;</span><br><span class="line">private VNode[] vertexs;//顶点数组</span><br><span class="line">public void createGraph() &#123;</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入顶点个数&quot;);</span><br><span class="line">int numVertexs = scan.nextInt();</span><br><span class="line">System.out.println(&quot;请输入边数&quot;);</span><br><span class="line">int numEdges = scan.nextInt();</span><br><span class="line">scan.nextLine();</span><br><span class="line">//初始化顶点</span><br><span class="line">vertexs = new VNode[numVertexs];</span><br><span class="line">for(int i=0; i &lt; numVertexs; i++) &#123;</span><br><span class="line">System.out.println(&quot;请输入顶点&quot;);</span><br><span class="line">vertexs[i] = new VNode();</span><br><span class="line">vertexs[i].data = scan.nextLine();</span><br><span class="line">vertexs[i].firstEdge = null;//很重要的一步</span><br><span class="line">&#125;</span><br><span class="line">//初始化边</span><br><span class="line">for(int i=0; i &lt; numEdges; i++) &#123;</span><br><span class="line">System.out.println(&quot;请输入边的起始顶点和结束顶点&quot;);</span><br><span class="line">ENode e1 = new ENode();</span><br><span class="line">String start = scan.nextLine();</span><br><span class="line">String end = scan.nextLine();</span><br><span class="line">int startIndex = getPosition(start);</span><br><span class="line">int endIndex = getPosition(end);</span><br><span class="line">e1.index = endIndex;</span><br><span class="line">//将e1连接到endIndedx所在链表的末尾</span><br><span class="line">if(vertexs[startIndex].firstEdge == null) &#123;</span><br><span class="line">vertexs[startIndex].firstEdge = e1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//将e1结点连接到vertexs[startIndex].firstEdge的末尾</span><br><span class="line">VertexsLast(vertexs[startIndex].firstEdge, e1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line">private void VertexsLast(ENode firstEdge, ENode e1) &#123;</span><br><span class="line">ENode p = firstEdge;</span><br><span class="line">while(p.nextEdge != null) &#123;</span><br><span class="line">p = p.nextEdge;</span><br><span class="line">&#125;</span><br><span class="line">p.nextEdge = e1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 连接顶点的位置信息</span><br><span class="line"> * @param start</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int getPosition(String data) &#123;</span><br><span class="line">for(int i=0;i&lt;vertexs.length;i++) &#123;</span><br><span class="line">if(vertexs[i].data.equals(data)) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印矩阵的队列图,出队元素</span><br><span class="line"> */</span><br><span class="line">public void print() &#123;</span><br><span class="line">for(int i=0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">ENode node = vertexs[i].firstEdge;</span><br><span class="line">while(node != null) &#123;</span><br><span class="line">System.out.println(node.index+&quot;\t&quot;+vertexs[node.index].data);</span><br><span class="line">node = node.nextEdge;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">GraphNode g = new GraphNode();</span><br><span class="line">g.createGraph();</span><br><span class="line">g.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>邻接矩阵适用于顶点少，边数多的图，邻接表相反</p><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>把邻接表和逆邻接表结合起来。<br>结构为：tailVex   headVex    headLink   tailLink<br>Vex表示顶点，Link表示结点<br>常用！！！！！！！！</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>是对边的操作</p><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>由两个一维数组组成，一个存储顶点，一个存储边信息，这个边数组每个数据元素由一条边的起点下标，重点下标和全组成。<br><img src="/2019/02/19/图/1.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;图(Graph)是由顶点的&lt;em&gt;有穷非空&lt;/em&gt;集合和顶点之间边的集合组成。通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="http://yoursite.com/2019/02/17/%E6%A0%91%E4%B9%8B%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/17/树之哈夫曼树/</id>
    <published>2019-02-17T10:12:32.000Z</published>
    <updated>2019-02-17T14:41:50.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>也称赫夫曼树、最优二叉树，Huffman,是首个实用的压缩编码方案。<br>&#160;&#160;&#160;&#160;给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉为最优二叉树，也称为哈夫曼树。<br><a id="more"></a><br>&#160;&#160;&#160;&#160;哈夫曼树是带权路径最短的树，权值较大的结点离根较近。</p><ul><li>路径长度<br>从根节点到该节点的路径上的连接数</li><li>树的路径长度<br>树中每个叶子结点的路径长度之和</li><li>结点带权路径长度<br>结点的路径长度与结点权值的乘积</li><li>树的带权路径长度<br>WPL(Weighted Path Length)是树中所有叶子结点的带权路径长度之和，WPL越小，树的结构越优。<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1></li><li>定长编码<br>约定8位表示一个字符</li><li>变长编码<br>单个编码的长度不一致，可以根据整体出现频率来调节<br>-前缀码<br>没有任何码字是其他码字的前缀</li></ul><p>约定，左子树用0表示，右子树用1表示<br><strong><em>很很很重要</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;也称赫夫曼树、最优二叉树，Huffman,是首个实用的压缩编码方案。&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉为最优二叉树，也称为哈夫曼树。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树(Binary Tree)</title>
    <link href="http://yoursite.com/2019/02/17/%E6%A0%91%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/17/树之二叉树/</id>
    <published>2019-02-17T04:28:33.000Z</published>
    <updated>2019-03-23T03:26:35.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&#160;&#160;&#160;&#160;也叫 二分树、二元树、对分树等。是n(n&gt;=0)个结点的有限元素的集合,该集合或为空，或为由一个根元素以及两个互不相交的、被分别称为左子树和右子树的二叉树组成。当集合为空时，称该二叉树为空二叉树。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>子树不能大于2哟</li><li>左右子树是有顺序的哟</li><li>如果没有左子树，是允许有右子树的<a id="more"></a><h1 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h1></li></ul><ol><li>斜树<br><img src="/2019/02/17/树之二叉树/二叉树/1.PNG" alt=""></li><li>满二叉树<br>如果在一棵二叉树中，所有的分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上面。<br><img src="/2019/02/17/树之二叉树/二叉树/2.PNG" alt=""><br>结点数为2^n-1    ,n表示深度</li><li>完全二叉树<br>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下，从左至右的顺序进行编号。如果说编号为i(1&lt;=i &lt;=n )的结点与满二叉树中编号为i的结点在二叉树中的位置相同的话，则称为是完全二叉树<br><strong><em>满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树</em></strong><br><strong>特点：</strong><br>&#160;&#160;&#160;&#160;叶子结点只能出现在最后一层或者倒数第二层上<br>&#160;&#160;&#160;&#160;最下层叶子结点集中在树的左部（根据满二叉树的定义来的）<br>&#160;&#160;&#160;&#160;同样结点数的二叉树，完全二叉树的深度是最小的  </li><li>线索二叉树<br>n个结点的二叉链表中含有n+1个空指针域。利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前驱和后继结点的指针（附加的指针称为线索）   <h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2>一维数组存储结点，从上至下，从左至右，不存在的结点可以用-1表示<br>但是如果空结点过多（如斜树）h会造成大量的空间浪费，适用性不强，一般使用链式存储<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2>二叉链表</li></ol><ul><li>数据</li><li>左子树结点，右子树结点  </li></ul><p>结构为：左子树   数据  右子树<br><img src="/2019/02/17/树之二叉树/二叉树/3.PNG" alt=""> </p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><em>注意：</em><br>树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点棉面临着不同的选择。  </p><ul><li>前序遍历<br>根-左-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历<br>左-根-右</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历<br>左-右-根</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">print(root,level);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层次遍历  </li></ul><p>节点类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tree &#123;</span><br><span class="line">private Object data;</span><br><span class="line">private Tree lchild;</span><br><span class="line">private Tree rchild;</span><br><span class="line">public Object getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">public void setData(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getLchild() &#123;</span><br><span class="line">return lchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setLchild(Tree lchild) &#123;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree getRchild() &#123;</span><br><span class="line">return rchild;</span><br><span class="line">&#125;</span><br><span class="line">public void setRchild(Tree rchild) &#123;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data, Tree lchild, Tree rchild) &#123;</span><br><span class="line">super();</span><br><span class="line">this.data = data;</span><br><span class="line">this.lchild = lchild;</span><br><span class="line">this.rchild = rchild;</span><br><span class="line">&#125;</span><br><span class="line">public Tree() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line">public Tree(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package timejjc.com.tree;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import timejjc.com.entity.Tree;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 二叉树</span><br><span class="line"> * @author 梁翠翠</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BinaryTree &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Tree root = new Tree(0);</span><br><span class="line">Tree createTree = createTree(root);</span><br><span class="line">System.out.println(&quot;结点\t层次&quot;);</span><br><span class="line">traverse(createTree,1);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 遍历</span><br><span class="line"> * @param root</span><br><span class="line"> */</span><br><span class="line">private static void traverse(Tree root,int level) &#123;</span><br><span class="line">if(root != null) &#123;</span><br><span class="line">print(root,level);</span><br><span class="line">traverse(root.getLchild(), level+1);</span><br><span class="line">traverse(root.getRchild(), level+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private static void print(Tree root,int level) &#123;</span><br><span class="line">System.out.println(root.getData()+&quot;\t&quot;+level);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 建立二叉树</span><br><span class="line"> * @param root 树结点</span><br><span class="line"> * @param level  层次</span><br><span class="line"> */</span><br><span class="line">private static Tree createTree(Tree root) &#123;</span><br><span class="line"></span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String n = scan.nextLine();</span><br><span class="line">if(&quot;#&quot;.equals(n)) &#123;//叶子结点</span><br><span class="line">return null;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">root.setData(n);</span><br><span class="line">root.setLchild(createTree(new Tree(0)));</span><br><span class="line">root.setRchild(createTree(new Tree(0)));</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入 ：ABD##F##CE###<br>输出：<br>结点    层次<br>A       1<br>B       2<br>D       3<br>F       3<br>C       2<br>E       3</p><p>“#”表示他的双亲是叶子结点</p><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p><img src="/2019/02/17/树之二叉树/二叉树/4.PNG" alt=""><br>嘿嘿，不懂<br>😭</p><h1 id="树-森林、二叉树转换"><a href="#树-森林、二叉树转换" class="headerlink" title="树/森林、二叉树转换"></a>树/森林、二叉树转换</h1><p><img src="/2019/02/17/树之二叉树/二叉树/5.PNG" alt=""></p><h2 id="树到二叉树的转换"><a href="#树到二叉树的转换" class="headerlink" title="树到二叉树的转换"></a>树到二叉树的转换</h2><ul><li>每个兄弟结点连线</li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/6.PNG" alt=""></p><ul><li>去掉与孩子的连线（第一个长子除外）</li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/7.PNG" alt=""></p><ul><li>调整位置  </li></ul><p><img src="/2019/02/17/树之二叉树/二叉树/8.PNG" alt=""></p><h2 id="森林到二叉树的转换"><a href="#森林到二叉树的转换" class="headerlink" title="森林到二叉树的转换"></a>森林到二叉树的转换</h2><ul><li>将森林中的每棵树转为二叉树</li><li>将根一次连在一起</li><li>调整位置</li></ul><h2 id="二叉树到树、森林的转换"><a href="#二叉树到树、森林的转换" class="headerlink" title="二叉树到树、森林的转换"></a>二叉树到树、森林的转换</h2><ul><li>若结点x是其双亲y的左孩子，则把x的右孩子，有孩子的有孩子，，，，，，都与y用连线连起来</li><li>去除双亲所有右孩子的连线</li></ul><p><em>二叉树的根节点有右孩子就是森林，没有就是树</em></p><h1 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h1><h2 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h2><p>先访问树的根节点，然后再一次访问根的每棵子树</p><h2 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h2><p>先遍历树的每棵子树，再遍历根</p><p><img src="/2019/02/17/树之二叉树/二叉树/9.PNG" alt=""></p><p>嗒嗒嗒，森林的遍历，名词叫做前序遍历和后序遍历，其实就是按照树的先根遍历和后根遍历一次来访问森林的每一棵树。</p><p>树、森林的前根遍历和（转变后的）二叉树的前序遍历相同<br>后根遍历和（转变后的）二叉树的中序遍历相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;也叫 二分树、二元树、对分树等。是n(n&amp;gt;=0)个结点的有限元素的集合,该集合或为空，或为由一个根元素以及两个互不相交的、被分别称为左子树和右子树的二叉树组成。当集合为空时，称该二叉树为空二叉树。&lt;/p&gt;
&lt;h1 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;子树不能大于2哟&lt;/li&gt;
&lt;li&gt;左右子树是有顺序的哟&lt;/li&gt;
&lt;li&gt;如果没有左子树，是允许有右子树的&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>五个常见算法</title>
    <link href="http://yoursite.com/2019/02/15/%E4%BA%94%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/15/五个常见算法/</id>
    <published>2019-02-15T10:19:46.000Z</published>
    <updated>2019-02-25T01:22:27.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><ol><li>递归<br>&#160;&#160;&#160;&#160;直接或间接地调用自身的算法    </li><li>分治<br>&#160;&#160;&#160;&#160;将一个规模为n的，难以解决的问题分解为k个规模较小的子问题，<em>子问题相互独立</em>  </li></ol><p>将子问题递归解决，得到源问题的解  </p><ol start="3"><li>典型案例<br>Fibonacci数列，阶乘，Hanoi塔，二分法搜索，高速排序，合并排序<a id="more"></a><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Dynamis programming,是运筹学的一个分支，是求解决策过程最优化的数学方法。 </li><li>基本思想<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;类似分治法，将待求解问题分解成若干个子问题，先求解子问题，但是<em>子问题不是相互独立的</em>，避免大量的重复计算，每一次要用到前一问题的解   </li><li><p>分类<br>线性动态规划： 拦截导弹， 合唱队形， 挖地雷， 建学校， 剑客决斗<br>区域动态规划： 石子合并， 加分二叉树， 统计单词个数， 炮兵布阵<br>树形动态规划： 贪吃的九头龙， 二分查找树， 聚会的欢乐， 数字三角形。<br>背包动态规划： 01背包问题， 完全背包问题， 分组背包问题， 二维背包， 装箱问题， 挤牛奶， </p></li><li><p>实例<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最短路径问题， 项目管理， 网络流优化， 最长公共子序列，最大连续子序列和， 矩阵连乘， 凸多边形最优三角剖分， 电路布线。</p></li></ol><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><ol><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;对问题求解时，总是做出再当前看来最好的选择，也就是说，不从整体最优上加以考虑。<br>某个状态以前的过程不会影响以后的状态，只与当前状态有关。  </li><li>与动态规划的区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;贪心算法是自顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为规模更小的子问题，最后得到一个整体最优解。<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不能回退，动态规划可以</li><li>思路<br>建立数学模型来描述问题<br>把求解的问题分成若干个子问题<br>对每一子问题求解，得到子问题的局部最优解<br>八字问题的解局部最优解合成原问题的一个解  </li><li>案例<br>01背包问题， 马踏棋盘，最小生成树的Prim算法和Kruskal算法<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1></li><li>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;能进则进，不进则退  。类似枚举的搜索尝试过程，主要再搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就返回，尝试别的路径，<em>是一种选优搜索法</em><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;需要深度优先的方式搜索解空间 </li><li>案例<br>八皇后问题<h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1></li><li><p>定义<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生所有儿子结点，在儿子结点中，导致不可行解或者非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。再从活结点中取下一结点成为当前扩展结点。重复……<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;常以广度优先或以最小消耗优先的方式搜索问题的解空间树。</p></li><li><p>方法  </p></li></ol><ul><li>队列式(FIFO)分支限界法<br>按照队列原则选区下一个结点为扩展结点</li><li>优先队列式分支限界法<br>按优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。</li></ul><ol start="3"><li>与回溯法区别<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是求条件下的所有解，分支限界是一个解<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;回溯是深度优先，分支限界是广度优先   </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;递归和分治&quot;&gt;&lt;a href=&quot;#递归和分治&quot; class=&quot;headerlink&quot; title=&quot;递归和分治&quot;&gt;&lt;/a&gt;递归和分治&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;递归&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;直接或间接地调用自身的算法    &lt;/li&gt;
&lt;li&gt;分治&lt;br&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;将一个规模为n的，难以解决的问题分解为k个规模较小的子问题，&lt;em&gt;子问题相互独立&lt;/em&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将子问题递归解决，得到源问题的解  &lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;典型案例&lt;br&gt;Fibonacci数列，阶乘，Hanoi塔，二分法搜索，高速排序，合并排序&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>新年第一周</title>
    <link href="http://yoursite.com/2019/02/15/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>http://yoursite.com/2019/02/15/新年第一周/</id>
    <published>2019-02-15T01:59:53.000Z</published>
    <updated>2019-03-17T08:28:25.638Z</updated>
    
    <content type="html"><![CDATA[<p>作为新年的第一周，真的是，微笑中透露着疲惫</p><ul><li>周二给同学发了简历，然后挂了</li><li>数据结构真的不好复习</li><li>刷题真的伤时间</li><li>第一周13号线停了一周，我单程时间就变成了2小时</li><li>7：40出发，9：40到公司，心态已崩</li><li>新年愿望：<blockquote><p>换工作<br>顺利毕业<br>皮肤变好<br>瘦<br>如果可以，还有小哥哥</p></blockquote></li></ul><ul><li>最后一定要说：尹腾召是个大傻子，大猪蹄子，糟老头子</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为新年的第一周，真的是，微笑中透露着疲惫&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;周二给同学发了简历，然后挂了&lt;/li&gt;
&lt;li&gt;数据结构真的不好复习&lt;/li&gt;
&lt;li&gt;刷题真的伤时间&lt;/li&gt;
&lt;li&gt;第一周13号线停了一周，我单程时间就变成了2小时&lt;/li&gt;
&lt;li&gt;7：40出发，
      
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="http://yoursite.com/2019/02/14/leetcode/"/>
    <id>http://yoursite.com/2019/02/14/leetcode/</id>
    <published>2019-02-14T02:23:04.000Z</published>
    <updated>2019-04-05T11:27:33.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                if(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    arr[0] = i;</span><br><span class="line">                    arr[1] = j;</span><br><span class="line">                    return arr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间58ms，属于暴力解法了，击败24.62%的用户，太菜了  </p><ul><li>利用hashmap的动态分配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] arr = new int[2];</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++) &#123;</span><br><span class="line">       if(map.containsKey(target-nums[i])) &#123;</span><br><span class="line">       arr[0] = map.get(target-nums[i]);</span><br><span class="line">       arr[1] = i;</span><br><span class="line">       return arr;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">       map.put( nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间8ms,击败87.66%的用户</p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p></blockquote><blockquote><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p></blockquote><blockquote><p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode newNode = new ListNode(0);</span><br><span class="line">       ListNode cur = newNode;</span><br><span class="line">        int carry = 0;//进位</span><br><span class="line">        while(l1 !=null || l2 != null)&#123;</span><br><span class="line">            int val1 = (l1 != null)? l1.val : 0;</span><br><span class="line">            int val2 = (l2 != null)? l2.val : 0;</span><br><span class="line">            int num = carry+val1+val2;</span><br><span class="line">            carry = num/10;</span><br><span class="line">            //这里如果用cur.val = num%10;</span><br><span class="line">            //就需要cur.next = new ListNode(0);</span><br><span class="line">            //反正每次结点都需要new</span><br><span class="line">        cur.next = new ListNode(num%10);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">            if(l1 != null)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 != null)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry&gt;0)//最后如果还有进位</span><br><span class="line">            cur.next = new ListNode(carry);</span><br><span class="line">        return newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间68ms,击败19.44%的用户<br>算是最直接（笨）的写法了，看来还要优化  </p><h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><p>示例 1:  </p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:  </p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。  </p></blockquote><pre><code>请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">int result = 0;</span><br><span class="line">int length = s.length();</span><br><span class="line">int i=0,j=0;</span><br><span class="line">//也可以用指针</span><br><span class="line">while(i&lt;length &amp;&amp; j&lt;length) &#123;</span><br><span class="line">if(set.contains(s.charAt(j))) &#123;</span><br><span class="line">//删掉最先出现的那个重复的</span><br><span class="line">set.remove(s.charAt(i++));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">set.add(s.charAt(j++));</span><br><span class="line">//关键的一步</span><br><span class="line">result = Math.max(result, j-i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是官方示例，关键在于对result求最大值，我之前的算法总是不能概括所有情况，后续会更新这道题（链表的形式）</p><h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4.寻找两个有序数组的中位数"></a>4.寻找两个有序数组的中位数</h1><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0<br>示例 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">//1.需要合并两个数组,并排序</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;nums1.length;i++) &#123;</span><br><span class="line">list.add(nums1[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0; j&lt;nums2.length; j++) &#123;</span><br><span class="line">list.add(nums2[j]);</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, null);</span><br><span class="line">//2.分奇偶</span><br><span class="line">int length = list.size();</span><br><span class="line">if(length%2 != 0) &#123;</span><br><span class="line">int result = list.get(length/2);</span><br><span class="line">return (double)result;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return (double)(list.get(length/2)+list.get(length/2-1))/2;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行用时94ms，击败12.56%的用户<br>内存消耗50.8MB，击败30.27%的用户</p><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><p>第一：错误示范，字符串特别长是，超时,答案是对的，但是过于暴力，不符合时间要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> * @param s</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static String longestPalindrome(String s) &#123;</span><br><span class="line">//最暴力的方法：1找出所有子串</span><br><span class="line">List&lt;String&gt; list = substringAll(s);</span><br><span class="line">//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line">String result = &quot;&quot;;</span><br><span class="line">if(s.length() == 0) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">if(s.length()&gt;0) &#123;</span><br><span class="line">result = s.substring(0, 1);</span><br><span class="line">&#125;</span><br><span class="line">while(list.size()&gt;0)&#123;</span><br><span class="line">String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">String tmp = list.get(0);</span><br><span class="line">for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(list.size()&gt;0 &amp;&amp; list.get(0).equals(tmp)) &#123;</span><br><span class="line">if( list.get(0).length()&gt;result.length()) &#123;</span><br><span class="line">result = list.get(0);</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">String str = s.substring(i, j);</span><br><span class="line">if(str.length()&gt;1  ) &#123;</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">String str = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">System.out.println(longestPalindrome(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二：稍微改进了一点，但是还是超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //最暴力的方法：1找出所有子串</span><br><span class="line">if(s.length() == 0) &#123;</span><br><span class="line">return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String result = &quot;&quot;;</span><br><span class="line">if(s.length()&gt;0) &#123;</span><br><span class="line">result = s.substring(0, 1);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; list = substringAll(s);</span><br><span class="line">//依次判断是否回文，如果回文，记录该子串和长度，下一个回文如果较长，覆盖</span><br><span class="line"></span><br><span class="line">while(list.size()&gt;0)&#123;</span><br><span class="line">/*String[] sub = list.get(0).split(&quot;&quot;);</span><br><span class="line">String tmp = list.get(0);</span><br><span class="line">for(int j=0,k = sub.length-1;j&lt;k;j++,k--) &#123;</span><br><span class="line">if(!sub[j].equals(sub[k])) &#123;</span><br><span class="line">list.remove(0);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;*/</span><br><span class="line">if( list.get(0).length()&gt;result.length()) </span><br><span class="line">result = list.get(0);</span><br><span class="line">list.remove(0);</span><br><span class="line">&#125;</span><br><span class="line">//最后输出最长回文串，否则随便输出一个字符</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">public static List&lt;String&gt; substringAll(String s)&#123;</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">for(int j=i+1; j&lt;s.length()+1;j++) &#123;</span><br><span class="line">String str = s.substring(i, j);</span><br><span class="line">//是回文</span><br><span class="line">if(str.length()&gt;1 &amp;&amp; new StringBuffer(str).reverse().toString().equals(str)) &#123;</span><br><span class="line">if(list.size()== 0 || !list.get(list.size()-1).contains(str))</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行用时10578ms，击败了0.98%的用户<br>内存消耗380MB，击败了0.97%得用户—-真可怕</p><h1 id="6-Z-N-字形变换"><a href="#6-Z-N-字形变换" class="headerlink" title="6. Z(N)字形变换"></a>6. Z(N)字形变换</h1><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p></blockquote><blockquote><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L&#160;&#160;&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I   &#160;&#160;&#160;&#160;&#160;R<br>E &#160;T &#160;O&#160;&#160;E&#160;&#160;S&#160;&#160;&#160;I&#160;&#160;  I&#160;&#160;&#160;&#160;G<br>E&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;H   &#160;&#160;&#160;&#160;&#160;N          </p></blockquote><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><blockquote><p>string convert(string s, int numRows);  </p></blockquote><p>示例 1:</p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”  </p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;R<br>E&#160;&#160;&#160;&#160;&#160;&#160;&#160;O&#160;&#160;&#160;E&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;I<br>E&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;I&#160;&#160;&#160;&#160;&#160;&#160;H&#160;&#160;&#160;&#160;&#160;&#160;N<br>T&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;G</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 7.整数反转 #</span><br><span class="line">给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> 示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure><p>class Solution {<br>    public int reverse(int x) {<br>        int rev = 0;<br>            while (x != 0) {<br>                int pop = x % 10;<br>                x /= 10;<br>                if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return 0;<br>                if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return 0;<br>                rev = rev * 10 + pop;<br>            }<br>            return rev;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">执行用时43ms,击败了64.62%的用户  </span><br><span class="line">内存消耗32.6MB,击败了43.26%的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 8.字符串转换整数 #</span><br><span class="line">这道题怎么说，我完全就是暴力求解，然后，，，，限制条件太多， 我提交了8次才对！  </span><br><span class="line"></span><br><span class="line">请你来实现一个 atoi 函数，使其能将字符串转换成整数。  </span><br><span class="line"></span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。  </span><br><span class="line"></span><br><span class="line">当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。  </span><br><span class="line"></span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。  </span><br><span class="line"></span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。  </span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。  </span><br><span class="line"></span><br><span class="line">说明：  </span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。  </span><br><span class="line"></span><br><span class="line">示例 1:  </span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;42&quot;  </span><br><span class="line">输出: 42 </span><br><span class="line"> </span><br><span class="line">示例 2:  </span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;   -42&quot;  </span><br><span class="line">输出: -42  </span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。  </span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。  </span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;4193 with words&quot;  </span><br><span class="line">输出: 4193  </span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。  </span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;words and 987&quot;  </span><br><span class="line">输出: 0  </span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。  </span><br><span class="line">     因此无法执行有效的转换。  </span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;-91283472332&quot;  </span><br><span class="line">输出: -2147483648  </span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。   </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></p><p> public static  int myAtoi(String str) {<br>         String trim = str.trim();<br>         if(str.length() == 0 || trim.length() == 0) {<br>             return 0;<br>         }<br>         int indexOf = trim.indexOf(“ “);<br>         Integer result = 0;<br>         if(indexOf != -1) {//存在空格<br>             result= getNumber(trim, indexOf);<br>         } else {<br>             result = getNumber(trim, trim.length());<br>         }<br>         return result;<br>     }<br>     private static int getNumber(String trim, int indexOf) {<br>         StringBuffer buffer = new StringBuffer();<br>         int sign = 1;<br>         boolean  flag = false; //判断是否有符号<br>         if(trim.charAt(0) == ‘-‘ ){<br>             sign = -1;<br>             flag = false;<br>         } else if(trim.charAt(0) == ‘+’ ) {<br>             sign = 1;<br>             flag = true;<br>         } else if(trim.charAt(0)&gt;=’0’ &amp;&amp; trim.charAt(0)&lt;=’9’) {<br>             if(trim.charAt(0)&gt;’0’ &amp;&amp; trim.charAt(0)&lt;=’9’) {<br>                 buffer.append(trim.charAt(0));<br>                 flag = true;<br>             }</p><pre><code>     }else {         return 0;     }     char[] charArray = trim.toCharArray();     for(int i=1;i&lt; charArray.length;i++) {         if(charArray[i]&gt;=&apos;0&apos; &amp;&amp; charArray[i]&lt;=&apos;9&apos;) {             if(charArray[i] == &apos;0&apos;) {                 if(buffer.length()&gt;0 &amp;&amp; buffer.charAt(0)&gt;&apos;0&apos;) {                     buffer.append(charArray[i]);                 }             }else {                 buffer.append(charArray[i]);             }         }else {             break;         }     }     if(buffer.length()&gt;10) {         if(flag) {             return Integer.MAX_VALUE;         }else {             return Integer.MIN_VALUE;         }     }     if(buffer.length() == 0) {         return 0;     }     if(buffer.length() == 10) {        String str = new String(buffer);        Integer consult = Integer.valueOf(str.substring(0, 9));        Integer residue = Integer.valueOf(str.substring(9, 10));        System.out.println(consult);        System.out.println(residue);         if(consult&gt;Integer.MAX_VALUE/10) {             if(flag) {                 return Integer.MAX_VALUE;             } else {                 return Integer.MIN_VALUE;             }         }else if(consult == Integer.MAX_VALUE/10) {             if(residue &lt;= Integer.MAX_VALUE%10) {                 System.out.println(Integer.valueOf(new String(buffer))*sign);                 return Integer.valueOf(new String(buffer))*sign;             } else {                 if(flag) {                     return Integer.MAX_VALUE;                 } else {                     return Integer.MIN_VALUE;                 }             }         } else {             return Integer.valueOf(new String(buffer))*sign;         }     }    return Integer.valueOf(new String(buffer))*sign;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">执行用时 50ms,击败了40.37%的用户  </span><br><span class="line">内存消耗47.9MB  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 9. 回文数 #</span><br><span class="line">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p> public boolean isPalindrome(int x) {<br>        if(x&lt;0)<br>            return false;<br>        boolean rlt = false;<br>        int rev = 0;<br>        int n = x;<br>        while (n != 0) {<br>            int pop = n % 10;<br>            n /= 10;<br>            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return false;<br>            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -Integer.MAX_VALUE % 10)) return false;<br>            rev = rev * 10 + pop;<br>        }<br>        if(rev == x)<br>            rlt = true;<br>        return rlt;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时146ms，击败了81.29%的用户  </span><br><span class="line">内存消耗：30.3MB，击败了63.98%的用户  </span><br><span class="line"></span><br><span class="line">emmmmm,最快的一次了</span><br><span class="line"></span><br><span class="line"># 11.盛最多水的容器 #</span><br><span class="line"></span><br><span class="line">&gt;给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">&gt;说明：你不能倾斜容器，且 n 的值至少为 2。</span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [1,8,6,2,5,4,8,3,7]  </span><br><span class="line">输出: 49</span><br><span class="line"></span><br><span class="line">暴力解</span><br></pre></td></tr></table></figure></p><p>public int maxArea(int[] height) {<br>        int max = 0;<br>        for(int i=0;i&lt;height.length;i++) {<br>            for(int j=i+1;j&lt;height.length;j++) {</p><pre><code>            int num = Math.min(height[i], height[j])*(j-i);            max = max&lt;num ? num:max;        }    }     return max;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时402ms,击败了22.18%的用户  </span><br><span class="line">内存消耗47.8MB，击败了0.96%的用户</span><br><span class="line"></span><br><span class="line">方法二：双指针法（官方题解）  </span><br><span class="line">思想：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;两线段之间形成的区域总是会受到其中较短那条长度的限制，此外，线段距离越远，得到的面积越大   </span><br><span class="line">分析：</span><br><span class="line">- 两个指针，一个指向头， 一个指向尾  </span><br><span class="line">- 每一步中，比较max，且较短线段的指针向较长线段指针的一侧移动。</span><br></pre></td></tr></table></figure><p> public int maxArea(int[] height) {<br>       int max = 0;<br>        int i=0;<br>        int j = height.length-1;<br>        while(i&lt;j) {<br>            max = Math.max(max, Math.min(height[i], height[j])*(j-i));<br>            if(height[i]&gt;height[j]) {<br>                j–;<br>            } else {<br>                i++;<br>            }<br>        }<br>         return max;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">执行用时：10ms,击败了64.19%的用户  </span><br><span class="line">内存消耗47.1MB,击败了0.96%的用户 </span><br><span class="line"></span><br><span class="line"># 13.罗马数字转整数 #</span><br><span class="line">问题</span><br><span class="line">&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。  </span><br><span class="line">字符          数值  </span><br><span class="line">I             1  </span><br><span class="line">V             5  </span><br><span class="line">X             10  </span><br><span class="line">L             50  </span><br><span class="line">C             100  </span><br><span class="line">D             500  </span><br><span class="line">M             1000  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">&gt;   通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。  </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。   </span><br><span class="line">&amp;#160;&amp;#160;&amp;#160;&amp;#160;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。  </span><br><span class="line"></span><br><span class="line">给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。  </span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">输入: &quot;III&quot;  </span><br><span class="line">输出: 3  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:  </span><br><span class="line">输入: &quot;IV&quot;  </span><br><span class="line">输出: 4  </span><br><span class="line"></span><br><span class="line">&gt;示例 3:  </span><br><span class="line">输入: &quot;IX&quot;  </span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><pre><code>public static int romanToInt(String s) {    int num = 0;    for(int i=0;i&lt;s.length();i++) {        char charAt = s.charAt(i);        switch(charAt) {        case &apos;I&apos;:    num += 1;    break;        case &apos;V&apos;:    num += 5;    break;        case &apos;X&apos;:    num += 10;    break;        case &apos;L&apos;:   num += 50;    break;        case &apos;C&apos;:    num += 100;    break;        case &apos;D&apos;:    num += 500;    break;        case &apos;M&apos;:    num += 1000;    break;        default:    break;        }        //六种特殊情况        if(i != 0) {            if(( s.charAt(i) == &apos;V&apos; || s.charAt(i) == &apos;X&apos;) &amp;&amp;s.charAt(i-1) == &apos;I&apos; ) {                num -= 1*2; //*2是因为（i-1）的值之前加了一遍            }            if(( s.charAt(i) == &apos;L&apos; || s.charAt(i) == &apos;C&apos;) &amp;&amp;s.charAt(i-1) == &apos;X&apos; ) {                num -= 10*2;            }            if(( s.charAt(i) == &apos;D&apos; || s.charAt(i) == &apos;M&apos;) &amp;&amp;s.charAt(i-1) == &apos;C&apos; ) {                num -= 100*2;            }        }    }    return num;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">过于暴力啊  </span><br><span class="line">执行用时：108ms,击败了46.6%的用户  </span><br><span class="line">内存消耗：66MB,击败了0.95%的用户  </span><br><span class="line"></span><br><span class="line"># 14.最长公共前缀 #</span><br><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]  </span><br><span class="line">输出: &quot;fl&quot;  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:</span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]  </span><br><span class="line">输出: &quot;&quot;  </span><br><span class="line">解释: 输入不存在公共前缀。  </span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br><span class="line"></span><br><span class="line">方法1-横向扫描，依次对比每一个字符串</span><br></pre></td></tr></table></figure><p>if(strs == null || strs.length == 0) {<br>            return “”;<br>        }<br>        String str = strs[0];<br>        for(int i=1;i&lt;strs.length;i++) {<br>            while(strs[i].indexOf(str) != 0) {<br>                //indexOf对于数组，相同为0，不同为-1<br>                str = str.substring(0, str.length()-1);<br>                if(str.isEmpty()) {<br>                    return “”;<br>                }<br>            }<br>        }<br>        return str;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时10ms,击败了65.5%的用户  </span><br><span class="line">内存消耗38.7MB,击败了1.37%的用户  </span><br><span class="line">方法2- 二分查找法</span><br><span class="line">思想：如果（1-mid）不是所有串的公共前缀，舍弃后半个区间  </span><br><span class="line">否则，再次分割，进行查找</span><br></pre></td></tr></table></figure></p><p>public static String longestCommonPrefix(String[] strs) {<br>        if(strs == null || strs.length == 0) {<br>            return “”;<br>        }<br>        //找出最短的那个串<br>        int minLen = Integer.MAX_VALUE;<br>        for (String string : strs) {<br>            minLen = Math.min(minLen, string.length());<br>        }<br>        int low = 1;<br>        int hight = minLen;<br>        while(low&lt;= hight) {<br>            int middle = (low+hight)/2;<br>            if(isLongStr(strs,middle)){<br>                low = middle +1;<br>            }else {<br>                hight = middle-1;<br>            }<br>        }<br>        return strs[0].substring(0, (low+hight)/2);<br>    }</p><pre><code>private static boolean isLongStr(String[] strs, int middle) {    String str1 = strs[0].substring(0, middle);    for(int i=1;i&lt;strs.length;i++) {        if(!strs[i].startsWith(str1)) {            return false;        }    }    return true;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时10ms,击败了65.5%的用户  </span><br><span class="line">内存消耗40.5MB，击败了1.02%的用户  </span><br><span class="line">时间复杂度为O(s*log(n)),s表示字符中字符数量总数，n表示长度为m的相同的字符串</span><br><span class="line"></span><br><span class="line"># 20.有效的括号 #</span><br><span class="line"></span><br><span class="line">给定一个只包括 &apos;(&apos;，&apos;)&apos;，&apos;&#123;&apos;，&apos;&#125;&apos;，&apos;[&apos;，&apos;]&apos; 的字符串，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：  </span><br><span class="line"></span><br><span class="line">左括号必须用相同类型的右括号闭合。  </span><br><span class="line">左括号必须以正确的顺序闭合。  </span><br><span class="line">注意空字符串可被认为是有效字符串。  </span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;()&quot;  </span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;输入: &quot;([)]&quot;  </span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>public static  boolean isValid(String s) {<br>        Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;();<br>        map.put(‘)’, ‘(‘);<br>        map.put(‘]’, ‘[‘);<br>        map.put(‘}’, ‘{‘);<br>        if(s == “”) {<br>            return true;<br>        }<br>       Stack<character> stack = new Stack<character>();<br>       for(int i=0;i&lt;s.length();i++) {<br>           // 如果遇到闭括号<br>           if(map.containsKey(s.charAt(i))) {<br>               char ch = stack.isEmpty()?’#’: stack.pop();<br>                //ch和值不相等，说明开括号和闭括号是不匹配的<br>                 if(ch != map.get(s.charAt(i))) {<br>                   return false;<br>               }<br>           }else {<br>               stack.push(s.charAt(i));<br>           }<br>       }</character></character></p><pre><code>   return stack.isEmpty();}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行用时：14ms,击败了23.95%的用户  </span><br><span class="line">内存消耗：35.7MB，击败了2.27%的用户  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 21.合并两个有序链表 #</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span><br><span class="line"></span><br><span class="line">&gt;示例：  </span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4  </span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Definition for singly-linked list.</li><li>public class ListNode {</li><li>int val;</li><li>ListNode next;</li><li>ListNode(int x) { val = x; }</li><li><p>}<br>*/<br>class Solution {<br> public ListNode mergeTwoLists(ListNode l1, ListNode l2) {</p><pre><code>ListNode newNode = new ListNode(0);ListNode cur = newNode;while(l1 != null &amp;&amp; l2 != null) {    if(l1.val&lt;l2.val) {        cur.next = l1;        cur = cur.next;        l1 = l1.next;    }else {        cur.next = l2;        cur = cur.next;        l2 = l2.next;    }</code></pre></li></ul><pre><code>    }    if(l1 == null ) {        cur.next = l2;    }    if(l2 == null) {        cur.next = l1;    }    return newNode.next;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">执行用时16ms，击败了59.56%的用户</span><br><span class="line">内存消耗42.9MB,击败了0.97%的用户 </span><br><span class="line"></span><br><span class="line"># 26.删除排序数组中的重复项 #</span><br><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。  </span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;给定数组 nums = [1,1,2],  </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [0,0,1,1,1,2,2,3,3,4],  </span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">思路：在看到这道题的时候，首先根据题目意思：有序   </span><br><span class="line">意味着，是递增或者递减的，而且因为是引用，那么删除之后的数组也是有序的</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        if(nums.length&lt;=1){<br>            return nums.length;<br>        }<br>        int count = 0;<br>        for(int i=0;i&lt;nums.length-1;) {<br>             while(nums[i] == nums[i+1] &amp;&amp; i&lt;(nums.length-count-1)) {<br>                 for(int j=i;j&lt;nums.length-1;j++) {<br>                     nums[j] = nums[j+1];<br>                 }<br>                 count++;<br>                 if(nums[i] != nums[i+1]) {<br>                     i = i+1;<br>                 }</p><pre><code>         }         if(nums[i] == nums[nums.length-1]) {             break;         }else if(nums[i] != nums[i+1]) {             i++;         }     }     return (nums.length-count);}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不知道是不是几天没碰代码，这道题写的过于暴力：  </span><br><span class="line">执行用时114ms,击败了6.88%的提交记录，  </span><br><span class="line">内存消耗47MB   </span><br><span class="line">估计是这道题最笨的一种解法了</span><br><span class="line"></span><br><span class="line">然后看了一下官方实例，真的是，巧妙了：</span><br></pre></td></tr></table></figure></p><p>public int removeDuplicates(int[] nums) {<br>    if (nums.length == 0) return 0;<br>    int i = 0;<br>    for (int j = 1; j &lt; nums.length; j++) {<br>        if (nums[j] != nums[i]) {<br>            i++;<br>            nums[i] = nums[j];<br>        }<br>    }<br>    return i + 1;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">利用了快慢指针的思想,i是慢指针，j是快指针，只要nums[i] == nums[j]就利用j++来跳过重复项</span><br><span class="line"># 27.移除元素 #</span><br><span class="line"></span><br><span class="line">给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。  </span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。  </span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">&gt;示例 1:  </span><br><span class="line">给定 nums = [3,2,2,3], val = 3,  </span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。  </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">&gt;示例 2:  </span><br><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,  </span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。  </span><br><span class="line">注意这五个元素可为任意顺序。  </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。  </span><br><span class="line"></span><br><span class="line">说明:  </span><br><span class="line"></span><br><span class="line">为什么返回数值是整数，但输出的答案是数组呢?  </span><br><span class="line"></span><br><span class="line">请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。  </span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:  </span><br><span class="line"></span><br><span class="line">&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝  </span><br><span class="line">int len = removeElement(nums, val);  </span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。  </span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。  </span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;  </span><br><span class="line">    print(nums[i]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>public static int removeElement(int[] nums, int val) {<br>        int i=0;<br>        int j=nums.length-1;<br>        int len = 0;<br>        while(i&lt;=j) {<br>            if(nums[i] == val) {<br>                int tmp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = tmp;<br>                j–;<br>            }else {<br>                i++;<br>                ++len;<br>            }<br>        }<br>        return len;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时：9ms,击败了69.33%的用户  </span><br><span class="line">内存消耗：69.6MB,击败了0.97%的用户  </span><br><span class="line"># 42.接雨水 #</span><br><span class="line"></span><br><span class="line">是一道难题，思路难，以下是百度的答案 (思路是百度给的，但是没有看答案哟)</span><br><span class="line">&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line">![](leetcode/接雨水.PNG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]  </span><br><span class="line">输出: 6  </span><br><span class="line">分析：</span><br><span class="line">如果想接到雨水，需要满足的条件是</span><br><span class="line">- height[i-1]&gt;height[i]</span><br><span class="line">- height[i]&lt;height[i+1]  </span><br><span class="line"></span><br><span class="line">假设已知最高点的坐标macIndex及其高度maxValue,考虑从左逐渐靠近最高点，此时，只需考虑第一个条件，因为始终有height[maxIndex]&gt;height[i]   </span><br><span class="line">*局部最高curRoot*</span><br><span class="line">局部最高与其余高度值得差值和即为积水和。  </span><br><span class="line">例如上例；积水和分别为:</span><br><span class="line">&gt;左侧：[0,1,1,2,2,2,2]（左往右）,那么左侧积水和为1+1+2+1 = 5</span><br><span class="line">&gt;右侧:[2,2,2,1]（右往左）,那么左侧积水和为1+1</span><br><span class="line">积水和为：5+1 = 6    </span><br><span class="line">  </span><br><span class="line">方法：</span><br><span class="line">- 遍历整个数组，找最高点  </span><br><span class="line">- 从左向右遍历至最高点坐标，求积水和</span><br><span class="line">- 从右向左遍历至最高点坐标，求积水和</span><br></pre></td></tr></table></figure></p><p> /**</p><pre><code>  * 接雨水  * @param height  * @return  */ public static int trap(int[] height) {     if(height == null || height.length == 0) {         return 0;     }    int max = 0;    int maxIndex = 0;   //遍历数组找到最高点    for(int i=0;i&lt;height.length;i++) {        if(height[i]&gt;max) {            maxIndex = i;            max = height[i];        }    }    int left = 0,right = 0;    //从左向右遍历至最高点，返回积水和    if(maxIndex&gt;0) {        left = countWaterLeft(0, maxIndex, height);    }    //从右向左遍历至最高点，返回积水和    if(maxIndex&lt;height.length-1) {        right = countWaterRight(maxIndex, height.length-1, height);    }    max = left+right;    return max;  }public static int countWaterRight(int maxIndex, int length, int[] height) {    int res = 0;    int[] result = new int[length - maxIndex];    int j=result.length-2;    //height: 0,1,0,2,1,0,1,3,2,1,2,1     //result:               [2,2,2,1]    result[result.length-1] = height[length];    for(int i=length-1;i&gt;maxIndex;i--) {        result[j] = Math.max(result[j+1], height[i]);        res += Math.abs((result[j]-height[i]));        j--;    }    return res;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行用时24ms,击败了43.90%的用户  </span><br><span class="line">内存消耗453.MB，击败了0.94%的用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">来一份网友答案：：</span><br></pre></td></tr></table></figure><p>找到三个值，第一是头值，第二是尾值，第三是除去头和尾之外，中间的最大值，如果中间的最大值小于头和尾的最小值，那么直接就可以计算出结果，如大于等于最大值（其实等于也可以直接处理，避免下一次递归，但是我为了懒省事没写。。。），则从中间把它们一分为二，再分别求值加到一起。运行时间11ms,超越100%。<br>class Solution {<br>    public int trap(int[] height) {<br>        if(height.length&lt;3){<br>            return 0;<br>        }<br>        return find(height,0,height.length-1);<br>    }<br>    public int find(int[] height,int start,int end){<br>        if(end-start&lt;2){//递归的终点<br>            return 0;<br>        }<br>        int max=-1,tmp=-1,min_two=Math.min(height[start],height[end]),sum=0;;<br>        for(int i=start+1;i&lt;end;i++){<br>            //这一句写在哪里都行<br>            sum=sum+(min_two-height[i]);<br>            if(height[i]&gt;max){<br>                max=height[i];<br>                tmp=i;<br>            }<br>        }</p><pre><code>    if(max&lt;min_two){//上面的加法其实应该在这里，转移到上面和在这里其实都一样        //sum=sum+(min_two-height[i]);        return sum;    }else{//其实这里还可以优化一下当中间的max值等于start或者end的时候，当它等于start,那么直接计算即可，不用进行下一次递归，因为下一次递归会再扫描一遍        return find(height,start,tmp)+find(height,tmp,end);    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 80.删除排序数组中的重复项II #</span><br><span class="line"></span><br><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [1,1,1,2,2,3],  </span><br><span class="line">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">&gt;给定 nums = [0,0,1,1,1,1,2,3,3],  </span><br><span class="line">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        if(nums.length == 0)<br>            return 0;<br>        int i = 0;<br>         int j = 1;<br>         for(j=1;j&lt;nums.length;j++) {<br>             if(nums[i] != nums[j] ) {<br>                 i++;<br>                 if((j-i)&gt;=1) {<br>                     nums[i+1] = nums[j];<br>                 }</p><pre><code>         }     }    return i+2;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在做完第26题之后趁热打铁，哈哈哈哈   </span><br><span class="line">执行用时2ms,击败了91.59%的用户  </span><br><span class="line">执行用时38.4MB,击败了0.89%的用户    </span><br><span class="line"></span><br><span class="line">但是看了大神的，啊啊啊，难受：</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public int removeDuplicates(int[] nums) {<br>        int i = 0;<br>        for (int n : nums)<br>            if (i &lt; 2 || n &gt; nums[i-2])<br>                nums[i++] = n;<br>        return i;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 88.合并两个有序数组 #</span><br><span class="line">给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</span><br><span class="line"></span><br><span class="line">&gt;说明:  </span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n。  </span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;示例:  </span><br><span class="line">输入:  </span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3  </span><br><span class="line">nums2 = [2,5,6],       n = 3  </span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 102.二叉树的层次遍历 #</span><br><span class="line">要求，使用迭代的方法  </span><br><span class="line">利用队列先进先出的特点，每次入队一层，出队，再进行下一层</span><br></pre></td></tr></table></figure><p>class Solution{<br>    public List&lt;List<integer>&gt; levelOrder(TreeNode root){<br>        List&lt;List<integer>&gt; rlt = new ArrayList&lt;List<integer>&gt;();<br>        if(root != null){<br>            return rlt;<br>        }<br>        Queue<treenode> queue = new LinkedList<treenode>();<br>        queue.offer(root);<br>        while(!quque.isEmpty()){<br>            List<integer> list = new ArrayList<integer>();<br>            int count = queue.size();<br>            while(count&gt;0){<br>                TreeNode node = queue.poll();<br>                list.add(node.val);<br>                if(node.left != null){<br>                    queue.offer(node.left);<br>                }<br>                if(node.right != null){<br>                    queue.offer(node.right);<br>                }<br>            }<br>            rlt.add(list);<br>        }<br>        return rlt;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行用时2ms,击败了68.09%的用户  </span><br><span class="line">内存消耗35.8MB,击败了0.84%的用户</span><br><span class="line"></span><br><span class="line"># 144.二叉树的前序遍历 #</span><br><span class="line">注意，这里因为前序遍历的时候是：根-左-右  </span><br><span class="line">所以遍历的时候，是先右后左</span><br></pre></td></tr></table></figure></integer></integer></treenode></treenode></integer></integer></integer></p><p>class Solution{<br>    public List<integer> preorderTraversal(TreeNode root){<br>    List<integer> list = new ArrayList<integer>();<br>    if(root == null)<br>        return list;<br>    }<br>    Stack<treenode> stack = new Stack<treenode>();<br>    stack.push(root);<br>    while(!stack.isEmpty()){<br>        TreeNode node = stack.pop();<br>        list.add(node.val);<br>        if(node.right != null){<br>            stack.push(node.right);<br>        }<br>        if(node.left != null){<br>            stack.push(node.left);<br>        }<br>    }<br>    return list;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行用时1ms,击败了86.31%的用户  </span><br><span class="line">内存消耗33.5MB,击败了0.75%的用户  </span><br><span class="line"># 136.只出现一次的数字#</span><br><span class="line"></span><br><span class="line">利用了异或的原理，1^1 = 0，0^n = n;</span><br></pre></td></tr></table></figure></treenode></treenode></integer></integer></integer></p><p>class Solution{<br>    public int singleNumber(int[] nums){<br>        int result = nums[0];<br>        for(int i=1;i&lt;nums.length;i++){<br>            result = nums[i]^result;<br>        }<br>        return result;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行用时1ms,击败了99.44%的用户  </span><br><span class="line">内存消耗38.7MB,击败了0.89%的用户  </span><br><span class="line"></span><br><span class="line"># 344.反转字符串 #</span><br><span class="line">&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。  </span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。  </span><br><span class="line">你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&gt;示例 1：  </span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]  </span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class="line"></span><br><span class="line">&gt;示例 2：  </span><br><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]  </span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></p><p>class Solution {<br>    public void reverseString(char[] s) {<br>        for(int i=0,j = s.length-1;i&lt;j;i++,j–) {<br>            char tmp = s[i];<br>            s[i] = s[j];<br>            s[j] = tmp;<br>        }<br>        for(int i=0;i&lt;s.length;i++) {<br>            System.out.print(s[i]);<br>        }<br>    }<br>}<br><code>`</code><br>执行用时</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;/a&gt;1.两数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
